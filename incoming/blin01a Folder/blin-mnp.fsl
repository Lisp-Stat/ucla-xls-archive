(XLISP::CHECK-FSL-VERSION 1 3)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #("blin-mnp" PROVIDE) 0 NIL)
#K(#(80 1 3 0 1 2 4 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 4 2 4 5 0 3 5 16 5 6 21 1 4 5 5 38 7 7 23 8 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 9 7 23 8 0 4 4 7 2 1 23 10 0 2 2 4 11 0 2) #(0 20 25 30 47 68) #((NAME VARIABLES TREE-NODE NEIGHBOURS PRINT-NAME LOCATION VAR_B_INV EX_B RESOLUTIONS SIZE-RATIOS GLOBAL-SIZE-RATIOS) MORAL-NODE-PROTO NIL MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&key (stream t))
Method to print (to stream) a little information about a node.
Returns nil." :INFO #K(#(77 3 2 0 0 0 12 11 11 0 1 2 3 4 5 6 7 8 9 10 1 62 13 14 23 13 0 3 2 12 14 62 11 14 23 13 0 3 2 10 14 62 9 14 23 13 0 3 2 8 14 38 14 14 23 15 14 2 1 14 23 13 0 3 2 7 14 62 6 14 23 13 0 3 2 5 14 38 16 14 23 15 14 2 1 14 23 13 0 3 2 4 14 11 0 3) #(0) #(NIL "~&Plot location: ~a" "~&Neighbours: ~a" NEIGHBOURS "~&Contained in tree-node: ~a" "~&Variables: ~a" VARIABLES "~&Print name: ~a" PRINT-NAME "~&Moral Graph Node: ~a" NAME (T) (:STREAM) FORMAT :TREE-NODE SEND :LOCATION) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:INFO) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (loc nil))
Sets or returns node location (for plotting purposes). Location
is a list of 2 floats on a (0,1) scale." :LOCATION #K(#(77 1 2 1 1 1 0 0 21 0 1 2 2 63 3 2 0 57 0 62 3 0 57 0) #(0 13 19) #(LOCATION #(NIL)) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:LOCATION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (node nil))
Sets or returns the encompassing tree-node." :TREE-NODE #K(#(77 1 2 1 1 1 0 0 21 0 1 2 2 63 3 2 0 57 0 62 3 0 57 0) #(0 13 19) #(TREE-NODE #(NIL)) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:TREE-NODE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (name nil))
Sets or returns the print name." :PRINT-NAME #K(#(77 1 2 1 1 1 0 0 21 0 1 2 2 63 3 2 0 57 0 62 3 0 57 0) #(0 13 19) #(PRINT-NAME #(NIL)) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:PRINT-NAME) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (var-list (slot-value 'variables)))
Returns an expectation vector for the given variable list.
Defaults to the full expectation vector for the node." :EX #K(#(77 1 2 1 2 2 0 1 3 21 2 1 2 2 0 2 5 1 3 62 3 5 62 4 6 23 3 6 1 6 38 4 7 25 5 0 3 6 7 5) #(0 14 19 22) #(VARIABLES TREE-NODE #(%NOT-SUPPLIED) SYMBOL-VALUE :EX SEND) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:EX) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (var-list (slot-value 'variables)))
Returns a variance matrix for the given variable list.
Defaults to the full variance matrix for the node." :VAR #K(#(77 1 2 1 2 2 0 1 3 21 2 1 2 2 0 2 5 1 3 62 3 5 62 4 6 23 3 6 1 6 38 4 7 25 5 0 3 6 7 5) #(0 14 19 22) #(VARIABLES TREE-NODE #(%NOT-SUPPLIED) SYMBOL-VALUE :VAR SEND) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:VAR) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (var-list (slot-value 'variables)))
Returns an adjusted expectation vector for the given
variable list. Defaults to the full vector for the node." :AEX #K(#(77 1 2 1 2 2 0 1 3 21 2 1 2 2 0 2 5 1 3 62 3 5 62 4 6 23 3 6 1 6 38 4 7 25 5 0 3 6 7 5) #(0 14 19 22) #(VARIABLES TREE-NODE #(%NOT-SUPPLIED) SYMBOL-VALUE :AEX SEND) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:AEX) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (var-list (slot-value 'variables)))
Returns an adjusted variance matrix for the given
variable list. Defaults to the full matrix for the node." :AVAR #K(#(77 1 2 1 2 2 0 1 3 21 2 1 2 2 0 2 5 1 3 62 3 5 62 4 6 23 3 6 1 6 38 4 7 25 5 0 3 6 7 5) #(0 14 19 22) #(VARIABLES TREE-NODE #(%NOT-SUPPLIED) SYMBOL-VALUE :AVAR SEND) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:AVAR) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (var-list (slot-value 'variables)))
Returns a resolved variance matrix for the given
variable list. Defaults to the full matrix for the node." :RVAR #K(#(77 1 2 1 2 2 0 1 3 21 2 1 2 2 0 2 5 1 3 62 3 5 62 4 6 23 3 6 1 6 38 4 7 25 5 0 3 6 7 5) #(0 14 19 22) #(VARIABLES TREE-NODE #(%NOT-SUPPLIED) SYMBOL-VALUE :RVAR SEND) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:RVAR) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (var-list (slot-value 'variables)))
Returns a resolution transform matrix for the given
variable list. Defaults to the full matrix for the node." :TRANSFORM #K(#(77 1 2 1 2 2 0 1 2 21 2 2 1 2 62 3 0 62 4 5 38 3 6 23 4 6 2 1 6 25 5 0 2 5 6) #(0 14 17) #(VARIABLES VAR_B_INV #(%NOT-SUPPLIED) :RVAR SEND %*) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:TRANSFORM) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (var-list (slot-value 'variables)))
Returns the resolution for the given variable list for the current
adjustment. Defaults to the overall resolution for the node." :RESOLUTION #K(#(77 1 2 1 1 1 0 3 21 2 1 2 2 0 2 4 1 3 62 3 4 38 2 5 23 3 5 2 1 5 23 4 5 1 5 23 5 5 1 5 23 6 6 1 4 2 47 5 6 0 57 0) #(0 13 18 21) #(VARIABLES #(%NOT-SUPPLIED) :TRANSFORM SEND DIAGONAL SUM LENGTH) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:RESOLUTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (var-list (slot-value 'variables)))
Returns the bearing vector for the given variable list for the current
adjustment. Defaults to the overall bearing for the node." :BEARING #K(#(77 1 2 1 2 2 0 1 3 21 2 1 2 2 0 2 5 1 3 62 3 5 62 4 6 23 3 6 1 6 38 4 7 25 5 0 3 6 7 5) #(0 14 19 22) #(VARIABLES TREE-NODE #(%NOT-SUPPLIED) SYMBOL-VALUE :BEARING SEND) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:BEARING) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (var-list (slot-value 'variables)))
Returns the size ratio for the given variable list for the current
adjustment. Defaults to the overall size-ratio for the node." :SIZE-RATIO #K(#(77 1 2 1 2 2 0 1 5 21 2 1 2 2 0 2 5 1 3 62 3 5 38 3 6 23 4 6 3 1 6 5 38 5 7 23 4 7 3 1 7 5 2 45 6 7 6 38 6 7 23 4 7 3 1 7 4 38 3 8 23 4 8 3 1 8 5 38 5 9 23 4 9 3 1 9 5 2 45 8 9 8 23 7 6 3 6 7 8 23 8 7 1 5 2 47 6 7 0 57 0) #(0 14 19 22) #(VARIABLES VAR_B_INV #(%NOT-SUPPLIED) :AEX SEND :EX :SLOT-VALUE %* LENGTH) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:SIZE-RATIO) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (var-list (slot-value 'variables)))
Returns the global size ratio for the given variable list for the
adjustment. Defaults to the overall size-ratio for the node." :GLOBAL-SIZE-RATIO #K(#(77 1 2 1 3 3 0 1 2 5 21 2 1 2 2 0 2 6 1 3 62 3 6 38 4 7 23 5 7 3 1 7 6 62 5 8 2 45 7 8 7 38 6 8 23 5 8 3 1 8 4 38 4 9 23 5 9 3 1 9 6 62 5 10 2 45 9 10 9 23 7 7 3 7 8 9 23 8 8 1 6 2 47 7 8 0 57 0) #(0 15 20 23) #(VARIABLES VAR_B_INV EX_B #(%NOT-SUPPLIED) :AEX SEND :SLOT-VALUE %* LENGTH) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:GLOBAL-SIZE-RATIO) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (vars data)
Expects a list of variables to be observed, and a vector of
observations. Returns nil." :OBSERVE #K(#(80 4 1 0 2 62 4 5 23 1 5 1 5 38 2 6 25 3 0 4 5 6 2 3) #(0) #(TREE-NODE SYMBOL-VALUE :OBSERVE SEND) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:OBSERVE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: ()
Send this to the observed node on the moral graph for current evidence 
to be absorbed into the graph." :ABSORB #K(#(80 2 1 0 2 62 2 3 23 1 3 1 3 38 2 4 25 3 0 2 3 4) #(0) #(TREE-NODE SYMBOL-VALUE :ABSORB SEND) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ABSORB) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (node)
Removes the given node from the neighbour list of the recieving node.
Returns nil." :REMOVE-NEIGHBOUR #K(#(80 3 1 0 2 62 3 4 23 1 5 1 2 23 2 4 2 4 5 63 3 4 0 57 0) #(0) #(NEIGHBOURS LIST SET-DIFFERENCE) 0 NIL) MORAL-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:REMOVE-NEIGHBOUR) 0 NIL)) EVAL) 0 NIL)
