\begin{slide}{}
\chapter{Objects}
\end{slide}

\begin{slide}{}
\section{Some Background}
Some basic features of object oriented programming include
\begin{itemize}
\item mutable state information
\item messages and methods
\item inheritance
\end{itemize}
Some people add other features, or place different emphasis on
different features.
\end{slide}

\begin{slide}{}
\subsection{Origins of OOP}
\begin{itemize}
\item
Earliest example: {\em Simula}, a simulation language.
\item
First ``pure'' object oriented language: {\em Smalltalk}.
\item
Smalltalk was used for interacting with graphical objects, building
graphical user interfaces.
\item
The Macintosh user interface inherits many features from the
Smalltalk-based Xerox system.
\end{itemize}
\end{slide}

\begin{slide}{}
\subsection{Some Variations}
\begin{itemize}
\item
Languages/systems can be purely object oriented or just support object
oriented programming.
\item
Two different approaches are used:
\begin{itemize}
\item class/inheritance systems
\item prototype/delegation systems
\end{itemize}
\item
Most newer systems support some form of multiple inheritance.
\end{itemize}
\end{slide}

\begin{slide}{}
\subsection{Some OOP Systems}
\begin{itemize}
\item {\em C++}\/ from ATT
\item {\em Objective C}, used in NeXT computers.
\item {\em Smalltalk-80}
\item {\em Object Pascal}, for programming the Macintosh.
\item {\em Flavors}, on {\em Symbolics}\/ Lisp machines
\item {\em Lisp Object Oriented Programming System (LOOPS)}
\item {\em Object Lisp}
\item {\em Portable Common LOOPS}
\item {\em CLOS}, the new Common Lisp standard
\item {\em Common Objects}, from HP Labs.
\end{itemize}
\end{slide}

\begin{slide}{}
\subsection{References on OOP}
\begin{itemize}
\item[]
Abelson, H. and Sussman, G. J., (1985), {\em Structure and Interpretation
of Computer Programs}, Cambridge, Ma: MIT Press.

\item[]
Winston, P. H. and Horn, B. K. P., (1988), {\em Lisp}, 3rd Edition,
Reading, Ma: Addison Wesley.

\item[]
Keene, S. E., (1989), {\em Object-Oriented Programming in Common Lisp: A
Programmer's Guide to CLOS}, Reading, Ma: Addison Wesley.

\item[]
{\em Proceedings of the ACM Conference on Object-Oriented Systems, Languages
and Applications (OOPSLA)}, in {\em ACM SIGPLAN Notices}, (1986-91).

\item[]
Wegner, P., (1990), ``Concepts and paradigms of object-oriented
programming,'' {\em ACM SIGPLAN Messenger}, vol. 1.
\end{itemize}
\end{slide}

\begin{slide}{}
\section{Introduction}
Suppose we would like to build an ``intelligent'' function for describing
or plotting a data set.

Initially we are looking at three types of data:
\begin{itemize}
\item single samples
\item multiple samples
\item paired samples
\end{itemize}
A \dcode{describe-data} function might be written as
\begin{flushleft}\Large\tt
(defun describe-data (data)\\
~~(cond\\
~~~((single-sample-p data) ...)\\
~~~((multiple-sample-p data) ...)\\
~~~((paired-sample-p data) ...)\\
~~~(t (error "don't know how to \~\\
~~~~~~~~~~~~~~describe this data set"))))
\end{flushleft}
\end{slide}

\begin{slide}{}
Now suppose we come up with a fourth type, a simple time series.

We would have to edit this function, possibly breaking good code. 

An alternative is to arrange for the appropriate code to be looked up
in the data set itself -- to dispatch on the data set type.

We would need some way of defining new data types and actions.

This is the basis of object oriented programming.
\end{slide}

\begin{slide}{}
\subsection{Some Terms}
An {\em object}\/ is a data structure that contains information in
{\em slots}.

Objects respond to {\em messages}\/ asking them to take certain
actions.

A message is {\em sent} to an object using the function \dcode{send}
in an expression like
\begin{flushleft}\Large\tt
(send \param{object} \param{selector} \param{arg-1} ... \param{arg-n})
\end{flushleft}
The \param{selector} is a keyword symbol used to identify the message.
\end{slide}

\begin{slide}{}
As an example, the \dcode{histogram} function returns a histogram object:
{\Large
\begin{verbatim}
> (setf p (histogram (normal-rand 20)))
#<Object: 1750540, prototype = HISTOGRAM-PROTO>
\end{verbatim}}
The object can be sent a message to add an additional set of points:
{\Large
\begin{verbatim}
> (send p :add-points (normal-rand 20))
NIL
\end{verbatim}}
The {\em message selector}\/ for the message is \dcode{:add-points}.

The {\em message argument}\/ is the sample of normal variables
generated by the expression \dcode{(normal-rand 20)}.

The {\em message}\/ consists of the selector and the arguments.

The procedure called to respond to this message is the {\em method}\/
for the message.
\end{slide}

\begin{slide}{}
\subsection{Inheritance and the Root Object}
Objects are organized in an {\em inheritance hierarchy}.

At the top is the {\em root object}, the value of \dcode{*object*}.

The root object contains methods for standard messages, such as
\begin{itemize}
\item[] \dcode{:own-slots} -- list of slots in an object
\item[] \dcode{:add-slot} -- insert a new slot 
\item[] \dcode{:delete-slot} -- delete a slot
\item[] \dcode{:slot-value} -- access or modify a slot's value
\end{itemize}
\end{slide}

\begin{slide}{}
Some examples:
{\Large
\begin{verbatim}
> (send *object* :own-slots)
(DOCUMENTATION PROTO-NAME INSTANCE-SLOTS)

> (send *object* :slot-value 'proto-name)
*OBJECT*

> *object*
#<Object: 302253140, prototype = *OBJECT*>

> (send *object* :slot-value 'instance-slots)
NIL
\end{verbatim}}
\end{slide}

\begin{slide}{}
\subsection{Constructing New Objects}
The root object is a {\em prototype}\/ object.

Prototypes serve as templates for building new objects -- {\em instances}.

The \dcode{:new} message is used to ask a prototype for a new instance.

Let's use an object to represent a data set:
{\Large
\begin{verbatim}
> (setf x (send *object* :new))
#<Object: 1750672, prototype = *OBJECT*>
\end{verbatim}}
Initially, the object has no slots of its own:
{\Large
\begin{verbatim}
> (send x :own-slots)
NIL
\end{verbatim}}
\end{slide}

\begin{slide}{}
We can add a slot for some data and a slot for a title string:
{\Large
\begin{verbatim}
> (send x :add-slot 'data (normal-rand 50))
(1.39981 -0.0601746 ....)
> (send x :add-slot 'title)
NIL
> (send x :own-slots)
(TITLE DATA)
> (send x :slot-value 'title)
NIL
> (send x :slot-value 'title "a data set")
"a data set"
> (send x :slot-value 'title)
"a data set"
\end{verbatim}}
\end{slide}

\begin{slide}{}
\subsection{Defining New Methods}
The code used to respond to a message is called a {\em method}.
 
\dcode{send} searches the receiving object and its ancestors until it
finds a method.

All messages used so far used methods in the root object.

New methods can be defined using \dcode{defmeth}.

The general form of a \dcode{defmeth} expression is:
\begin{flushleft}\Large\tt
(defmeth \param{object} \param{selector} \param{parameters}\\
~~\param{body})
\end{flushleft}
The argument \param{object} is evaluated, the others are not.
\end{slide}

\begin{slide}{}
An example:
{\Large
\begin{verbatim}
(defmeth x :describe (&optional (stream t))
  (let ((title (slot-value 'title))
        (data (slot-value 'data)))
    (format stream "This is ~a~%" title)
    (format stream
            "The sample mean is ~a~%"
            (mean data))
    (format stream
            "The sample SD is ~a~%"
            (standard-deviation data))))
\end{verbatim}}
The definition looks like a \dcode{defun}, except for the object
expression appearing as the first argument.

The new \dcode{:describe} method can be used like any other method:
{\Large
\begin{verbatim}
> (send x :describe)
This is a data set
The sample mean is 0.127521
The sample SD is 1.0005
NIL
\end{verbatim}}
\end{slide}

\begin{slide}{}
A few notes:
\begin{itemize}
\item
Within a method, the variable \dcode{self} refers to the object receiving
the message.
\item
\dcode{self} is needed since methods can be inherited.
\item
\dcode{self} is added to the environment for the function body before
the other arguments.
\item
Within a method, the function \dcode{slot-value} can be used to access
a slot.

Using this function is more efficient than using the
\dcode{:slot-value} message.
\item
The \dcode{slot-value} function can {\em only}\/ be used in the body of
a method.
\item
Within a method, \dcode{slot-value} can be used as a place form with
\dcode{setf}.
\end{itemize}
\end{slide}

\begin{slide}{}
It is good programming practice not to assume too much about the slots
an object has.

For our data set object, we can write {\em accessor methods}\/ for the
title and data slots:
{\Large
\begin{verbatim}
(defmeth x :title (&optional (title nil set))
  (if set (setf (slot-value 'title) title))
  (slot-value 'title))

(defmeth x :data (&optional (data nil set))
  (if set (setf (slot-value 'data) data))
  (slot-value 'data))
\end{verbatim}}
Using these accessors we can rewrite the \dcode{:describe} method:
{\Large
\begin{verbatim}
(defmeth x :describe (&optional (stream t))
  (let ((title (send self :title))
        (data (send self :data)))
    (format stream "This is ~a~%" title)
    (format stream
            "The sample mean is ~a~%"
            (mean data))
    (format stream
            "The sample SD is ~a~%"
     (standard-deviation data))))
\end{verbatim}}
\end{slide}

\begin{slide}{}
\subsection{Printing Objects}
The printing system prints objects by sending them the \dcode{:print}
message.

A method for \dcode{:print} must take an optional {\em stream}\/ argument.

A simple \dcode{:print} method for our data set:
{\Large
\begin{verbatim}
(defmeth x :print (&optional (stream t))
  (format stream "#<~a>" (send self :title)))
\end{verbatim}}
The result is
{\Large
\begin{verbatim}
> x
#<a data set>
\end{verbatim}}
\end{slide}

\begin{slide}{}
\subsection{Help Information for Messages}
If we change the definition of the \dcode{:describe} method to
{\Large
\begin{verbatim}
(defmeth x :describe (&optional (stream t))
"Method args: (&optional (stream t))
Prints a simple description of the object
to STREAM."
  (let ((title (send self :title))
        (data (send self :data)))
    ...))
\end{verbatim}}
then the string is used as a documentation string: {\Large
\begin{verbatim}
> (send x :help :describe)
:DESCRIBE
Method args: (&optional (stream t))
Prints a simple description of the object
to STREAM.
NIL
\end{verbatim}}
\end{slide}

\begin{slide}{}
\section{Prototypes}
\subsection{Creating Simple Prototypes}
Instead of repeating the process used so far for each new data set, we
can construct a {\em dataset prototype}\/ using \dcode{defproto}.

The simplest form of a \dcode{defproto} expression is
\begin{flushleft}\Large\tt
(defproto \param{name} \param{instance slots})
\end{flushleft}
\dcode{defproto} evaluates \param{instance slots} and
\begin{itemize}
\item
constructs a new object, assigns it to the global variable \param{name}
\item
installs a slot \dcode{proto-name} with value \dcode{name}
\item
installs a slot \dcode{instance-slots} with the symbols from
\param{instance slots}
\item
installs a slot with value nil for each symbol in the
\dcode{instance-slots} list
\end{itemize}
Different instances created from a prototype usually differ only in
the values of their instance slots.
\end{slide}

\begin{slide}{}
We can define a prototype for our data set as
{\Large
\begin{verbatim}
(defproto data-set-proto '(data title))
\end{verbatim}}
Prototype objects are like any other objects.

We can place values in their slots
{\Large
\begin{verbatim}
(send data-set-proto :slot-value
      'title "a data set")
\end{verbatim}}
and we can define methods for them:
{\Large
\begin{verbatim}
(defmeth data-set-proto
         :title (&optional (title nil set))
  (if set (setf (slot-value 'title) title))
  (slot-value 'title))

(defmeth data-set-proto :data ...)

(defmeth data-set-proto :describe ...)

(defmeth data-set-proto :print ...)

(defmeth data-set-proto :plot ()
  (histogram (send self :data)
             :title (send self :title)))
\end{verbatim}}
\end{slide}

\begin{slide}{}
\subsection{Creating Instances from Prototypes}
An instance is created by sending a prototype the \dcode{:new}
message.

The method for this message does the following:
\begin{itemize}
\item
creates a new object that inherits from the prototype
\item
adds a slot for each symbol in the prototype's \dcode{instance-slots}
list
\item
sets the value of each new slot to its value in the prototype
\item
sends the new object the \dcode{:isnew} message with the arguments
given to \dcode{:new}
\item
returns the new object
\end{itemize}
\end{slide}

\begin{slide}{}
The root object \dcode{:isnew} initialization method allows slots to
be initialized by keyword arguments:
{\Large
\begin{verbatim}
> (setf x (send data-set-proto :new
                :data (chisq-rand 20 5)))
#<a data set>
> (send x :title)
"a data set"
> (send x :data)
(10.7254 10.4314 2.32346 ...)
> (send x :describe)
This is a data set
The sample mean is 5.17844
The sample SD is 3.2129
\end{verbatim}}
\end{slide}

\begin{slide}{}
Any data set needs its own data.

We can define an \dcode{:isnew} method that requires a data argument:
{\Large
\begin{verbatim}
(defmeth data-set-proto
         :isnew (data &key title)
  (send self :data data)
  (if title (send self :title title)))
\end{verbatim}}
It is often useful to define an appropriate \dcode{:isnew}
initialization method.

It is (almost) never necessary to define a new \dcode{:new}
method.
\end{slide}

\begin{slide}{}
\subsection{Prototypes and Inheritance}
Prototypes can inherit from other objects, usually other prototypes.

The full form of a \dcode{defproto} expression is
\begin{flushleft}\Large\tt
(defproto \param{name}\\
~~~~~~~~~~\param{instance slots}\\
~~~~~~~~~~\param{shared slots}\\
~~~~~~~~~~\param{parents}\\
~~~~~~~~~~\param{doc string})
\end{flushleft}
All arguments except the first are evaluated.

\param{instance slots} and \param{shared slots} should be \dcode{nil}
or lists of symbols.

We won't be using shared slots.

\param{parents} should be a single object or a list of objects -- the
default is the root object.

The instance slots of the new prototype are
the union of the \param{instance slots} in the call and the 
instance slots of all ancestors.

So you only need to specify {\em additional}\/ slots you want.
\end{slide}

\begin{slide}{}
An equally-spaced time series prototype might add \dcode{origin} and
\dcode{spacing} slots:
{\Large
\begin{verbatim}
(defproto time-series-proto
          '(origin spacing) () data-set-proto)
\end{verbatim}}
Accessor methods for the new slots:
{\Large
\begin{verbatim}
(defmeth time-series-proto
         :origin (&optional (origin nil set))
  (if set (setf (slot-value 'origin) origin))
  (slot-value 'origin))

(defmeth time-series-proto
         :spacing (&optional (sp nil set))
  (if set (setf (slot-value 'spacing) sp))
  (slot-value 'spacing))
\end{verbatim}}
and default values for the \dcode{title} slot and the new slots can be
set as
{\Large
\begin{verbatim}
(send time-series-proto :title "a time series")
(send time-series-proto :origin 0)
(send time-series-proto :spacing 1)
\end{verbatim}}
\end{slide}

\begin{slide}{}
An example -- a short moving average series:
{\Large
\begin{verbatim}
> (let* ((e (normal-rand 21))
         (i (iseq 1 20))
         (d (+ (select e i)
               (* 0.6 (select e (- i 1))))))
    (setf y (send time-series-proto :new d)))
#<a time series>
> (send y :describe)
This is a time series
The sample mean is 0.194134
The sample SD is 1.15485
\end{verbatim}}
\end{slide}

\begin{slide}{}
\subsection{Overriding and Modifying Inherited Methods}
The inherited \dcode{:plot} and \dcode{:describe} methods are not
optimal for a time series.

We can {\em override}\/ the \dcode{:plot} method with the definition
{\Large
\begin{verbatim}
(defmeth time-series-proto :plot ()
  (let* ((data (send self :data))
         (start (send self :origin))
         (step (send self :spacing))
         (n (length data)))
    (plot-points (+ start (* step (iseq n)))
                 data)))
\end{verbatim}}
\end{slide}

\begin{slide}{}
Instead of overriding the \dcode{:describe} method completely,
we can augment it:
{\Large
\begin{verbatim}
(defmeth time-series-proto
         :describe (&optional (stream t))
  (let ((ac (autocor (send self :data))))
    (call-next-method stream)
    (format stream
            "The autocorrelation is ~a~%"
            ac)))
\end{verbatim}}
The \dcode{call-next-method} function calls the next method for the
current selector
\begin{flushleft}\Large\tt
(call-next-method \param{arg-1} ... \param{arg-n})
\end{flushleft}
The \dcode{autocor} function can be defined as
{\Large
\begin{verbatim}
(defun autocor (x)
  (let ((n (length x))
        (x (- x (mean x))))
    (/ (mean (* (select x (iseq 0 (- n 2))) 
                (select x (iseq 1 (- n 1)))))
       (mean (* x x)))))
\end{verbatim}}
\end{slide}

\begin{slide}{}
\subsection{Some Cautions}
\begin{itemize}
\item
Unfortunately the object system does not allow you to hide slots and
messages intended for internal use from public access.
\item
To protect yourself against breaking inherited methods you need to
follow a few guidelines:
\begin{itemize}
\item
Don't use slot names you didn't add yourself.
\item
Don't modify slots unless you are sure it is safe.
\item
Don't define methods for messages unless you know this won't do any
harm.
\end{itemize}
\end{itemize}
\end{slide}

\begin{slide}{}
\section{Examples}
\subsection{Survival Function Estimator}
We can use an object to organize our tools for fitting a survival function.

Since we need the unique death times, death counts, and numbers at risk,
we can define a prototype that adds slots to hold these values:
{\Large
\begin{verbatim}
(defproto survival-proto
          '(death-times num-deaths num-at-risk)
          ()
          data-set-proto)

(send survival-proto :title
      "a survival data set")
\end{verbatim}}
Accessors for these three slots are defined as
{\Large
\begin{verbatim}
(defmeth survival-proto :death-times ()
  (slot-value 'death-times))
(defmeth survival-proto :num-deaths ()
  (slot-value 'num-deaths))
(defmeth survival-proto :num-at-risk ()
  (slot-value 'num-at-risk))
\end{verbatim}}
\end{slide}

\begin{slide}{}
The \dcode{data} slot can be used to hold both the times and the
death indicators.

The accessor method can be defined as
{\Large
\begin{verbatim}
(defmeth survival-proto :data
         (&optional times status)
  (when times
    (call-next-method (list times status))
    (let* ((i (which (= 1 status)))
           (dt (select times i))
           (dt-list (coerce dt 'list))
           (udt (sort-data (remove-duplicates
                            dt-list
                            :test #'=)))
           (d (mapcar
               #'(lambda (x)
                 (count x dt-list :test #'=))
               udt))
           (r (mapcar
               #'(lambda (x)
                 (count x times :test #'<=))
               udt)))
      (setf (slot-value 'death-times) udt)
      (setf (slot-value 'num-deaths) d)
      (setf (slot-value 'num-at-risk) r)))
  (slot-value 'data))
\end{verbatim}}
\end{slide}

\begin{slide}{}
The \dcode{:isnew} method fills in the data:
{\Large
\begin{verbatim}
(defmeth survival-proto :isnew
         (times status &optional title)
  (send self :data times status)
  (if title (send self :title title)))
\end{verbatim}}
A \dcode{:describe} method:
{\Large
\begin{verbatim}
(defmeth survival-proto :describe
         (&optional (stream t))
  (let ((title (send self :title))
        (data (send self :data)))
    (format stream "This is ~a~%" title)
    (format stream
            "The mean time is ~a~%"
            (mean (first data)))
    (format stream
            "The number of failures is ~a~%"
            (sum (second data)))))
\end{verbatim}}
A \dcode{:plot} method:
{\Large
\begin{verbatim}
(defmeth survival-proto :plot ()
  (let ((km (send self :km-estimator))
        (udt (send self :death-times)))
    (plot-lines (make-steps udt km))))
\end{verbatim}}
\end{slide}

\begin{slide}{}
A method for the Kaplan-Meier estimator:
{\Large
\begin{verbatim}
(defmeth survival-proto :km-estimator ()
  (let ((r (send self :num-at-risk))
        (d (send self :num-deaths)))
    (accumulate #'* (/ (- r d) r))))
\end{verbatim}}
Methods for the Fleming-Harrington estimator and standard errors based on
Greenwood's formula and Tsiatis' formula are
{\Large
\begin{verbatim}
(defmeth survival-proto :fh-estimator ()
  (let ((r (send self :num-at-risk))
        (d (send self :num-deaths)))
    (exp (- (cumsum (/ d r))))))

(defmeth survival-proto :greenwood-se ()
  (let* ((r (send self :num-at-risk))
         (d (send self :num-deaths))
         (km (send self :km-estimator))
         (rd1 (pmax (- r d) 1)))
    (* km (sqrt (cumsum (/ d r rd1))))))

(defmeth survival-proto :tsiatis-se ()
  (let ((r (send self :num-at-risk))
        (d (send self :num-deaths))
        (km (send self :km-estimator)))
    (* km (sqrt (cumsum (/ d (^ r 2)))))))
\end{verbatim}}
\end{slide}

\begin{slide}{}
\subsection{Model Prototypes}
Linear regression, nonlinear regression and GLIM model
prototypes are arranged as:
\begin{center}
\begin{picture}(400,380)
%\put(105,350){\protoimage{regression-model-proto}}
\put(200,360){\makebox(0,0){\tt regression-model-proto}}
\put(200,360){\oval(250,20)}
\put(0,280){\protoimage{nreg-model-proto}}
\put(105,210){\protoimage{glim-proto}}
\put(0,140){\protoimage{poissonreg-proto}}
\put(105,90){\protoimage{binomialreg-proto}}
\put(210,140){\protoimage{gammareg-proto}}
\put(0,20){\protoimage{logitreg-proto}}
\put(210,20){\protoimage{probitreg-proto}}
\put(200,350){\line(0,-1){130}}
\put(200,350){\line(-2,-1){100}}
\put(200,210){\line(0,-1){100}}
\put(200,210){\line(-2,-1){100}}
\put(200,210){\line(2,-1){100}}
\put(200,90){\line(-2,-1){100}}
\put(200,90){\line(2,-1){100}}
\end{picture}
\end{center}
\end{slide}

\begin{slide}{}
\section{OOP and User Interfaces}
Users of a graphics workstation can take a limited set of actions.

They can
\begin{itemize}
\item hit keys
\item move the pointer
\item click the pointer
\end{itemize}
These actions can be viewed as messages that are being sent to
objects on the screen.

Graphical user interfaces present users with a model based on a desk:
\begin{itemize}
\item
Overlapping windows act like sheets of paper
\item
Different windows represent different software objects on the screen
\item
Each object may respond differently to key stroke or locator click
messages
\end{itemize}
\end{slide}

\begin{slide}{}
The {\em user interface conventions} of the window system
determine what objects receive what messages.

Several variations are possible:
\begin{itemize}
\item
On the Macintosh the front window receives all input.

A window becomes the front window by clicking on it.
\item
Under {\em twm}\/ in an {\em X11}\/ system, the window containing the
locator cursor receives all input.
\end{itemize}
Most window management systems are object-oriented in design.

The window system is responsible for converting user actions into
messages.

The programmer is responsible for defining any methods objects
need in order to respond to the user's actions.
\end{slide}

\begin{slide}{}
Some other variations include:
\begin{itemize}
\item
size and location of windows may have to be determined by the user
\item
resizing or moving windows from within a program may not be possible
\item
menus may be popped up or pulled down
\item
mouse buttons may mean different things in different settings
\item
mice have different numbers of buttons
\end{itemize}
\end{slide}

\begin{slide}{}
\section{Menus}
Menus are created using the \dcode{menu-proto} prototype.

The initialization method requires a single argument, the menu title.
{\Large
\begin{verbatim}
> (setf data-menu
        (send menu-proto :new "Data"))
#<Object: 4055334, prototype = MENU-PROTO>
\end{verbatim}}
A menu bar is available for holding menus not associated with a graph.

The \dcode{:install} message installs a menu; \dcode{:remove} removes it:
{\Large
\begin{verbatim}
> (send data-menu :install)
NIL
> (send data-menu :remove)
NIL
\end{verbatim}}
\end{slide}

\begin{slide}{}
Initially a menu contains no items.

Items are created using the \dcode{menu-item-proto} prototype.

The initialization method requires one argument, the item's title.

It also accepts several keyword arguments, including
\begin{itemize}
\item
\dcode{:action} -- a function to be called when the item is selected
\item
\dcode{:enabled} -- true by default
\item
\dcode{:key} -- a character to serve as the keyboard equivalent
\item
\dcode{:mark} -- \dcode{nil} (the default) or \dcode{t} to indicate a
check mark.
\end{itemize}
Analogous messages are available for accessing and changing these
values in existing menu items.
\end{slide}

\begin{slide}{}
Suppose we assign a data set object as the value of some global
symbol:
{\Large
\begin{verbatim}
(setf *current-data-set* x)
\end{verbatim}}
Two menu items for dealing with the current data set are:
{\Large
\begin{verbatim}
> (setf desc
        (send menu-item-proto :new "Describe"
              :action
              #'(lambda ()
                (send *current-data-set*
                      :describe))))
#<Object: 4034406, prototype = MENU-ITEM-PROTO>
> (setf plot 
        (send menu-item-proto :new "Plot"
              :action 
              #'(lambda ()
                (send *current-data-set*
                      :plot))))
#<Object: 3868686, prototype = MENU-ITEM-PROTO>
\end{verbatim}}
\end{slide}

\begin{slide}{}
You can force an item's action to be invoked by sending it the
\dcode{:do-action} message:
{\Large
\begin{verbatim}
> (send desc :do-action)
This is a data set
The sample mean is 4.165463
The sample SD is 1.921366
\end{verbatim}}

The system sends the \dcode{:do-action} message when you select the item
in a menu.

The \dcode{:append-items} message adds the items to the menu:
{\Large
\begin{verbatim}
> (send data-menu :append-items desc plot)
NIL
\end{verbatim}}
\end{slide}

\begin{slide}{}
On the Macintosh, the \dcode{:key} message adds a keyboard equivalent
to an item:
{\Large
\begin{verbatim}
> (send desc :key #\D)
#\D
\end{verbatim}}
This message is ignored on most other systems.

You can also enable and disable an item with the \dcode{:enabled}
message:
{\Large
\begin{verbatim}
> (send desc :enabled)
T
> (send desc :enabled nil)
NIL
> (send desc :enabled t)
T
\end{verbatim}}
Before a menu is presented, the system sends each of its menu items
the \dcode{:update} message.

You can define a method for this message that enables or disables the
item, or adds a check mark, as appropriate.
\end{slide}

\begin{slide}{}
\section{Dialogs}
Dialogs are similar to menus in that they are based on a dialog
prototype and dialog item prototypes.

There are, however many more variations.

Fortunately most dialogs you need fall into one of several categories
and can be produced by custom dialog construction functions.
\end{slide}

\begin{slide}{}
\subsection{Modal Dialogs}
Modal dialogs are designed to ask specific questions and wait until
they receive a response.

All other interaction is disabled until the dialog is dismissed -- they
place the system in dialog mode.

Six functions are available for producing some standard modal dialogs:

\begin{itemize}
\item
\dcode{(message-dialog \param{string})} -- presents a message with an
\macbold{OK} button; returns \dcode{nil} when the button is pressed.
\item
\dcode{(ok-or-cancel-dialog \param{string})} -- presents a message with an
\macbold{OK} and a \macbold{Cancel} button; returns \dcode{t} or \dcode{nil}
according to the button pressed.
\end{itemize}
\end{slide}

\begin{slide}{}
\begin{itemize}
\item
\dcode{\Large\tt(choose-item-dialog \param{string} \param{string-list})} --
presents a heading and a set of radio buttons for choosing one of the
strings.

Returns the index of the selected string on \macbold{OK} or
\dcode{nil} on \macbold{Cancel}.
{\Large
\begin{verbatim}
> (choose-item-dialog
   "Dependent variable:"
   '("X" "Y" "Z"))
1
\end{verbatim}}
\item
\dcode{\Large\tt(choose-subset-dialog \param{string} \param{string-list})} --
presents a heading and a set of check boxes for indicating which items
to select.

Returns a list of the list of selected indices on \macbold{OK} or
\dcode{nil} on \macbold{Cancel}.
{\Large
\begin{verbatim}
> (choose-subset-dialog
   "Independent variables:"
   '("X" "Y" "Z"))
((0 2))
\end{verbatim}}
\end{itemize}
\end{slide}

\begin{slide}{}
\begin{itemize}
\item
\dcode{\Large\tt(get-string-dialog \param{prompt} [:initial \param{expr}])}\\
presents a dialog with a prompt, an editable text field, an
\macbold{OK} and a \macbold{Cancel} button.

The initial contents of the editable field is empty or the
\verb+~a+-formated version of \param{expr}.

The result is a string or \dcode{nil}.
{\Large
\begin{verbatim}
> (get-string-dialog
   "New variable label:"
   :initial "X")
"Tensile Strength"
\end{verbatim}}
\item
\dcode{\Large\tt(get-value-dialog \param{prompt} [:initial \param{expr}])}\\
like \dcode{get-string-dialog}, except
\begin{itemize}
\item
the initial value expression is converted to a string with \verb+~s+
formatting
\item
the text is interpreted as a lisp expression and is evaluated
\item
the result is a list of the value, or \dcode{nil}
\end{itemize}
\end{itemize}
\end{slide}

\begin{slide}{}
There are two dialogs for dealing with files:
\begin{itemize}
\item
\dcode{(open-file-dialog)} -- presents a standard \macbold{Open File}
dialog and returns a file name string or \dcode{nil}.

Resets the working folder on \macbold{OK}.
\item
\dcode{(set-file-dialog \dcode{prompt})} -- presents a standard
\macbold{Save File} dialog.

Returns a file name string or \dcode{nil}.

Resets the working folder on \macbold{OK}.
\end{itemize}
In the {\em X11}\/ versions of these are currently just
\dcode{get-string-dialogs}.

The MS Windows versions are also not yet fully developed.
\end{slide}

\begin{slide}{}
\subsection{Modeless Dialogs}
Two standard modeless slider dialogs are available:
\begin{itemize}
\item
\dcode{sequence-slider-dialog} -- a slider for scrolling
through a sequence.

An action function is called each time the slider is adjusted.

The current sequence value or a value from a display sequence is displayed.
\item
\dcode{interval-slider-dialog} -- similar to the sequence slider, except
that a range to be divided up into a reasonable number of points is given.

By default, the range and number of points are adjusted to produce nice
printed values.
\end{itemize}
\end{slide}

\begin{slide}{}
\subsection{Custom Dialogs}
If the standard dialogs are not sufficient, you can construct custom
modal or modeless dialogs using a variety of items:
\begin{itemize}
\item static and editable text fields
\item radio button groups
\item check boxes
\item sliders
\item scrollable lists
\item push  buttons
\end{itemize}
\end{slide}
