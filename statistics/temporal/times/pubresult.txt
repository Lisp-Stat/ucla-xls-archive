





;       n.lsp
;       w.hatch Sun Aug 25 17:14:19 EDT 1991
;       uunet!bts!bill
;
(defun gt-select (data value)
        "----------------------------------------------------------------
        gt-select (data value) data is a list of lists; the component lists
        are assumed to be of the same length with the first list being
        time tags.  The returned object is a list of the original lists
        containing all elements having time tags greater than given value.
        -----------------------------------------------------------------"
        (let ((my-time 0) (n 0) (m 0) (value-index 0) (now-list 0) (out-list 0)
                (chop-tag 0))
                ;----------------------------------------------------------
                ; find the chop time tag
                ;----------------------------------------------------------
                (block gt
                        (setf m (length data))
                        (setf my-time (car data ))
                        (setf n (length my-time))
                        (block find-chop-point
                                (dotimes (i n)
                                        (setf find-index i)
                                        (if (greater-than (nth i my-time) value)
                                                (return-from find-chop-point)
                                        )
                                )
                        ) ; END find-chop-point
                        ;------------------------------------------------------
                        ; the chop tag is the tag prior to the find-index
                        ;------------------------------------------------------
                        (if (eql find-index 0)
                                (setf chop-tag 0)
                                (setf chop-tag  find-index)
                        )
                        ;------------------------------------------------------
                        ; chop beginning of each of the component list
                        ;------------------------------------------------------
                        (dotimes (i m)
                                (setf now-list (select data i))
                                (setf now-list (chop-first now-list chop-tag))
                                (if (eql i 0)
                                        (setf out-list now-list)
                                        (setf out-list (list out-list now-list))
                                )
                        )
                        (return-from gt out-list)
                ) ; END gt
        )
)
(defun lt-select (data value)
        "----------------------------------------------------------------
        lt-select (data value) data is a list of lists; the component lists
        are assumed to be of the same length with the first list being



                      January 15, 1992





                           - 2 -


        time tags.  The returned object is a list of the original lists
        containing all elements having time tags less than given value.
        -----------------------------------------------------------------"
        (let ((my-time 0) (n 0) (m 0) (value-index 0) (now-list 0) (out-list 0)
                (chop-tag 0))
                ;----------------------------------------------------------





                ; find the chop time tag
                ;----------------------------------------------------------
                (block gt
                        (setf m (length data))
                        (setf my-time (car data ))
                        (setf n (length my-time))
                        (block find-chop-point
                                (dotimes (i n)
                                        (setf find-index i)
                                        (if (>= (nth i my-time) value)
                                                (return-from find-chop-point)
                                        )
                                )
                        ) ; END find-chop-point
                        ;------------------------------------------------------
                        ; the chop tag is the tag prior to the find-index
                        ;------------------------------------------------------
                        (if (eql find-index 0)
                                (setf chop-tag 0)
                                (setf chop-tag  (- n find-index))
                        )
                        ;------------------------------------------------------
                        ; chop beginning of each of the component list
                        ;------------------------------------------------------
                        (dotimes (i m)
                                (setf now-list (select data i))
                                (setf now-list (chop-last now-list chop-tag))
                                (if (eql i 0)
                                        (setf out-list now-list)
                                        (setf out-list (list out-list now-list))
                                )
                        )
                        (return-from gt out-list)
                ) ; END gt
        )
)
(defun chop-first (x &optional ( n 1))
        "---------------------------------------------------------------
        chop-first (x &optional (n 1)) returns x with first n elements
        removed
        ----------------------------------------------------------------"
        (block chopping-first-block
                (let ( (new-list 0) )



                      January 15, 1992





                           - 3 -


                        (setf new-list x)
                        (dotimes (i n)
                                (setf new-list (cdr new-list))
                        )
                        (return-from chopping-first-block new-list)

                )  ; END let
        ) ; END chopping-first-block
)
(defun chop-last (x &optional ( n 1))
        "---------------------------------------------------------------
        chop-last (x &optional (n 1)) returns x with last n elements
        removed
        ----------------------------------------------------------------"
        (block chopping-last-block
                (let ( (new-list 0) )
                        (setf new-list (reverse x))





                        (dotimes (i n)
                                (setf new-list (cdr new-list))
                        )
                        (setf new-list (reverse new-list))
                        (return-from chopping-last-block new-list)
                )  ; END let
        ) ; END chopping-last-block
)
(defun assert-list (x name)
        "----------------------------------------------------------------
        assert-list (x name) print result of assertion that x is a list
        name is the symbol that is printed
        -----------------------------------------------------------------"
        (print "given object ")
        (prin1 name)
        (prin1 " -- ")
        (if (listp x)
                (prin1 " IS A LIST\n")
                (prin1 " IS A NOT LIST\n")
        )
)
(defun test-pass (x name-x)
        (def name-x 0)
        (prin1 name-x)
        (prin1  x)
        (prin1 "\n")

)
(defun range-delete (data &key (min-y minus-huge) (max-y huge))
        "----------------------------------------------------------------
        range-delete (data &key (min-y minus-huge) (max-y huge))
        data is a list of lists; there are assumed



                      January 15, 1992





                           - 4 -


        to be 2 component lists of the same length. Additional component
        lists are ignored.  The first list is assumed to be
        time tags and the second list y data values that correspond
        to the time tags.  range-delete returns a like list of lists with all
        data points having values greater than min-y and less than max-y
        -----------------------------------------------------------------"
        (block range-delete-tag
        (let ((n 0) (m 0) (new-y-data 0) (time-tags 0) (new-tags 0)
                (y-data 0))
                (setf m (length data))
                ;--------------------------------------------------------
                ; make sure data contains at least 2 lists
                ;--------------------------------------------------------
                (if (< m 2)
                        (return-from range-delete-tag
                                (my-error
                                  "range-delete: less than 2 component lists")
                        )
                )
                ;--------------------------------------------------------
                ; select first 2 component lists
                ;--------------------------------------------------------
                (setf time-tags (select data 0))
                (setf y-data    (select data 1))
                (setf n  (length time-tags))





                ;------------------------------------------------------
                ; verify that 2 given lists are the same length
                ;------------------------------------------------------
                (if (/= n (length y-data))
                        (return-from range-delete-tag
                                (my-error "
                          range-delete: component list lengths not equal")
                        )
                )
                ;------------------------------------------------------
                ; search for y-data elements greater than the given value
                ; if found then remove the offending elements from both
                ; time-tags and y-data
                ;------------------------------------------------------
                (dotimes (i n)
                        (when (and (> (nth i y-data) min-y)
                                        (< (nth i y-data) max-y))
                                (when (listp new-tags)
                                        (setf new-tags
                                           (combine new-tags (nth i time-tags))
                                        )
                                        (setf new-y-data
                                           (combine new-y-data (nth i y-data))
                                        )



                      January 15, 1992





                           - 5 -


                                )
                                (when (not (listp new-tags))
                                        (setf new-tags (list (nth i time-tags)))
                                        (setf new-y-data (list (nth i y-data)))

                                )
                        )
                )
                ;------------------------------------------------------
                ; return a compound list of the edited data
                ;------------------------------------------------------
                (setf new-data (list new-tags new-data))
        ) ; END let
        ) ; END block range-delete-tag
)
(defun my-error (msg)
        "---------------------------------------------------------------
         my-error (msg)  prints msg and returns nil
         ---------------------------------------------------------------"
        ( block my-error-tag
                (print msg)
                (prin1 "\n")
                (return-from my-eror-tag nil)
        ) ; END my-error-tag
)
(defun remove-from-list (x i)
        "---------------------------------------------------------------
        remove-from-list (x i)  returns list x with ith element removed
        if i is out of range the given list x is returned unchanged
         ---------------------------------------------------------------"
        (block remove-tag
        (let ((n 0) (pre-list 0) (post-list 0) (out-list 0))
                (setf n (length x))
                ;------------------------------------------------------
                ; if i out of range then return the given list
                ;------------------------------------------------------





                (if (< i 0) (return-from remove-tag x))
                (if (>= i n) (return-from remove-tag x))
                ;------------------------------------------------------
                ; handle the boundry conditions
                ;------------------------------------------------------
                (if (= i 0) (return-from remove-tag (chop-first x)))
                (if (= i (- n 1)) (return-from remove-tag (chop-last x)))
                ;------------------------------------------------------
                ; handle the interior conditions
                ;------------------------------------------------------
                (setf pre-list (chop-last x (- n i)))
                (setf post-list (chop-first x (+ 1 i)))
                (setf out-list (combine pre-list post-list))



                      January 15, 1992





                           - 6 -


        ) ; END let
        ) ; END remove-tag
)
(def max-int (- 2147483647 1))
(def min-int (- max-int))
(def max-short (- 32767 1))
(def min-short (- max-short))
(defun itoa (n)
        "----------------------------------------------------------------
        itoa(n) return integer converted to a string
        -----------------------------------------------------------------"
        (if (integerp n)
                (with-output-to-string (s) (princ n s))
                (print "not an integer\n")
        )
)
(defun ntoa (n)
        "----------------------------------------------------------------
        ntoa(n) return number converted to a string
        -----------------------------------------------------------------"
        (if (numberp n)
                (with-output-to-string (s) (princ n s))
                (print "not a number\n")
        )
)
(defun gmt-hhmmss (gmt)
        "----------------------------------------------------------------
        gmt-hhmmss (gmt) given gmt in seconds convert to hhmmss string
        -----------------------------------------------------------------"
        (let ((hr 0) (min 0) (sec 0) (size 0) (result 0) (hhmmss "")
                (iresult "") (n 0))
                (setf hr (truncate (/ gmt 3600)))
                (setf min (truncate (/ (- gmt (* hr 3600)) 60) ))
                (setf sec (- gmt (* 3600 hr)))
                (setf sec (truncate (- sec (* 60 min))))
                (setf result (+ (* 10000 hr) (* 100 min) sec))
                (setf iresult (itoa result))
                (setf size (strlen iresult))
                (setf n (- 6 size))
                (dotimes (j n iresult)
                        (setf iresult (strcat "0" iresult))
                )
        ) ; END let
)





(defun vec-gmt-hhmmss (gmt)
        "----------------------------------------------------------------
        vec-gmt-hhmmss (gmt) given gmt in seconds convert to hhmmss string
        -----------------------------------------------------------------"
        ( if (compound-data-p gmt)



                      January 15, 1992





                           - 7 -


                ( map-elements #'vec-gmt-hhmmss gmt)
                (gmt-hhmmss gmt)
        )
)
(defun strlen (s)
        "----------------------------------------------------------------
        strlen (s) used in gmt-hhmmss
        ----------------------------------------------------------------"
        (length s)
)
(defun vec-const (x n)
        "----------------------------------------------------------------
        vec-const (x n) return a list of length n, each list element
        is equal to x
        -----------------------------------------------------------------"
        (let ((out-list 0))
                (dotimes (i n out-list)
                        (if (= i 0)
                                (setf out-list (list x))
                                (setf out-list (combine out-list x))
                        )
                )
        ) ; END let
)
(defun chinorm (s df)
        "-------------------------------------------------------------
        chinorm (s df) returns transformation of chi-square
        s with df degrees of freedom to approximate N(0,1) deviate
        -------------------------------------------------------------"
        (/ (- s (float df)) (sqrt (* 2 df)))
)
(defun trim-mean (x &key (high .95) (low .05))
        "---------------------------------------------------------------
        trim-mean (x &key (high .95) (low .05)) return trimmed mean of x
        high and low specify the quantiles to be trimmed from x
        ----------------------------------------------------------------"
        (let ((high-q HUGE) (low-q MINUS-HUGE) (new-x 0) (t-mean 0))
                (if (< high 1)
                        (def high-q (quantile x high))
                )
                (if (> low 0)
                        (def low-q (quantile x low))
                )
                (setf new-x (remove-if #'(lambda (c) (< high-q c)) x))
                (setf new-x (remove-if #'(lambda (c) (> low-q c)) new-x))
                ;(prin1 "new-x ")





                ;(prin1 new-x)
                ;(prin1 "\n")
                (setf t-mean (/ (sum new-x) (length new-x)))



                      January 15, 1992





                           - 8 -


        ) ; END let
)























































                      January 15, 1992





                           - 9 -


;               s.lsp
;
;       xlispstat functions used in the analysis of UdFilter program
;       outputs.  These functions assume that the current directory
;       contains the UdFilter output files stateplt.dat, statesig.dat
;       and the individual channel residual files.
;
;       W. Hatch Sun Jul  7 07:55:18 EDT 1991
;       Coleman Research
;       Project Jasper Pink
;
(def wyse "wyse") ;
(def tek  "tek")  ;
(def pc   "pc")   ;
;(def term wyse)   ;
(def term "pc")
(def huge 1.e36)
(def minus-huge (- huge))
(def EPSILON 1.e-15)
(defun safediv (num denom) ;
        "----------------------------------------------------------------
         safediv (num denom) returns scalar division result
         ----------------------------------------------------------------"
        ( cond
                ((/= denom 0.0)
                        (/ num denom)
                )
                (t 1.e-14)
        )

)
(defun delta (x) ;
        "----------------------------------------------------------------
         delta (x) returns scalar forward first difference, zero at end of list
         ----------------------------------------------------------------"
        ( cond
                ((not (endp (cddr x)))
                        (- (second x) (first x)))
                (t 0.0 )
        )
)
(defun dydx (x y) ;
        "----------------------------------------------------------------
         dydx (x y) returns scalar numerical first derivative
         ----------------------------------------------------------------"
        (safediv (delta y) (delta x))
)
(defun vec-dydx (x y) ;
        "----------------------------------------------------------------
         vec-dydx (x y) return list of dydx, chop off last 2 list elements
         ----------------------------------------------------------------"
        (chop-last (chop-last (maplist #'dydx  x  (smooth-kernel x y))))
)




                      January 15, 1992





                           - 10 -


(defun load-seq (file) ;
        "----------------------------------------------------------------
         load-seq (file) load col of data to y, make x real sequence (0,1)
         ----------------------------------------------------------------"
        (def data (read-data-columns file))
        (def y (select data 0))
        (def x (rseq 0.0 1.0 (length y)))
)
(defun smooth-lowess (x y) ;
        "----------------------------------------------------------------
         smooth-lowess (x y) return smoothed y sequence at given x values
         ----------------------------------------------------------------"
        (second (lowess x y))
)
(defun smooth-spline (x y) ;
        "----------------------------------------------------------------
         smooth-spline (x y) return smoothed y sequence at given x values
         ----------------------------------------------------------------"
        (second (spline x y :xvals x))
)
(defun smooth-kernel (x y) ;
        "----------------------------------------------------------------
         smooth-kernel (x y) return smoothed y sequence at given x values
         ----------------------------------------------------------------"
        (second (kernel-smooth x y :xvals x))
)
(defun plot-dydx (x y &key (min-x minus-huge) (max-x huge))
        "----------------------------------------------------------------
        plot-dydx (x y &key (min-x minus-huge) (max-x huge))
        plot dy/dx chopping off last 2 end points in vec-dydx
         ----------------------------------------------------------------"
        (tekpoints (chop-last (chop-last x)) (vec-dydx x y)
                :min-x min-x :max-x max-x)
)
(defun print-list (file x &rest args ) ;
        "----------------------------------------------------------------
         print-list (file x &rest args ) print multiple lists in parallel
         column format assumes lists are of equal length; NIL printed for
         some entries if this is not true
         ----------------------------------------------------------------"
        ;------------------------------------------------------------
        ; open file and define local loop index variables
        ;------------------------------------------------------------
        (setf pf (open file :direction :output))
        (let  ((i 0) (j 0))
        ;------------------------------------------------------------
        ; loop over element count of first list
        ;------------------------------------------------------------
        (loop








                      January 15, 1992





                           - 11 -


                (if (not (nth i x)) (close pf) )
                (if (not (nth i x)) (return t) )
                ; ----------------------------------------------------
                ; print element from first list
                ; ----------------------------------------------------
                (princ (nth i x) pf)
                (format pf " ")
                (def yargs  args)
                ; ----------------------------------------------------
                ; print remainder of list elements
                ; ----------------------------------------------------
                (dotimes (j (length args)  )
                        (def ycar (car yargs))
                        (def yargs (cdr yargs))
                        (princ (nth i ycar) pf)
                        (format pf " ")
                )
                ; ----------------------------------------------------
                ; newline and increment list element count
                ; ----------------------------------------------------
                (terpri pf)
                (setf i (+ i 1))
        ))
        (close pf)
)
(defun vec+ (x y) ;
        "-------------------------------------------------------------
         vec+ (x y) addition of simple or compound objects,
         Tierney page 98,99
         -------------------------------------------------------------"
        ( if (or (compound-data-p x) (compound-data-p y))
                ( map-elements #'vec+ x y)
                ( + x y))
)
(defun vec- (x y) ;
        "-------------------------------------------------------------
         vec- (x y) subtraction of simple or compound objects,
         Tierney page 98,99
         -------------------------------------------------------------"
        ( if (or (compound-data-p x) (compound-data-p y))
                ( map-elements #'vec- x y)
                ( - x y))
)
(defun vec* (x y) ;
        "-------------------------------------------------------------
         vec* (x y) multiplication of simple or compound objects,
         Tierney page 98,99
         -------------------------------------------------------------"
        ( if (or (compound-data-p x) (compound-data-p y))
                ( map-elements #'vec* x y)
                ( * x y))
)
(defun vec/ (x y) ;
        "-------------------------------------------------------------



                      January 15, 1992





                           - 12 -


         vec/ (x y)  division of simple or compound objects, Tierney page 98,99
        -------------------------------------------------------------"
        ( if (or (compound-data-p x) (compound-data-p y))
                ( map-elements #'vec/ x y)
                ( / x y))
)
(defun rms3 (x y z) ;
        "-------------------------------------------------------------
         rms3 (x y z) returns list of rms of given 3 lists elements
         -------------------------------------------------------------"
        (sqrt (vec+ (vec* x x) (vec+ (vec* y y) (vec* z z))))
)
(defun tekmode() ;
        "-------------------------------------------------------------
         tekmode () if Wyse terminal, switch to tek graphics mode
                otherwise do nothing
         -------------------------------------------------------------"
        (if (string= term wyse) (system "tekmode")
        )
)
(defun ansimode() ;
        "-------------------------------------------------------------
         ansimode () if Wyse terminal switch to ansi character mode
                otherwise do nothing
         -------------------------------------------------------------"
        (if (string= term wyse) (system "ansimode")
        )
)
(defun plot-density(x) ;
        "-------------------------------------------------------------
         plot-density (x) plot probability density function, then plot
                normal sample density for same number of points
         -------------------------------------------------------------"
        (tekmode)
        (plot-points(kernel-dens x))
        (read-line)
        (read-line)
        (plot-lines (kernel-dens (normal-rand (length x) ) :type "g"))
        (read-line)
        (ansimode)
)
(defun tekpoints(x y &key (min-x minus-huge) (max-x  huge))
        "-------------------------------------------------------------
         tekpoints(x y &key (min-x minus-huge) (max-x  huge))
         select range for x and plot-points
         -------------------------------------------------------------"
        (let
                (
                        (data 0)
                        (plotx 0)
                        (ploty 0)






                      January 15, 1992





                           - 13 -


                )
                (tekmode)
                (setf data (list x y))
                (if (> min-x (- huge))
                        (setf data (gt-select data min-x))
                )
                (if (< max-x huge)
                        (setf data (lt-select data max-x))
                )
                (setf plotx (select data 0))
                (setf ploty (select data 1))
                (plot-points plotx ploty)
                (read-line)
                (ansimode)
        ) ; END let
)

(defun norm-plot (x) ;
        "-------------------------------------------------------------
         norm-plot (x) normal probability plot of given list of values
         -------------------------------------------------------------"
        (def __y (sort-data x ))
        (def __a (/ 1 (* 2 (length x))))
        (def __b (- 1 __a))
        (def __p (rseq __a __b (length x)))
        (tekpoints (normal-quant __p) __y)
        (undef (list '__y '__a '__b '__p))
)
(defun ksh () ;
        "-------------------------------------------------------------
         ksh () escape to korn shell
         -------------------------------------------------------------"
        (system "ksh")
)
(defun raw-psd ( x )
        "-------------------------------------------------------------
         raw-psd(x) returns squared magnitude of fft(x)
         raw psd is scaled such that sum of components is unity
        --------------------------------------------------------------"
        (let ((stdx 0) (abs-fftx 0) (power 0))
                (setf stdx (center-and-scale x))
                (setf abs-fftx (abs (/ (fft stdx) (length stdx))))
                (half-list (* 2 (* abs-fftx abs-fftx)))
        )
)
(defun plot-raw-psd (x)
        "-------------------------------------------------------------
         plot-raw-psd(x) plots squared magnitude of fft(x)
         vs normalized frequencies 0 to .5
        --------------------------------------------------------------"
        (let ((power 0) (stdx 0) (freq 0))
                (setf power (raw-psd x))
                (setf freq (rseq 0 .5 (length power)))
                (tekpoints freq power)



                      January 15, 1992





                           - 14 -


        )
)


(defun plot-smooth-psd (x)
        "--------------------------------------------------------------
         plot-smooth-psd (x)  plots the smooth-psd of x at normalized
         frequencies 0 to .5
        ---------------------------------------------------------------"
        (let ((power 0) (stdx 0) (freq 0))
                (setf power (smooth-psd x))
                (setf freq (rseq 0 .5 (length power)))
                (tekpoints freq power)
        )
)
(defun smooth-psd (x)
        "--------------------------------------------------------------
         smooth-psd (x) returns kernel-smooth of raw psd
        ---------------------------------------------------------------"
        (let ((freq 0) (power 0))
                (setf power (raw-psd x))
                (setf freq (rseq 0 .5 (length power)))
                (second (kernel-smooth freq power :width .1 :xvals freq))
        )
)
(defun half-list (x)
        "-------------------------------------------------------------
         half-list(x) returns list containing first half of the elements
                in x
        --------------------------------------------------------------"
        (let ((j 0) (len 0))
                (def len (/ (length x) 2))
                (loop
                        (def x (chop-last x))
                        (def j (+ j 1))
                        (if (or (eql j len) (zerop len))
                                (return x)
                        )
                )
        )
)
(defun center-and-scale (x)
        "-------------------------------------------------------------
        center-and-scale (x) return x with mean subtracted and divided
                by standard deviation
        --------------------------------------------------------------"
        (let ((xbar 0) (xsig 0))
                (setf xbar (mean x))
                (setf xsig (standard-deviation x))
                (vec/ (- x xbar) xsig)
        )
)





                      January 15, 1992





                           - 15 -


(defun read-xyz (file)
        "-------------------------------------------------------------
        read-xyz (file)  def x y, and z as first 3 data column read from file
        --------------------------------------------------------------"
        (let ((col 0))
                (setf col (read-data-columns file))
                (def x (select col 0))
                (if (>= (length col) 2)
                        (def y (select col 1))
                )
                (if (>= (length col) 3)
                        (def z (select col 2))
                )
        )
)
(defun greater-than (x y)
        "-------------------------------------------------------------
        greater-than (x y) returns true if x greater than y, else nil
        --------------------------------------------------------------"
        (plusp (- x y))
)
(defun less-than (x y)
        "-------------------------------------------------------------
        less-than (x y) returns true if x is less than y, else nil
        --------------------------------------------------------------"
        (minusp (- x y))
)
(defun equal-to (x y)
        "-------------------------------------------------------------
        equal-to (x y) returns true if x is equal to y, else nil
        --------------------------------------------------------------"
        (equalp x y)
)
(defun log10 (x)
        "-------------------------------------------------------------
        log10 (x) returns log to the base 10 of x, vectorized
        --------------------------------------------------------------"
        (/ (log x) (log 10.))
)
(defun pow (x y)
        "-------------------------------------------------------------
        pow (x y)  returns x raised to the yth power
        --------------------------------------------------------------"
        (exp (* (log x) y))
)
(defun limit (x &key (lower .05) (upper .95))
        "-------------------------------------------------------------





        limit (x &key (lower .05) (upper .95)) evaluates the upper and
        lower quantiles of x and returns x with values above the upper



                      January 15, 1992





                           - 16 -


        quantile set to the upper quantile and values less than the lower
        quantile set to the lower quantile.
        --------------------------------------------------------------"
        (let ((idx 0) (x-up 0) (x-low 0) (x-value 0) (x-yield 0))
                (setf x-up (quantile x upper))
                (setf x-low (quantile x lower))
                (dotimes (i (length x) x-yield)
                        (setf idx i)
                        (setf x-value (nth idx x))
                        (if (> x-value x-up)
                                (setf x-value x-up)
                        )
                        (if (< x-value x-low)
                                (setf x-value x-low)
                        )
                        (if (= i 0)
                                ; i = 0
                                (setf x-yield (list x-value))
                                ; i /= 0
                                (setf x-yield (combine x-yield x-value))
                        )
                ) ; END dotimes
        ) ; END let
)
(defun atan (y)
        "---------------------------------------------------------------
        atan (y)  returns the arc tangent of y in radians
        ---------------------------------------------------------------"
        (let ((fx 0) (x0 0) (x1 0) (endc 0) (ya 0) (yb 0) (signy 0)
                (cx 0) (dx 0)
             )
        (block at
                (setf endc (* 1.e4 EPSILON))
                ;-----------------------------------------------------------
                ; reductions to work with principal angle between 0 and pi/4
                ;-----------------------------------------------------------
                (if (< 0 y)
                        (setf signy 1)
                        (setf signy (- 1))
                )
                (if (= 0. y)
                        (setf signy 0.)
                )
                (setf ya (abs y))
                ;-----------------------------------------------------------
                ; if angle is greater than pi/4 then work with its complement
                ;-----------------------------------------------------------
                (if (> ya 1)
                        (setf yb (/ 1 ya))
                        (setf yb ya)
                )
                (setf x1 yb)
                ;-----------------------------------------------------------
                ; Newton-Rapson iterations



                      January 15, 1992





                           - 17 -


                ;-----------------------------------------------------------
                (loop
                        (if (< (abs (- x0 x1)) endc)
                                (return-from at)
                        )
                        (setf x0 x1)
                        (setf fx (- yb (tan x0)))





                        (setf cx (cos x0))
                        (setf dx (* fx cx cx))
                        (setf x1 (+ x0 dx))
                        ;(print-object "x1 : " x1)
                ) ; END loop
        ) ; END block at
        ;------------------------------------------------------------------
        ; take complement if initial principal angle > pi/4
        ;------------------------------------------------------------------
        ;(print-object "ya : " ya)
        (if (> ya 1)
                (setf x1 (- (/ pi 2) x1))
        )
        ;------------------------------------------------------------------
        ; put returned angle in 2d quadrant if given argument was negative
        ;------------------------------------------------------------------
        ;(print-object "signy : " signy)
        ;(print-object "x1 : " x1)
        (if (> 0 signy)
                (setf x1 (- x1))
        )
        ;(print-object "x1 : " x1)
        (setf xb x1)
        ) ; END let
)




















                      January 15, 1992





                           - 18 -


;               t.lsp - xlispstat time series analysis functions
;
;               requires functions defined in s.lsp
;
;               by W. Hatch
;                  Coleman Research
;                  14502 Greenview Drive Suite 206
;                  Laurel, MD 20708
;
(defun get-filter (n cutoff rolloff &key (nyquest .5) ( units 10)
        ( type "lowpass") )
        "-------------------------------------------------------------
        get-filter (n cutoff rolloff &key (nyquest .5) (units 10)
                (type lowpass))
        returns list of n real, frequency domain filter coefficients
        for given cutoff and rolloff. If units = 10, the rolloff is in
        dB per decade, if units = 2, the rolloff is in db per octave.
        The cutoff is the half power frequency in Hz. The type is
        lowpass or highpass.  The fft of the time series to be
        filtered will be  multiplied by the real filter coeffients term by
        term.
        --------------------------------------------------------------"
        (let (
                        (half-power (sqrt 0.5) )
                        (gain 0)
                        (sign (- 1))
                        (freq-interval 0.)
                        (active-freq 0.)
                        (octaves 0.)
                        (filter-factor 1.)
                        (exp-var 0.)
                        (iplus 0)
                        (filter 0)
                        (rev-filter 0)
                        (small-gain .00001)
                        (m 0)
                        (oddn nil)
                        (mless 0)
                        (gain0 0.)
                )
                ;------------------------------------------------------
                ; set up for odd or even number of coefficients
                ;------------------------------------------------------
                (when (evenp n)
                        (setf m (/ n 2))
                        (setf oddn nil)
                )
                (when (oddp n)
                        (setf m (/ (- n 1) 2))
                        (setf oddn t)
                )
                ;------------------------------------------------------
                ; set up for lowpass or highpass
                ;------------------------------------------------------



                      January 15, 1992





                           - 19 -


                (when (equal type "lowpass")
                        (setf gain0  1.)
                        (setf sign (- 1.))
                        (print "get-filter lowpass")
                )
                (when (equal type "highpass")
                        (setf gain0 0.)
                        (setf sign 1)
                        (print "get-filter highpass")





                )
                ;------------------------------------------------------
                ; set filter constants
                ;------------------------------------------------------
                (setf filter-factor (log10 units))
                (setf num-filter-coef m)
                (setf freq-interval (/ nyquest m))
                ;------------------------------------------------------
                ; compute first half of filter coefficients
                ;------------------------------------------------------
                (block end-of   ; label block to allow return-from
                (dotimes  (i m)
                        ;---------------------------------------------------
                        ; compute filter gain coeffivient
                        ;---------------------------------------------------
                        (setf iplus (+ i 1))
                        (setf active-freq (* freq-interval iplus))
                        (setf octaves
                           (safediv (log10
                                (safediv active-freq cutoff)) filter-factor))
                        (setf exp-var (safediv (* rolloff octaves sign) 20.0))
                        (setf exp-var (pow 10. exp-var))
                        (setf gain (* exp-var half-power))
                        ;---------------------------------------------------
                        ; constrain gain to be <= 1.0
                        ;---------------------------------------------------
                        (if (> gain 1)
                                (setf gain 1)
                        )
                        ;---------------------------------------------------
                        ; append gain to list of filter coefficients
                        ;---------------------------------------------------
                        (if (eq i 0)
                                (setf filter (list gain))
                                (setf filter (combine filter gain))
                        )
                        ;---------------------------------------------------
                        ; check if remainder of gains are constant
                        ;---------------------------------------------------
                        (if (equal type "lowpass")



                      January 15, 1992





                           - 20 -


                                ;--------------------------------------------
                                ; lowpass - set remainder of gains to 0.
                                ;--------------------------------------------
                                (when (<= gain small-gain)
                                        (setf mless (- (- m i) 1))
                                        (dotimes (j mless)
                                            (setf filter (combine filter 0.))
                                        ) ;                     ---------------
                                    (return-from end-of ) ;jump out of block
                                ) ;                             ---------------
                                ;--------------------------------------------
                                ; highpass - set remainder of gains to 1.0
                                ;--------------------------------------------
                                (when (>= gain 1.0)
                                        (setf mless (- (- m i) 1))
                                           (dotimes (j mless)
                                             (setf filter (combine filter 1.0))
                                           );                  ----------------
                                        (return-from end-of) ;jump out of block
                                ) ;                            ----------------

                        ) ; ENDIF
                )  ; END dotimes
                )  ; END block end-of
                ;------------------------------------------------------
                ; append mirror image of filter to filter, if odd number





                ; of terms then delete the extra term
                ;------------------------------------------------------
                (setf rev-filter (reverse filter))
                (if (not oddn)
                        (setf filter (chop-last filter))
                )
                (setf filter (combine filter rev-filter))
                (setf filter (combine gain0 filter))
                ;------------------------------------------------------
                ; return the list of filter coefficients
                ;------------------------------------------------------
                ;(first (list filter))
        ) ; END let
)
(defun real-filter (x cutoff rolloff &key (type "lowpass") (nyquest .5))
        "-------------------------------------------------------------
        real-filter (x cutoff rolloff &key (type lowpass) (nyquest .5))
        returns real x lowpass or highpass filtered
        --------------------------------------------------------------"
        (let    (
                        (forward-transform 0)
                        (inverse-transform 0)
                        (filter-coefficients 0)



                      January 15, 1992





                           - 21 -


                        (imag-forward-transform 0)
                        (real-forward-transform 0)
                        (n 0)
                ) ; END local declarations
                (setf n (length x))
                (setf forward-transform (fft x))
                (setf filter-coefficients
                        (if (equal type "lowpass")
                                (get-filter n cutoff rolloff
                                        :type "lowpass" :nyquest nyquest)
                                (get-filter n cutoff rolloff
                                        :type "highpass" :nyquest nyquest)
                        )
                )
                ;(print "filter-coefficients")
                ;(print filter-coefficients)
                ;(print "given forward-transform")
                ;(print forward-transform)
                (setf real-forward-transform
                        (* filter-coefficients (realpart forward-transform)))
                (setf imag-forward-transform
                        (* filter-coefficients (imagpart forward-transform)))
                (setf forward-transform
                        (complex real-forward-transform
                                imag-forward-transform))
                ;(print "filtered forward-transform")
                ;(print forward-transform)
                (setf forward-transform (/ forward-transform n))
                (setf inverse-transform (fft forward-transform t))
                (realpart inverse-transform)
        ) ; END let
)
(defun real-band-filter (x low-freq high-freq rolloff &key (nyquest .5)
        (type "bandpass"))
        "-------------------------------------------------------------
        real-band-filter (x low-freq high-freq rolloff &key (nyquest .5)
                (type bandpass))





        returns real x after bandpass or bandstop filtering
        --------------------------------------------------------------"
        (let ( (xlow 0))
                (if (equal type "bandpass")
                        (setf xlow
                                (complex-filter (complex-filter x high-freq
                                        rolloff :type "lowpass") low-freq
                                        rolloff :type "highpass")
                        )
                        (setf xlow
                                (+ (complex-filter x low-freq
                                        rolloff :type "lowpass")



                      January 15, 1992





                           - 22 -


                                        (complex-filter x high-freq
                                        rolloff :type "highpass")
                                )
                        )
                ) ; END if
                ;(print "yielded complex time series")
                ;(print xlow)
                (realpart xlow)
        ) ; END let
)
(defun complex-filter (x cutoff rolloff &key (type "lowpass") (nyquest .5))
        "-------------------------------------------------------------
        complex-filter (x cutoff rolloff &key (type lowpass) (nyquest .5))
        returns complex lowpass or highpass filtered sequence
        --------------------------------------------------------------"
        (let    (
                        (forward-transform 0)
                        (inverse-transform 0)
                        (filter-coefficients 0)
                        (imag-forward-transform 0)
                        (real-forward-transform 0)
                        (n 0)
                        (n 0)
                ) ; END local declarations
                (setf n (length x))
                (setf forward-transform (fft x))
                (setf filter-coefficients
                        (if (equal type "lowpass")
                                (get-filter n cutoff rolloff
                                        :type "lowpass" :nyquest nyquest)
                                (get-filter n cutoff rolloff
                                        :type "highpass" :nyquest nyquest)
                        )
                )
                (setf real-forward-transform
                        (* filter-coefficients (realpart forward-transform)))
                (setf imag-forward-transform
                        (* filter-coefficients (imagpart forward-transform)))
                (setf forward-transform
                        (complex real-forward-transform
                                imag-forward-transform))
                (setf forward-transform (/ forward-transform n))
                (setf inverse-transform (fft forward-transform t))
        ) ; END let
)
(defun complex-demodulate (x mod-freq &key (cutoff .1) (rolloff 200))
        "-------------------------------------------------------------
        complex-demodulate (x mod-freq &key (cutoff .1) (rolloff 200)





        returns series x demodulated by mod-freq and low pass filtered



                      January 15, 1992





                           - 23 -


        mod-freq must be between 0. and .5 (normalized frequency)
        -------------------------------------------------------------"
        (let    (       (n 0)
                        (alpha 0)
                        (real-alpha 0)
                        (imag-alpha 0)
                        (modx 0)
                        (outx 0)
                )
                (setf mod-freq (- 0 mod-freq))
                (setf n (length x))
                (dotimes (i n)
                        (setf real-alpha (cos (* 2 pi i mod-freq)))
                        (setf imag-alpha (sin (* 2 pi i mod-freq)))
                        (if (eq i 0)
                                (setf modx (complex real-alpha imag-alpha))
                                (setf modx (combine
                                        modx (complex real-alpha imag-alpha)))
                        )
                )
                (setf outx (complex-filter modx cutoff rolloff))
                ;(real-part outx)
        ) ; END let
)
(defun gen-data (n amp freq )
        "-------------------------------------------------------------
        gen-data (n amp freq )
        returns n data points, (+ normal-rand (* amp (sin (* 2 PI i freq)))
        -------------------------------------------------------------"
        (let    (       (data 0)
                )

                (dotimes (i n)
                        (if (eq i 0)
                                (setf data (* amp (sin (* 2 pi i freq))))
                                (setf data (combine data
                                        (* amp (sin (* 2 pi i freq)))))
                        ) ; END if
                ) ; END dotimes
                (+ data (normal-rand n))
        ) ; END let
)
(defun decimate ( x &optional (n 5))
        "--------------------------------------------------------------
        decimate ( x &optional (n 5))  returns list containing
        every nth element of the given list x, n defaults to 5
        --------------------------------------------------------------"
        (let ((new-x nil) (test 0) (i1 0))
                (dotimes (i (length x) new-x)
                        (setf i1 (+ i 1))
                        (setf test (truncate (/ (float i1) (float n))))
                        (if (= 0 (- i1 (* n test)))
                                (if (= i1 n)
                                        (setf new-x (list (nth i x)))



                      January 15, 1992





                           - 24 -


                                        (setf new-x (combine new-x (nth i x)))
                                )

                        )
                )





        ) ; END let
)













































                      January 15, 1992





                           - 25 -


;       W. Hatch  uunet!bts!bill
;       Sun Nov  3 16:17:09 EST 1991
;
;       infinite impulse response (iir) digital filter design
;       and filtering of timeseries data
;-----------------------------------------------------------------------
(defun low-pass-iir (x fp gp fs gs)
        "---------------------------------------------------------------
        low-pass-iir (x fp gp fs gs) given pass freq fp, and gain  gp,
        stop frequency fs and gain gs; design iir low pass filter and
        filter the time series x.  returns the filtered time series.
        SEE iir-filter, low-pass-design
        ---------------------------------------------------------------"
        (block lpiir
        (let ((y 0) (coef 0))
                (setf coef (low-pass-design fp gp fs gs))
                (return-from lpiir (iir-filter x coef))
        ) ; END let
        ) ; END block lpiir
)
(defun high-pass-iir (x fs gs fp gp)
        "---------------------------------------------------------------
        high-pass-iir (x fs gs fp gp) given stop frequency fs and gain gs;
        pass freq fp, and gain  gp, design iir high pass filter and
        filter the time series x.  returns the filtered time series.
        SEE iir-filter, high-pass-design
        ---------------------------------------------------------------"
        (block hpiir
        (let ((y 0) (coef 0))
                (setf coef (high-pass-design fs gs fp gp))
                (return-from hpiir (iir-filter x coef))
        ) ; END let
        ) ; END block hpiir
)
(defun band-pass-iir (x fs1 gs1 fp1 gp1 fp2 gp2 fs2 gs2)
        "---------------------------------------------------------------
        band-pass-iir (x fs1 gs1 fp1 gp1 fp2 gp2 fs2 gs2)
        given stop frequency fs1 and gain gs1 pass frequency fp1 and
        gain  gp1, pass frequency fp2 and gain fp2, stop frequency fs2
        and gain gs2; design iir band pass filter and
        filter the time series x.  returns the filtered time series.
        SEE iir-filter, band-pass-design
        ---------------------------------------------------------------"
        (block bpiir
        (let ((y 0) (coef 0))
                (setf coef (band-pass-design fs1 gs1 fp1 gp1 fp2 gp2 fs2 gs2))
                ;(print-object "bp coef: " coef)
                (return-from bpiir (iir-filter x coef))
        ) ; END let
        ) ; END block bpiir
)
(defun band-stop-iir (x fp1 gp1 fs1 gs1 fs2 gs2 fp2 gp2)
        "---------------------------------------------------------------
        band-stop-iir (x fp1 gp1 fs1 gs1 fs2 gs2 fp2 gp2)



                      January 15, 1992





                           - 26 -


        given pass frequency fp1 and gain gp1, stop frequency fs1 and
        gain  gs1, stop frequency fs2 and gain fs2, pass frequency fp2
        and gain gp2; design iir band stop filter and
        filter the time series x.  returns the filtered time series.
        SEE iir-filter, band-stop-design
        ---------------------------------------------------------------"
        (block bsiir
        (let ((y 0) (coef 0))
                (setf coef (band-stop-design fp1 gp1 fs1 gs1 fs2 gs2 fp2 gp2))
                ;(print-object "bs coef: " coef)
                ;(setf y (digital-transfer coef))
                ;(message "transfer magnitude of band stop")
                ;(tekpoints (rseq 0 .5 (length y)) y)
                (return-from bsiir (iir-filter x coef))
        ) ; END let
        ) ; END block bsiir
)
(defun print-object (msg obj)
        "--------------------------------------------------------------
        print-object (msg obj)  display message, print object followed
        by newline
        --------------------------------------------------------------"
        (princ msg)
        (princ " ")
        (princ obj)
        (princ "\n")
)
(defun message (msg)
        "--------------------------------------------------------------
        message (msg)  print message followed by newline
        --------------------------------------------------------------"
        (princ msg)
        (princ "\n")
)
(defun iir-error (pass-gain pass-freq stop-gain stop-freq)
        (princ "pass-gain: ")
        (princ pass-gain)
        (princ " db  pass-freq: ")
        (princ pass-freq)
        (princ " Hz\n")
        (princ "stop-gain: ")
        (princ stop-gain)
        (princ " db stop-freq: ")
        (princ stop-freq)
        (princ " Hz\n")

)
(defun iir-filter (x coef)
        "----------------------------------------------------------------
        iir-filter (x coef) infinite impulse response (iir) filter
        x is the input time series and coef
        is either 1.) a single 2d or 4th order section or 2.) a list
        of 2d and/or 4th order serial sections. Each 2d order filter
        section is a list containing the coefficients (Kd a0 a1 b0 b1)



                      January 15, 1992





                           - 27 -


        for a digital filter section of the form

                            z**2 + a1 * z + a0
                H(z) = Kd * -------------------
                            z**2 + b1 * z + b0

        The corresponding difference equation is

            y(i) = Kd * {x(i) + a1*x(i-1) + a0*x(i-2) - b1*y(i-1) + b0*y(i-2)}

        Each 4th order section contains (Kd a0 a1 a2 a3 b0 b1 b2 b3) for
        a 4th order form of the above.

        The time series x is filtered forward and backward to cancal out
        any phase shift or delays.
        ----------------------------------------------------------------"
        (block biir
        (let ((nsect 0) (y 0))
                ;--------------------------------------------------------
                ; coef is either the coefficients for a single section or
                ; a list of sections
                ;--------------------------------------------------------
                (if (listp (nth 0 coef))
                        (setf nsect (length coef))
                        (setf nsect 1)
                )
                ;--------------------------------------------------------
                ; forward pass
                ;--------------------------------------------------------
                (setf y x)
                (if (listp (nth 0 coef))
                        ;-----------------------------------------------
                        ; multiple sections
                        ;-----------------------------------------------
                        (dotimes (k nsect)
                                (setf y (iir-section y (nth k coef)))
                        )
                        ;-----------------------------------------------
                        ; single section
                        ;-----------------------------------------------
                        (setf y (iir-section y coef))
                )
                ;--------------------------------------------------------
                ; reverse pass
                ;--------------------------------------------------------
                ;(print-object "reverse y : " y)
                (setf y (reverse y))
                ;(print-object "reverse y : " y)
                (if (listp (nth 0 coef))
                        ;-----------------------------------------------
                        ; multiple sections
                        ;-----------------------------------------------
                        (dotimes (k nsect)
                                (setf y (iir-section y (nth k coef)))



                      January 15, 1992





                           - 28 -


                        )
                        ;-----------------------------------------------
                        ; single section
                        ;-----------------------------------------------
                        (setf y (iir-section y coef))
                )
                (setf y (reverse y))
        ) ; END let
        ) ; END block biir
)





(defun iir-section (x coef)
        "----------------------------------------------------------------
        iir-section (x coef)  2d or 4th order iir section
        returns filtered time series. x is time series to be filtered,
        For a 2d order section coef contains Kd, a0, a1, b0, b1 for the
        digital transfer function

                            z**2 + a1 * z + a0
                H(z) = Kd * -------------------
                            z**2 + b1 * z + b0

        the corresponding difference equation is

            y(i) = Kd * {x(i) + a1*x(i-1) + a0*x(i-2) - b1*y(i-1) + b0*y(i-2)}

        For a 4th order section coef contains (Kd a0 a1 a2 a3 b0 b1 b2 b3)
        for the 4th order version of the above.
        ----------------------------------------------------------------"
        ;(print-object "iir-section given coef : " coef)
        ;(print-object "iir-section given x : " x)
        (let ((n 0) (y 0) (ynow 0) (gain 0) (a0 0) (a1 0) (b0 0) (b1 0)
                (newx 0))
        (block iir
                (if (> (length coef) 5)
                        (return-from iir (iir4-section x coef))
                )
                (setf y (combine 0 0 ))
                (setf newx (combine  0 0 x))
                (setf n (length newx))
                (setf gain (nth 0 coef))
                (setf a0 (nth 1 coef))
                (setf a1 (nth 2 coef))
                (setf b0 (nth 3 coef))
                (setf b1 (nth 4 coef))
                (dotimes (i n)
                        (when (> i 1)
                                (setf ynow (+  (nth i newx)
                                                (* a1 (nth (- i 1) newx))
                                                (* a0 (nth (- i 2) newx))



                      January 15, 1992





                           - 29 -


                                           )
                                )
                                (setf ynow (* ynow gain))
                                (setf ynow (- ynow (* b1 (nth (- i 1)  y) )))
                                (setf ynow (- ynow (* b0 (nth  (- i 2) y) )))
                                (setf y (combine y  ynow))
                        ) ; END when
                ) ; END dotimes
                (setf y (chop-first y 2))
                (return-from iir  y)
        ) ; END iir
        ) ; END let
)
(defun iir4-section (x coef)
        "----------------------------------------------------------------
        iir4-section (x coef)  4th order iir section
        returns filtered time series. x is time series to be filtered,
        SEE iir-section
        ----------------------------------------------------------------"
        ;(print-object "iir4-section given coef : " coef)
        ;(print-object "iir4-section given x : " x)
        (let ((n 0) (y 0) (ynow 0) (Kd 0) (a0 0) (a1 0) (a2 0) (a3 0)
                (b0 0) (b1 0) (b2 0) (b3 0)





                (newx 0))
        (block iir4
                (setf y (combine 0 0 0 0))
                (setf newx (combine  0 0 0 0 x))
                (setf n (length newx))
                (setf Kd (nth 0 coef))
                (setf a0 (nth 1 coef))
                (setf a1 (nth 2 coef))
                (setf a2 (nth 3 coef))
                (setf a3 (nth 4 coef))
                (setf b0 (nth 5 coef))
                (setf b1 (nth 6 coef))
                (setf b2 (nth 7 coef))
                (setf b3 (nth 8 coef))
                (dotimes (i n)
                        (when (> i 3)
                                (setf ynow (+  (nth i newx)
                                                (* a3 (nth (- i 1) newx))
                                                (* a2 (nth (- i 2) newx))
                                                (* a1 (nth (- i 3) newx))
                                                (* a0 (nth (- i 4) newx))
                                           )
                                )
                                (setf ynow (* Kd ynow))
                                (setf ynow (- ynow
                                                (* b3 (nth (- i 1) y))



                      January 15, 1992





                           - 30 -


                                                (* b2 (nth (- i 2) y))
                                                (* b1 (nth (- i 3) y))
                                                (* b0 (nth (- i 4) y))
                                        )
                                )
                                (setf y (combine y  ynow))
                        ) ; END when
                ) ; END dotimes
                (setf y (chop-first y 4))
                (return-from iir4  y)
        ) ; END iir4
        ) ; END let
)
(defun butterworth-size (fp gp fs gs &key (base 1))
        "---------------------------------------------------------------
        butterworth-size (fp gp fs gs &key (base 1)) given fp passband
        frequency, gp the gain in db at frequency fp, fs stopband frequency, and
        gs the gain in db at frequency fs, returns list (n fc) where
        n is the order and fc is the cutoff frequency.   n is a multiple
        of base.  if n is to be even, base is 2; if n is to be a multiple
        of 4, then base is 4.

        note that gp = 20 log10 (gain at fp),  gs = 20 log10 (gain at fs) with
        both gp and gs assumed to be negative with gp > gs (low pass filter)
        the frequencies fp < fs
        are assumed to be normalized such that 0 < fp  and 0 < fp

        reference: Digital Filters, R. W. Hamming, Prentice-Hall,1977,
        pages 189-195
        ---------------------------------------------------------------"
        (let ((a 0) (e 0) (n 0) (fc 0))
        (block bs
                ;------------------------------------------------------
                ; assure that frequencies are between 0 and .5
                ;------------------------------------------------------
                (when (> 0 fs)
                        (princ "illegal negative frequency, fs:  ") (princ fs)





                        (princ "\n")
                        (return-from bs nil)
                )
                (when (> 0 fp)
                        (princ "illegal negative frequency, fp:  ") (princ fp)
                        (princ "\n")
                        (return-from bs nil)
                )
                (when (< fs  fp)
                        (princ "illegal frequencies fs:  ") (princ fs)
                        (princ "greater than fp: ") (princ fp) (princ "\n")
                        (return-from bs nil)



                      January 15, 1992





                           - 31 -


                )
                ;------------------------------------------------------
                ; assure that gains are negative db and gp > gs
                ;------------------------------------------------------
                (if (< 0 gs)
                        (setf gs (- gs))
                )
                (if (< 0 gp)
                        (setf gp (- gp))
                )
                (when (< gp gs)
                        (princ "illegal gains db, gp: ") (princ gp)
                        (princ "less than gs: ") (princ gs) (princ "\n")
                        (return-from bs nil)
                )
                (setf gp (expt 10. (/ gp 20)))
                (setf gs (expt 10. (/ gs 20)))
                (setf e (sqrt (- (/ 1 gp) 1)))
                (setf a (sqrt (/ 1 gs)))
                ;------------------------------------------------------
                ; evaluate the integer order of the filter
                ;------------------------------------------------------
                (setf n (log (/ e (sqrt (- (* a a) 1)))))
                (setf n (/ n (log (/ fp fs))))
                (if ( < (truncate n) n)
                        (setf n (+ (truncate n) 1))
                        (setf n (truncate n))
                )
                ;------------------------------------------------------
                ; assure that n is a multiple of 4, this simplifies
                ; the logic of coefficient evaluation
                ;------------------------------------------------------
                (if ( < (truncate (/ n base)) (/ n base))
                        (setf n (* (+ (truncate (/ n base)) 1) base))
                )
                ;------------------------------------------------------
                ; evaluate filter cutoff frequency (3db down point)
                ;------------------------------------------------------
                (setf e (exp (/ (log e) n)))
                (setf fc (/ fp e))
                (return-from bs (combine n fc))
        ) ; END block bs
        ) ; END let
)
(defun iir-test ()
        "------------------------------------------------------------------
        iir-test () test the following infinite impulse (iir) filter functions
                low-pass-iir
                high-pass-iir
                band-pass-iir
                band-stop-iir






                      January 15, 1992





                           - 32 -


        testing consists of generating a white noise time series, filtering
        the time series and plotting the smoothed power spectrum of the
        filter output
        ------------------------------------------------------------------"
        (let ((y 0) (x 0) (ypsd 0) (xpsd 0) (xfer 0) (freq 0)(samp-size 200)
                (xfreq 0))
                (setf x (normal-rand samp-size))
                (setf freq (rseq 0 .5 (/ samp-size 2)))
                (setf xfreq (rseq 0 .5 50))
                (message "smooth psd of white noise input series")
                (setf xpsd (smooth-psd x))
                (tekpoints freq xpsd)
                ;---------------------------------------------------------
                ; low pass
                ;---------------------------------------------------------
                (setf y (low-pass-iir x .2 (- 3) .3 (- 20) ))
                (message "smooth psd of low pass iir output")
                (message ".2Hz -3db .3Hz -20db")
                (setf ypsd (smooth-psd y))
                (tekpoints freq ypsd)
                (message "analytical transfer magnitude of low-pass")
                (message ".2Hz -3db .3Hz -20db")
                (setf xfer (digital-transfer
                        (low-pass-design .2 (- 3) .3 (- 20)) :steps 50))
                (tekpoints xfreq xfer)
                ;---------------------------------------------------------
                ; high pass
                ;---------------------------------------------------------
                (setf y (high-pass-iir x .3 (- 20) .4 (- 3.)))
                (message "smooth psd of high pass iir output")
                (message ".3Hz -20db .4Hz -3db")
                (setf ypsd (smooth-psd y))
                (tekpoints freq ypsd)
                (message "analytical transfer magnitude of high pass")
                (message ".2Hz -3db .3Hz -20db")
                (setf xfer (digital-transfer
                        (high-pass-design .3 (- 20) .4 (- 3)) :steps 50))
                (tekpoints xfreq xfer)
                ;---------------------------------------------------------
                ; band pass
                ;---------------------------------------------------------
                (setf y (band-pass-iir x .3 (- 20) .35 (- 3.)
                        .4 (- 3.) .45 (- 20) ))
                (message "smooth psd of band pass iir output")
                (message "(.3Hz -20db .35Hz -3db .4Hz -3db .45Hz -20db)")
                (setf ypsd (smooth-psd y))
                (tekpoints freq ypsd)
                (message "analytical transfer magnitude of band pass iir")
                (message ".3Hz -20db .35Hz -3db .4Hz -3db .45Hz -20db")
                (setf xfer (digital-transfer (
                        band-pass-design .3 (- 20) .35 (- 3) .4 (- 3)
                                .45 (- 20)) :steps 50))
                (tekpoints xfreq xfer)
                ;---------------------------------------------------------



                      January 15, 1992





                           - 33 -


                ; band stop
                ;---------------------------------------------------------
                (setf y (band-stop-iir x .2 (- 3) .25 (- 20.)
                        .3 (- 20.) .35 (- 3) ))
                (message "smooth psd of band stop iir output")
                (message ".2Hz -3db .25Hz -20db .3Hz -20db .35Hz -3db")
                (setf ypsd (smooth-psd y))
                (tekpoints freq ypsd)
                (message "analytical transfer magnitude band stop iir")
                (message ".2Hz -3db .25Hz -20db .3Hz -20db .35Hz -3db")
                (setf xfer (digital-transfer
                        (band-stop-design .2 (- 3) .25 (- 20) .3 (- 20)





                                .35 (- 3)) :steps 50))
                (tekpoints xfreq xfer)
        ) ; END let
)




































                      January 15, 1992





                           - 34 -


;       timeseries functions
;       W. Hatch  uunet!bts!bill
;       Mon Nov 18 19:05:48 EST 1991
(defun at ()
        (analog-test)
)
(defun analog-test ( )
        "----------------------------------------------------------------
        analog-test () test the following analog low pass prototype filter
        transforms in this xlispstat file
                - analog-low2low
                - analog-low2high
                - analog-low2pass
                - analog-low2stop
                - analog24-transfer
        -----------------------------------------------------------------"
        (def fproto (/ 1 (* 2 pi)))
        (def freq-tags (rseq 0 .5 50))
        ;----------------------------------------------------------------
        ; low pass prototype  -  2d order Butterworth
        ;----------------------------------------------------------------
        (def lp-proto (combine 1 1 0 0 1 (* 2 (cos (/  pi 4)))))
        (def mag-lp-proto (analog24-transfer lp-proto))
        (message "lp-proto")
        (tekpoints freq-tags mag-lp-proto)
        ;----------------------------------------------------------------
        ; low2low
        ;----------------------------------------------------------------
        (def lp (analog-low2low lp-proto .2))
        (def mag-lp (analog24-transfer lp))
        (message "low pass , cutoff .2 Hz ")
        (tekpoints freq-tags mag-lp)
        ;----------------------------------------------------------------
        ; low2high
        ;----------------------------------------------------------------
        (def lp-proto (combine 1 1 0 0 1 (* 2 (cos (/ pi 4)))))
        (def hp (analog-low2high lp-proto .3 ))
        (def mag-hp (analog24-transfer hp ))
        (message "high pass , cutoff .3 Hz ")
        (print-object "high pass coefficients : " hp)
        (tekpoints freq-tags mag-hp)
        ;----------------------------------------------------------------
        ; low2pass
        ;----------------------------------------------------------------
        (def bp (analog-low2pass lp-proto .2 .3 ))
        (def mag-bp (analog24-transfer bp))
        (message "band pass , cutoff .2 Hz , .3 Hz")
        (tekpoints freq-tags mag-bp)
        ;----------------------------------------------------------------
        ; low2stop
        ;----------------------------------------------------------------
        (def bs (analog-low2stop lp-proto .2 .3 ))
        (def mag-bs (analog24-transfer bs))
        (message "band stop , cutoff .2 Hz , .3 Hz")



                      January 15, 1992





                           - 35 -


        (tekpoints freq-tags mag-bs)
)
(defun analog-low2low (coef freq)





        "-----------------------------------------------------------------
        analog-low2low (coef freq) given in coef the coefficients of an analog,
        low pass, second order filter with cutoff radian frequency of 1.0,
        return the coefficients of a low pass filter with cutoff
        frequency of f Hz .  The assumed form of a second order section is

           H(s) = K * (a2 * s**2 + a1 * s + a0)/(s**2 + b1 * s + b0)

        coef is a list (K a0 a1 a2 b0 b1), the returned list is
        (Ka alpha0 alpha1 alpha2 beta0 beta1 beta2)
        ------------------------------------------------------------------"
        (let ((K 0) (a0 0) (a1 0) (a2 0) (b0 0) (b1 0) (Ka 0) (alpha0 0)
                (alpha1 0) (alpha2 0) (beta0 0) (beta1 0) (w 0) (yield 0))
                (setf K (nth 0 coef))
                (setf a0 (nth 1 coef))
                (setf a1 (nth 2 coef))
                (setf a2 (nth 3 coef))
                (setf b0 (nth 4 coef))
                (setf b1 (nth 5 coef))
                (setf w (* 2 pi freq))
                (setf alpha2 a2)
                (setf alpha1 (* a1 w))
                (setf alpha0 (* a0 w w))
                (setf beta1  (* b1 w))
                (setf beta0  (* b0 w w))
                (setf Ka K)
                (setf yield (combine Ka alpha0 alpha1 alpha2 beta0 beta1))
        ) ; END let
)
(defun analog-low2high (coef freq)
        "-----------------------------------------------------------------
        analog-low2high (coef freq) given in coef the coefficients of an analog,
        low pass, second order filter with cutoff radian frequency of 1.0,
        return the coefficients of a high pass filter with cutoff
        frequency of freq Hz .  The assumed form of a second order section is

           H(s) = K * (a2 * s**2 + a1 * s + a0)/(s**2 + b1 * s + b0)

        coef is a list (K a0 a1 a2 b0 b1), the returned list is
        (Ka alpha0 alpha1 alpha2 beta0 beta1 beta2)
        ------------------------------------------------------------------"
        (let ((K 0) (a0 0) (a1 0) (a2 0) (b0 0) (b1 0) (Ka 0) (alpha0 0)
                        (alpha1 0) (alpha2 0) (beta0 0) (beta1 0) (w 0)
                        (yield 0)
                        (w2 0)
                )



                      January 15, 1992





                           - 36 -


        (block l2h
                ;(print-object "given coef : " coef)
                (setf K (nth 0 coef))
                (setf a0 (nth 1 coef))
                (setf a1 (nth 2 coef))
                (setf a2 (nth 3 coef))
                (setf b0 (nth 4 coef))
                (setf b1 (nth 5 coef))
                (setf w (* 2 pi freq))
                (setf w2 (* w w))
                (setf alpha2 a0)
                (setf alpha1 (* a1 w))
                (setf alpha0 (* a2 w2))
                (setf beta0  (/ w2 b0 ))
                (setf beta1  (/ (* b1 w) b0))
                (setf Ka (/ K b0))
                (setf yield (combine Ka alpha0 alpha1 alpha2 beta0 beta1))





                ;(print-object "yielded coef: " yield)
                (return-from l2h yield)
        ) ; END block l2h
        ) ; END let
)
(defun analog-low2pass (coef lowfreq upfreq)
        "-----------------------------------------------------------------
        analog-low2pass (coef lowfreq upfreq) given in coef the coefficients
        of an analog, low pass, second order filter with cutoff radian
        frequency of 1.0, return the coefficients of a band pass filter with
        lower cutoff frequency lowfreq and upper cutoff upfreq Hz.
        The assumed form of the given second order section is

                H(s) = K * (a2 * s**2 + a1 * s + a0)/(s**2 + b1 * s + b0)

        coef is a list (K a0 a1 a2 b0 b1), the returned list contains
        the coefficients for the 4th order band pass section as
        (Ka alpha0 alpha1 alpha2 alpha3 alpha4 beta0 beta1 beta2 beta3)
        ------------------------------------------------------------------"
        (let (  (K 0) (a0 0) (a1 0) (a2 0) (b0 0) (b1 0) (Ka 0) (alpha0 0)
                (alpha1 0) (alpha2 0) (alpha3 0) (alpha4 0) (w2 0)
                (beta1 0) (beta1 0) (beta2 0) (beta3 0) (Band 0) (w 0) (yield 0)
             )
        (block ab
                (when (< upfreq lowfreq)
                        (print-object "analog-low2pass upfreq : ",
                                (combine upfreq " < lowfreq : " lowfreq))
                        (return-from ab)
                )
                (setf K (nth 0 coef))
                (setf a0 (nth 1 coef))
                (setf a1 (nth 2 coef))



                      January 15, 1992





                           - 37 -


                (setf a2 (nth 3 coef))
                (setf b0 (nth 4 coef))
                (setf b1 (nth 5 coef))
                (setf w (sqrt (* 2 pi lowfreq 2 pi upfreq))) ;*** geo. mean freq
                (setf w2 (* w w))
                (setf Band (* 2 pi (- upfreq lowfreq))) ;*** Bandandwidth
                (setf Band2 (* Band Band))
                (setf alpha4 a2)
                (setf alpha3 (* a1 Band))
                (setf alpha2 (+ (* 2 a2 w2) (* a0 Band2)))
                (setf alpha1 (* a1 Band w2))
                (setf alpha0 (* a2 w2 w2))
                (setf beta0  (* w2 w2))
                (setf beta1  (* b1 Band w2))
                (setf beta2  (+ (* 2 w2) (* b0 Band2)))
                (setf beta3  (* b1 Band))
                (setf Ka  K )
                (setf yield (combine Ka alpha0 alpha1 alpha2 alpha3 alpha4
                        beta0 beta1 beta2 beta3))
        ) ; END block ab
        ) ; END let
)
(defun analog-low2stop (coef lowfreq upfreq)
        "-----------------------------------------------------------------
        analog-low2stop (coef lowfreq upfreq) given in coef the coefficients
        of an analog, low pass, second order filter with cutoff radian
        frequency of 1.0, return the coefficients of a band stop filter with
        lower cutoff frequency lowfreq and upper cutoff upfreq Hz.





        The assumed form of the given second order section is

                H(s) = K * (a2 * s**2 + a1 * s + a0)/(s**2 + b1 * s + b0)

        coef is a list (K a0 a1 a2 b0 b1), the returned list contains
        the coefficients for the 4th order band stop section as
        (Ka alpha0 alpha1 alpha2 alpha3 alpha4 beta0 beta1 beta2 beta3)
        ------------------------------------------------------------------"
        (let (  (K 0) (a0 0) (a1 0) (a2 0) (b0 0) (b1 0) (Ka 0) (alpha0 0)
                (alpha1 0) (alpha2 0) (alpha3 0) (alpha4 0) (w2 0)
                (beta1 0) (beta1 0) (beta2 0) (beta3 0) (Band 0) (w 0) (yield 0)
             )
        (block ap
                (when (< upfreq lowfreq)
                        (print-object "analog-low2stop upfreq : ",
                                (combine upfreq " < lowfreq : " lowfreq))
                        (return-from ap)
                )
                (setf K (nth 0 coef))
                (setf a0 (nth 1 coef))
                (setf a1 (nth 2 coef))



                      January 15, 1992





                           - 38 -


                (setf a2 (nth 3 coef))
                (setf b0 (nth 4 coef))
                (setf b1 (nth 5 coef))
                (setf w (sqrt (* 2 pi lowfreq 2 pi upfreq))) ;*** geo. mean freq
                (setf w2 (* w w))
                (setf Band (* 2 pi (- upfreq lowfreq))) ;*** Bandandwidth
                (setf Band2 (* Band Band))
                (setf alpha4 a0)
                (setf alpha3 (* a1 Band))
                (setf alpha2 (+ (* 2 a0 w2) (* a2 Band2)))
                (setf alpha1 (* a1 Band w2))
                (setf alpha0 (* a0 w2 w2))
                (setf beta0  (* w2 w2))
                (setf beta1  (/ (* b1 Band w2) b0))
                (setf beta2  (/ (+ (* 2 w2 b0) Band2) b0))
                (setf beta3  (/ (* b1 Band) b0))
                (setf Ka  (/ K b0))
                (setf yield (combine Ka alpha0 alpha1 alpha2 alpha3 alpha4
                        beta0 beta1 beta2 beta3))
        ) ; END block ap
        ) ; END let
)
(defun analog24-transfer (coef &key (hfreq .5) (steps 50))
        "------------------------------------------------------------
        analog24-transfer (coef &key (hfreq .5) (steps 50))
        returns magnitude of analog transfer function for a 2d or 4th
        order filter section with gain and coefficients in coef.
        these are for 2d order section: (K a0 a1 a2 b0 b1)
        with b2 assumed to be 1.0 and the transfer function given by

                H(S) = K * (a2 * s**2 + a1 * s + a0) / (s**2 + b1 * s + b0)

        For 4th order section the coefficients are
        (K a0 a1 a2 a3 a4 b0 b1 b2 b3) with b4 assumed to be 1.0
        -------------------------------------------------------------"
        (let (  (K (complex 0 0)) (a0 (complex 0 0)) (a1 (complex 0 0))
                (a2 (complex 0 0))
                (b0 (complex 0 0)) (b1 (complex 0 0)) (Ka (complex 0 0))
                (a3 (complex 0 0)) (a4 (complex 0 0)) (b2 (complex 0 0))
                (b3 (complex 0 0))
                (yield 0) (deltaf 0)
                (y 0) (num 0) (denom 0) (w 0) (s1 (complex 0 0))





                (s2 (complex 0 0)) (s3 (complex 0 0))
                (s4 (complex 0 0)) (zero 0)
             )
        (block ta
                (setf K (complex (nth 0 coef) 0))
                (setf a0 (complex (nth 1 coef) 0))
                (setf a1 (complex (nth 2 coef) 0))



                      January 15, 1992





                           - 39 -


                (setf a2 (complex (nth 3 coef) 0))
                (setf b0 (complex (nth 4 coef) 0))
                (setf b1 (complex (nth 5 coef) 0))
                (when (> (length coef)  6)
                        (setf a3 (complex (nth 4 coef) 0))
                        (setf a4 (complex (nth 5 coef) 0))
                        (setf b0 (complex (nth 6 coef) 0))
                        (setf b1 (complex (nth 7 coef) 0))
                        (setf b2 (complex (nth 8 coef) 0))
                        (setf b3 (complex (nth 9 coef) 0))
                        (setf b4 (complex 1 zero))
                )
                (when (< (length coef) 7)
                        (setf a3 (complex zero zero))
                        (setf a4 (complex zero zero))
                        (setf b2 (complex 1    zero))
                        (setf b3 (complex zero zero))
                        (setf b4 (complex zero zero))
                )
                (setf deltaf (/ hfreq steps))
                (dotimes (i steps)
                        (setf num (complex 0 0))
                        (setf denom (complex 0 0))
                        (setf w (complex 0 (* 2 pi i deltaf)))
                        (setf s1 w)
                        (setf s2 (* s1 w))
                        (setf s3 (* s2 w))
                        (setf s4 (* s3 w))
                        (setf num (+
                                        (* a4 s4)
                                        (* a3 s3)
                                        (* a2 s2)
                                        (* a1 s1)
                                        a0
                                )
                        )
                        (setf denom (+
                                        (* b4 s4)
                                        (* b3 s3)
                                        (* b2 s2)
                                        (* b1 s1)
                                        b0
                                )
                        )
                        (setf y (/  num denom))
                        (setf y (* K y))
                        (if (< i  1)
                                (setf yield (list (abs y)))
                                (setf yield (combine yield (abs y)))
                        )
                )
                (return-from ta yield)
        ) ; END block ta
        ) ; END let



                      January 15, 1992





                           - 40 -


)
























































                      January 15, 1992





                           - 41 -


;       timeseries functions
;       W. Hatch  uunet!bts!bill
;       Wed Nov 20 13:52:59 EST 1991
(defun tb2 ()
        (test-bilinear2)
)
(defun test-bilinear24 ()
        "----------------------------------------------------------------
        test-bilinear24 ()  test d2a-freq, bilinear2, bilinear4,
        and digital-transfer
        ----------------------------------------------------------------"
        (let (  (lp-proto 0) (lp 0) (lp-digital 0) (wd 0) (wa 0) (fa 0)
                )
                ; --------------------------------------------------------
                ; define Butterworth low-pass prototype
                ;---------------------------------------------------------
                (setf lp-proto (combine 1 1 0 0 1 (* 2 (cos (/  pi 4)))))
                ;------------------------------------------------------------
                ; pre-warp the .2 Hz digital cutoff frequency
                ;------------------------------------------------------------
                (setf wd (* 2 pi .2))
                (setf wa (tan (/ wd 2)))
                (setf fa (/ wa (* 2 pi)))
                (print-object "fa : " fa)
                ;------------------------------------------------------------
                ; compute analog filter and take bilinear transform
                ;------------------------------------------------------------
                (setf lp (analog-low2low lp-proto fa))
                (setf lp-digital (bilinear2 lp))
                (print-object "lp-digital .2 Hz cutoff : " lp-digital)
                ;------------------------------------------------------------
                ; compute digital filter transfer function magnitude vs freq
                ;------------------------------------------------------------
                (def lpd-transfer (digital-transfer lp-digital :steps 10))
                (print-object "lpd-transfer : " lpd-transfer)
                (def flow (d2a-freq .2))
                (def fhigh (d2a-freq .4))
                (print-object "digital flow : " (list flow " fhigh : " fhigh))
                (def band (analog-low2pass lp-proto flow fhigh))
                (print-object "band pass coef : " band)
                (def band-digital (bilinear4 band))
                (print-object "band-digital .2, .4 Hz cutoff : " band-digital)
                (def band-transfer (digital-transfer band-digital :steps 10))
                (print-object "band-transfer : " band-transfer)
        ) ; END let
)
(defun d2a-freq (fd)
        "-------------------------------------------------------------------
        d2a-freq (fd) given digital frequency 0 <= fd <= .5 Hz,
        returns pre-warped analog frequency fa for use of bilinear transform.
        --------------------------------------------------------------------"
        (let ((fa 0) (wa 0))
        (block adf
                (when (or ( < fd 0 ) (> fd .5))



                      January 15, 1992





                           - 42 -


                        (print-object "fd : "
                                (list fd " must be between 0 and .5 Hz")
                        )





                        (return-from adf)
                )
                (setf wa (tan (/ (* 2 pi fd) 2)))
                (setf fa (/ wa (* 2 pi)))
        ) ; END block adf
        ) ; END let
)
(defun a2d-freq (fa)
        "-------------------------------------------------------------------
        a2d-freq (fa) given digital frequency 0 <= fa <= + infinity
        returns un-warped digital frequency fd = 2*atan(2*pi*fd) / (2*pi)
        --------------------------------------------------------------------"
        (let ((fd 0) (wd 0))
        (block adf
                (when ( < fa 0 )
                        (print-object "fa : "
                                (list fa " must be between 0 and + infinity")
                        )
                        (return-from adf)
                )
                (setf wd (* 2 (atan (* 2 pi fa))))
                (setf fd (/ wd (* 2 pi)))
        ) ; END block adf
        ) ; END let
)
(defun bilinear2 (coef)
        "---------------------------------------------------------------
        bilinear2 (coef) return bilinear transform of 2d order analog
        filter section. The analog section is assumed to have the form

                H(s) = Ka * (a2 * s**2 + a1 * s + a0) / (s**2 + b1 * s + bo)

        The resultant digital filter is assumed to have the form

                H(z) = Kd*(z**2 + alpha1*z * alpha0) / (z**2 + beta1*Z + beta0)

        The given coef contains (Ka a0 a1 a2 b0 b1) and the returned list
        contains (Kd alpha0 alpha1 beta0 beta1). Note that in the digital
        filter, H(z), the 2d order terms in both numerator are assumed
        to have a coefficient of 1.0 .  In the analog filter, H(s), only
        the denominator coefficient of s**2 is assumed to be 1.0 .
        ---------------------------------------------------------------"
        (let ((Kd 0) (Ka 0) (a0 0) (a1 0) (a2 0) (b0 0) (b1 0) (b2 1) (yield 0)
                (alpha0 0) (alpha1 0) (beta0 0) (beta1 0) (Sn 0) (Sd 0)
             ) ; END local initialization
        (block bl2



                      January 15, 1992





                           - 43 -


                (when (< (length coef) 6)
                        (print-object "(length coef) : " (list
                                (length coef)
                                "less than 6 \ncoef contents : "
                                coef)
                        )
                        (return-from bl2)
                )
                ; extract given coef contents
                (setf Ka (nth 0 coef))
                (setf a0 (nth 1 coef))
                (setf a1 (nth 2 coef))
                (setf a2 (nth 3 coef))
                (setf b0 (nth 4 coef))





                (setf b1 (nth 5 coef))
                (setf Sn (+ a0 a1 a2))
                (setf Sd (+ b0 b1 b2))
                (setf Kd (/ (* Ka Sn) Sd))
                (setf alpha0 (/ (- (+ a2 a0) a1) Sn))
                (setf alpha1 (/ (* 2 (- a0 a2)) Sn))
                (setf beta0 (/ (- (+ b2 b0) b1) Sd))
                (setf beta1 (/ (* 2 (- b0 b2)) Sd))
                (setf yield (list Kd alpha0 alpha1 beta0 beta1))
                (return-from bl2 yield)
        ) ; END block bl2
        ) ; END let
)
(defun bilinear4 (coef)
        "---------------------------------------------------------------
        bilinear4 (coef) return bilinear transform of 4th order analog
        filter section. The analog section is assumed to have the form

                        Ka * (a4 * s**4 + a3 * s**3 + a2 * s**2 + a1 * s + a0)
                H(s) =  -----------------------------------------------------
                         (s**4 + b3 * s**3 + b2 * s**2 + b1 * s + bo)

        The resultant digital filter is assumed to have the form

                Kd * (z**4 + alpha3 * z**3 + alpha2 * z**2 + alpha1*z * alpha0)
        H(z) = ----------------------------------------------------------------
                (z**4 + beta3 * z**3 + beta2 * z**2 + beta1*Z + beta0)

        The given coef contains
                (Ka a0 a1 a2 a3 a4 b0 b1 b2 b3 )

        The returned list contains
                (Kd alpha0 alpha1 alpha2 alpha3 beta0 beta1 beta2 beta3)

        Note that in the digital filter, H(z), the 4th order terms in



                      January 15, 1992





                           - 44 -


        both numerator are assumed to have a coefficient of 1.0 .
        In the analog filter, H(s), only the denominator coefficient of
        s**4 is assumed to be 1.0 .
        ---------------------------------------------------------------"
        (let ((Kd 0) (Ka 0) (a0 0) (a1 0) (a2 0) (a3 0) (a4 0)
                (b0 0) (b1 0) (b2 1) (b3 0) (b4 1) (yield 0)
                (alpha0 0) (alpha1 0) (alpha2 0) (alpha3 0)
                (beta0 0) (beta1 0) (beta2 0) (beta3 0) (Sn 0) (Sd 0)
             ) ; END local initialization
        (block bl4
                (when (< (length coef) 10)
                        (print-object "(length coef) : " (list
                                (length coef)
                                "less than 10 \ncoef contents : "
                                coef)
                        )
                        (return-from bl4)
                )
                ; extract given coef contents
                (setf Ka (nth 0 coef))
                (setf a0 (nth 1 coef))
                (setf a1 (nth 2 coef))
                (setf a2 (nth 3 coef))
                (setf a3 (nth 4 coef))
                (setf a4 (nth 5 coef))
                (setf b0 (nth 6 coef))
                (setf b1 (nth 7 coef))
                (setf b2 (nth 8 coef))





                (setf b3 (nth 9 coef))
                (setf Sn (+ a0 a1 a2 a3 a4))
                (setf Sd (+ b0 b1 b2 b3 b4))
                (setf Kd (/ (* Ka Sn) Sd))
                (setf alpha0 (- (+ a4 a2 a0) (+ a3 a1)) )
                (setf alpha0 (/ alpha0 Sn))
                (setf alpha1 (+ (* 2 (- a3 a1))  (* 4 (- a0 a4))))
                (setf alpha1 (/ alpha1 Sn))
                (setf alpha2 (-  (* 6 (+ a4 a0))  (* 2 a2) )  )
                (setf alpha2 (/ alpha2 Sn))
                (setf alpha3 (+ (* 4 (- a0 a4)) (* 2 (- a1 a3))))
                (setf alpha3 (/ alpha3 Sn))
                (setf beta0 (- (+ b4 b2 b0) (+ b3 b1) ))
                (setf beta0 (/ beta0 Sd))
                (setf beta1 (+ (* 2 (- b3 b1))  (* 4 (- b0 b4))))
                (setf beta1 (/ beta1 Sd))
                (setf beta2 (-  (* 6 (+ b4 b0))  (* 2 b2) )  )
                (setf beta2 (/ beta2 Sd))
                (setf beta3 (+ (* 4 (- b0 b4)) (* 2 (- b1 b3))))
                (setf beta3 (/ beta3 Sd))
                (setf yield (list Kd alpha0 alpha1 alpha2 alpha3



                      January 15, 1992





                           - 45 -


                        beta0 beta1 beta2 beta3))
                (return-from bl4 yield)
        ) ; END block bl4
        ) ; END let
)
(defun digital-transfer (coef &key (hfreq .5) (steps 50) (magnitude t))
        "------------------------------------------------------------------
        digital-transfer (coef &key (hfreq .5) (steps 50) magnitude t))
        returns the magnitude of the H(z) for z = exp(j*2*pi*f(i))
        where f(i) ranges from 0 Hz to hfreq in steps and j=sqrt(-1)

                            z**n + a(n-1)*z**(n-1) ... + a(1)*z + a(0)
                H(z)= Kd*  -------------------------------------------
                            z**n + b(n-1)*z**(n-1) ... + b(1)*z + b(0)

        coef contains (Kd a(0) a(1) ... a(n-1) b(0) b(1) ... b(n-1)

        if the given magnitude is false, then the complex digital transfer
        function is returned
        ------------------------------------------------------------------"
        (let    ((num 0) (denom 0) (freq 0) (K 0) (n 0) (z 0) (dfreq 0)
                 (zexp 1) (y 0) (yield 0)
                )
        (block dt
                ;--------------------------------------------------------
                ; treat multiple sections (lists)
                ;--------------------------------------------------------
                (if (listp (first coef))
                        (return-from dt (multi-sect-digital-transfer
                                coef :hfreq hfreq :steps steps
                                :magnitude magnitude))
                )
                (setf dfreq (/ hfreq steps))            ; frequency step size
                (setf n (/ (- (length coef) 1) 2))      ; order of H(z)
                (setf K (nth 0 coef))                   ; gain
                ;------------------------------------------------------------
                ; loop over frequencies
                ;------------------------------------------------------------
                (dotimes (i steps)
                        (setf z (exp (complex 0 (* i 2 pi dfreq))))
                        (setf zexp 1)
                        (setf num 0)





                        (setf denom 0)
                        ;---------------------------------------------------
                        ; loop over powers of z = exp (complex 0 wt)
                        ;---------------------------------------------------
                        (dotimes (j  n)
                                (setf num
                                        (+ num (* zexp (nth (+ j 1) coef)))



                      January 15, 1992





                           - 46 -


                                )
                                (setf denom
                                        (+ denom (* zexp (nth (+ j n 1) coef)))
                                )
                                ;---------------------------------------------
                                ; compute (j+1)th power of z
                                ;---------------------------------------------
                                (setf zexp (* zexp z))
                        ) ; END dotimes j
                        ;------------------------------------------------------
                        ; nth power of z has coefficient 1.0 in both num, denom
                        ;------------------------------------------------------
                        (setf num (+ num zexp))
                        (setf denom (+ denom  zexp))
                        (if  magnitude
                                (setf y (abs (* K (/ num denom))))
                                (setf y (* K (/ num denom)))
                        )
                        (if (= i 0)
                                (setf yield (list y))
                                (setf yield (combine yield y))
                        ) ; END if
                ) ; END dotimes i
                (return-from dt yield)
        ) ; END block dt
        ) ; END let
)
(defun multi-sect-digital-transfer (coef &key (hfreq .5) (steps 50)
        (magnitude t))
        "-------------------------------------------------------------
        multi-sect-digital-transfer (coef &key (hfreq .5) (steps 50)
                (magnitude t))
        returns the magnitude of the H(z) for z = exp(j*2*pi*f(i))
        where f(i) ranges from 0 Hz to hfreq in steps and j=sqrt(-1)
        The transfer function for each section is of the form

                            z**n + a(n-1)*z**(n-1) ... + a(1)*z + a(0)
                HS(z)= Kd*  -------------------------------------------
                            z**n + b(n-1)*z**(n-1) ... + b(1)*z + b(0)

        and the overall transfer function is

                H(z) = H0(z) * H1(z) * ...

        coef contains (coef0 coef1 .... ) and for each section coef(i)
        contains

        (Kd a(0) a(1) ... a(n-1) b(0) b(1) ... b(n-1)

        if given magnitude is false, then the complex frequency domain
        transfer function is returned
        -------------------------------------------------------------"
        (block msdt
        (let ((coefi 0) (nsect 0) (Hi 0) (H 0))



                      January 15, 1992





                           - 47 -


                (setf nsect (length coef))
                (dotimes (i nsect)





                        (setf coefi (nth i coef))
                        (setf Hi (digital-transfer coefi
                                :hfreq hfreq :steps steps
                                :magnitude magnitude))
                        (if (= i 0)
                                (setf H Hi)
                                (setf H (* H Hi))
                        )
                ) ; END dotimes i
                (return-from msdt H)
        ) ; END let
        ) ; END block msdt
)





































                      January 15, 1992





                           - 48 -


; t5.lsp
; top level digital filter design functions
; Sun Nov 24 19:36:43 EST 1991
;
;Bill Hatch
;Coleman Research Corporation
;14502 Greenview Drive Suite 206
;Laurel, Maryland 20708
;Phone (301)470-3839
;FAX (301)776-5461
;HOME (301)441-1675
;uunet!bts!bill
;
(def butterworth "butterworth")
(defun dftt ()
        (digital-filter-design-test)
)

(defun digital-filter-design-test ()
        "----------------------------------------------------------------
        digital-filter-design--test () test the following functions
                - low-pass-design
                - high-pass-design
                - band-pass-design
                - band-stop-design
                - digital-transfer
                - butterworth-analog-lp-proto
                - d2a-freq
                - bilinear2
                - bilinear4
        -----------------------------------------------------------------"
        (let ((coef 0) (H 0) (freq 0))
                (setf freq (rseq 0 .5 50))
                (message "low pass digital filter design")
                (setf coef (low-pass-design .2 (- 3.) .3 (- 20.)))
                (setf H (digital-transfer coef))
                (tekpoints freq H)
                (message "high pass digital filter design")
                (setf coef (high-pass-design .2 (- 20.) .3 (- 3.)))
                (setf H (digital-transfer coef))
                (tekpoints freq H)
                (message "band pass digital filter design")
                (setf coef (band-pass-design .1 (- 20.) .2 (- 3.) .3 (- 3.)
                        .4 (- 20.)))
                (setf H (digital-transfer coef))
                (tekpoints freq H)
                (message "band stop digital filter design")
                (setf coef (band-stop-design .1 (- 3.) .2 (- 20.) .3 (- 20.)
                        .4 (- 3.)))
                (setf H (digital-transfer coef))
                (tekpoints freq H)
        ) ; END let
)
(defun low-pass-design (fp gp fs gs &key (type "butterworth"))



                      January 15, 1992





                           - 49 -


        "-------------------------------------------------------------------
        low-pass-design (fp gp fs gs &key (type butterworth))
        given pass frequency fp and gp, the gain in db at fp, the stop





        frequency fs and gs, the gain in db at fs.  gp and gs must be
        negative with gp > gs.  both fp and fs must be between 0 and .5
        with fp < fs.  the function returns a list of lists.
        each of the component lists contains the digital gain Kd and the
        coefficients for one serial section of the filter.
        a typical 2d order section would contain (Kd a0 a1 b0 b1) and
        the corresponding digital transfer function for the section is

                H(z) = Kd * (z**2 + a1 * z + a0) / (z**2 + b1 * z + b0)

        note that the coefficients of z**2 is 1.0 in both numerator and
        denominator.

        at present butterworth is the only type that is implemented.
        -------------------------------------------------------------------"
        (block lpd
                (when (or (> 0. fp) (> 0. fs) (> fp fs) (> fp .5) (> fs .5))
                        (print-object
                                "low-pass-design:: fp : " (list fp " fs : " fs))
                        (message
                          "requires: 0 < fp < .5 ; 0 < fs < .5 ; and fp < fs")
                        (return-from lpd)
                )
                (when (or (> gs 0) (> gp 0) (> gs gp))
                        (print-object
                                "low-pass-design:: gp : " (list gp " gs : " gs))
                        (message "requires: 0 > gp, 0 > gs and gp > gs")
                        (return-from lpd)
                )
        ;(message "low-pass-design: validity checks ok")
        (let    ((nsect 0) (fc 0) (y 0) (yield 0) (n2 0) (order-fc 0)
                (pass-freq 0)
                (stop-freq 0) (pass-gain 0) (stop-gain 0) (order 0)
                )
                ;-------------------------------------------------------------
                ; pre-warp the frequencies to map digital frequencies to
                ; analog prototype
                ;-------------------------------------------------------------
                (setf pass-freq (d2a-freq fp))
                (setf stop-freq (d2a-freq fs))
                ;-------------------------------------------------------------
                ; determine number of sections and cutoff frequency
                ; restrict to nsect even meaning all 2d order sections
                ;-------------------------------------------------------------
                (setf order-fc (butterworth-size pass-freq gp stop-freq gs
                        :base 2))



                      January 15, 1992





                           - 50 -


                ;(print-object "order-fc : " order-fc)
                (setf order (nth 0 order-fc))
                (setf fc (nth 1 order-fc))
                (setf nsect (/ order 2))
                (dotimes (k nsect)
                        (setf y (butterworth-analog-lp-proto order k))
                        ;(print-object "butterworth-analog-proto: " y)
                        (setf y (analog-low2low y fc))
                        ;(print-object "analog-low2low: " y)
                        (setf y (bilinear2 y))
                        ;(print-object "bilinear: " y)
                        (if (= k 0)
                                (setf yield (list y))
                                (setf yield (append yield (list y)))
                        )
                ) ; END dotimes
                (return-from lpd yield)
        ) ; END let
        ) ; END block lpd
)





(defun butterworth-analog-lp-proto (order k)
        "-------------------------------------------------------------------
        butterworth-analog-lp-proto (order k)
        -------------------------------------------------------------------"
        (let ((yield 0) (b1 0))
                (setf b1 (* (+ (* 2 k) 1) pi))
                (setf b1 (* 2 (cos (/ b1 (* 2 order)))))
                (setf yield (list 1 1 0 0 1 b1 1))
        ) ; END let
)
(defun high-pass-design (fs gs fp gp &key (type "butterworth"))
        "-------------------------------------------------------------------
        high-pass-design (fs gs fp gp &key (type butterworth))
        given stop frequency fs and gs, the gain in db at fs, the pass
        frequency fp and gp, the gain in db at fp.  gs and gp must be
        negative with gp > gs.  both fp and fs must be between 0 and .5
        with fp > fs.  the function returns a list of lists.
        each of the component lists contains the digital gain Kd and the
        coefficients for one serial section of the filter.
        a typical 2d order section would contain (Kd a0 a1 b0 b1) and
        the corresponding digital transfer function for the section is

                H(z) = Kd * (z**2 + a1 * z + a0) / (z**2 + b1 * z + b0)

        note that the coefficients of z**2 is 1.0 in both numerator and
        denominator.

        at present butterworth is the only type that is implemented.
        -------------------------------------------------------------------"



                      January 15, 1992





                           - 51 -


        (block hpd
                (when (or (> 0. fp) (> 0. fs) (< fp fs) (> fp .5) (> fs .5))
                        (print-object
                            "high-pass-design:: fp : " (list fp " fs : " fs))
                        (message
                          "requires: 0 < fp < .5 ; 0 < fs < .5 ; and fp > fs")
                        (return-from hpd)
                )
                (when (or (> gs 0) (> gp 0) (> gs gp))
                        (print-object
                            "high-pass-design:: gp : " (list gp " gs : " gs))
                        (message "requires: 0 > gp, 0 > gs and gp > gs")
                        (return-from hpd)
                )
        ;(message "high-pass-design: validity checks ok")
        (let    ((nsect 0) (fc 0) (y 0) (yield 0) (n2 0) (order-fc 0)
                (pass-freq 0)
                (stop-freq 0) (pass-gain 0) (stop-gain 0) (order 0)
                )
                ;-------------------------------------------------------------
                ; pre-warp the frequencies to map digital frequencies to
                ; analog prototype
                ;-------------------------------------------------------------
                (setf pass-freq (d2a-freq fp))
                (setf stop-freq (d2a-freq fs))
                ;-------------------------------------------------------------
                ; convert frequencies to mirror image for low pass prototype
                ;-------------------------------------------------------------
                (setf pass-freq (- .5 pass-freq))
                (setf stop-freq (- .5 stop-freq))
                ;-------------------------------------------------------------





                ; determine number of sections and cutoff frequency
                ; restrict to nsect even meaning all 2d order sections
                ;-------------------------------------------------------------
                (setf order-fc (butterworth-size pass-freq gp stop-freq gs
                        :base 2))
                ;(print-object "order-fc : " order-fc)
                ;-------------------------------------------------------------
                ; extract order and fc, take mirror image of fc to get
                ; high pass cutoff frequency
                ;-------------------------------------------------------------
                (setf order (nth 0 order-fc))
                (setf fc (- .5 (nth 1 order-fc)))
                (setf nsect (/ order 2))
                (dotimes (k nsect)
                        (setf y (butterworth-analog-lp-proto order k))
                        ;(print-object "butterworth-analog-proto: " y)
                        (setf y (analog-low2high y fc))
                        ;(print-object "analog-low2high: " y)



                      January 15, 1992





                           - 52 -


                        (setf y (bilinear2 y))
                        ;(print-object "bilinear: " y)
                        (if (= k 0)
                                (setf yield (list y))
                                (setf yield (append yield (list y)))
                        )
                ) ; END dotimes
                (return-from hpd yield)
        ) ; END let
        ) ; END block hpd
)
(defun band-pass-design (fs1 gs1 fp1 gp1 fp2 gp2 fs2 gs2
        &key (type "butterworth"))
        "-------------------------------------------------------------------
        band-pass-design (fs1 gs1 fp1 gp1 fs2 gp2 fs2 gs2
                &key (type butterworth))
        given frequencies fs1, fp1, fp2, fs2 and the corresponding gains
        gp1, fp2, gp2, and gs2, where fs1 and fs2 are the stop frequencies,
        gs1 and gs2 are the stop gains, fp1 and fp2 are the pass frequencies,
        gp1 and gp2 are the pass gains.
        The frequencies are in Hz with 0 < fs1 < fp1 < fp2 < fs2 < .5 .
        The gains are negative db with gs1 and gs2 < gp1 and gp2 .

        the function returns a list of lists.  each of the component
        lists contains the digital gain Kd and the coefficients for
        one serial section of the filter.  a typical 4th order section
        would contain (Kd a0 a1 a2 a3 b0 b1 b2 b3) and the
        corresponding digital transfer function for the section is

                            (z**4 + a3 * z**3 + a2 * z**2 + a1 * z + a0)
                H(z) = Kd * --------------------------------------------
                            (z**4 + b3 * z**3 + b2 * z**2 + b1 * z + b0)

        note that the coefficients of z**4 is 1.0 in both numerator and
        denominator.

        at present butterworth is the only type that is implemented.
        -------------------------------------------------------------------"
        (block bpd
                (when (or
                        (> 0. fp1) (> 0. fp2)
                        (> 0. fs1) (> 0. fs2)
                        (not (< fs1 fp1 fp2 fs2))
                        (> fp1 .5) (> fp2 .5)
                        (> fs2 .5) (> fs2 .5)





                      )
                        (print-object
                                "band-pass-design:: fs1 : "
                                (list fs1



                      January 15, 1992





                           - 53 -


                                        " fp1 : "
                                        fp1
                                        " fp2 : "
                                        fp2 " fs2 : "
                                        fs2)
                                )
                        (message
          "requires: 0 < fp. < .5 ; 0 < fs. < .5 ; and fs1 < fp1 < fp2 < fs2")
                        (return-from bpd)
                ) ; END when

                (when (or (> gs1 0) (> gs2 0) (> gp1 0) (> gp2 0)
                        (> gs1 gp1) (> gs2 gp2 ))
                        (print-object
                        "band-pass-design:: gs1 : "
                                (list gs1
                                        " gp1 : "
                                        gp1
                                        " gp2 : "
                                        gp2
                                        " gs2 : "
                                        gs2 )
                                )
                        (message
                "requires: 0 > gp[12] , 0 > gs[12]  and gp[12] > gs[12]")
                        (return-from bpd)
                ) ; END when

        ;(message "band-pass-design: validity checks ok")
        (let    ((nsect 0) (fc1 0) (fc2 0) (y 0) (yield 0) (n2 0)
                (order-fc1 0) (ordef-fc2 0)
                (pass-freq1 0) (pass-freq2 0)
                (stop-freq1 0) (pass-freq2 0)
                (pass-gain 0) (stop-gain 0) (order 0)
                )
                ;-------------------------------------------------------------
                ; pre-warp the frequencies to map digital frequencies to
                ; analog prototype
                ;-------------------------------------------------------------
                (setf pass-freq1 (d2a-freq (- .5 fp1)))
                (setf pass-freq2 (d2a-freq  fp2))
                (setf stop-freq1 (d2a-freq (- .5 fs1)))
                (setf stop-freq2 (d2a-freq fs2))
                ;-------------------------------------------------------------
                ; determine number of sections and cutoff frequency
                ; restrict to nsect even meaning all 2d order sections
                ;-------------------------------------------------------------
                (setf order-fc2 (butterworth-size pass-freq2 gp2 stop-freq2 gs2
                        :base 2))
                (setf order-fc1 (butterworth-size pass-freq1 gp1
                        stop-freq1 gs1 :base 2))
                ;(print-object "from size [analog] : "
                ;       (list "fc1-lp: " (second order-fc1)
                ;       " fc2: " (second order-fc2)))



                      January 15, 1992





                           - 54 -


                (setf order (max (first order-fc2) (first order-fc1)))
                (setf fc1 (- .5 (a2d-freq (second order-fc1))))
                ;(print-object "fc1-bp [digital]: " fc1)
                (setf fc1 (d2a-freq fc1))
                ;(print-object "fc1-bp [analog]: " fc1)
                (setf fc2 (second order-fc2))
                (setf nsect (/ order 2))
                (dotimes (k nsect)





                        (setf y (butterworth-analog-lp-proto order k))
                        ;(print-object "butterworth-analog-proto: " y)
                        (setf y (analog-low2pass y fc1 fc2))
                        ;(print-object "analog-low2band: " y)
                        (setf y (bilinear4 y))
                        ;(print-object "bilinear: " y)
                        (if (= k 0)
                                (setf yield (list y))
                                (setf yield (append yield (list y)))
                        )
                ) ; END dotimes
                (return-from bpd yield)
        ) ; END let
        ) ; END block bpd
)
(defun band-stop-design (fp1 gp1 fs1 gs1 fs2 gs2 fp2 gp2
        &key (type "butterworth"))
        "-------------------------------------------------------------------
        band-stop-design (fp1 gp1 fs1 gs1 fs2 gs2 fp2 gp2
                &key (type butterworth))
        given frequencies fp1, fs1, fs2, fp2 and the corresponding gains
        gs1, gp1, gs2, and gp2, where fs1 and fs2 are the stop frequencies,
        gs1 and gs2 are the stop gains, fp1 and fp2 are the stop frequencies,
        gp1 and gp2 are the stop gains.
        The frequencies are in Hz with 0 < fp1 < fs1 < fs2 < fp2 < .5 .
        The gains are negative db with gs1 and gs2 < gp1 and gp2 .

        the function returns a list of lists.  each of the component
        lists contains the digital gain Kd and the coefficients for
        one serial section of the filter.  a typical 4th order section
        would contain (Kd a0 a1 a2 a3 b0 b1 b2 b3) and the
        corresponding digital transfer function for the section is

                            (z**4 + a3 * z**3 + a2 * z**2 + a1 * z + a0)
                H(z) = Kd * --------------------------------------------
                            (z**4 + b3 * z**3 + b2 * z**2 + b1 * z + b0)

        note that the coefficients of z**4 is 1.0 in both numerator and
        denominator.

        at present butterworth is the only type that is implemented.



                      January 15, 1992





                           - 55 -


        -------------------------------------------------------------------"
        (block bsd
                (when (or
                        (> 0. fp1) (> 0. fp2)
                        (> 0. fs1) (> 0. fs2)
                        (not (< fp1 fs1 fs2 fp2))
                        (> fp1 .5) (> fp2 .5)
                        (> fs2 .5) (> fs2 .5)
                      )
                        (print-object
                                "band-stop-design:: fs1 : "
                                (list fs1
                                        " fp1 : "
                                        fp1
                                        " fp2 : "
                                        fp2 " fs2 : "
                                        fs2)
                                )
                        (message
          "requires: 0 < fp. < .5 ; 0 < fs. < .5 ; and fp1 < fs1 < fs2 < fp2")
                        (return-from bsd)
                ) ; END when






                (when (or (> gs1 0) (> gs2 0) (> gp1 0) (> gp2 0)
                        (> gs1 gp1) (> gs2 gp2 ))
                        (print-object
                        "band-stop-design:: gs1 : "
                                (list gs1
                                        " gp1 : "
                                        gp1
                                        " gp2 : "
                                        gp2
                                        " gs2 : "
                                        gs2 )
                                )
                        (message
                "requires: 0 > gp[12] , 0 > gs[12]  and gp[12] > gs[12]")
                        (return-from bsd)
                ) ; END when

        ;(message "band-stop-design: validity checks ok")
        (let    ((nsect 0) (fc1 0) (fc2 0) (y 0) (yield 0) (n2 0)
                (order-fc1 0) (ordef-fc2 0)
                (pass-freq1 0) (pass-freq2 0)
                (stop-freq1 0) (pass-freq2 0)
                (pass-gain 0) (stop-gain 0) (order 0)
                )
                ;-------------------------------------------------------------
                ; pre-warp the frequencies to map digital frequencies to



                      January 15, 1992





                           - 56 -


                ; analog prototype
                ;-------------------------------------------------------------
                (setf pass-freq1 (d2a-freq fp1))
                (setf pass-freq2 (d2a-freq (- .5 fp2)))
                (setf stop-freq1 (d2a-freq fs1))
                (setf stop-freq2 (d2a-freq (- .5 fs2)))
                ;-------------------------------------------------------------
                ; determine number of sections and cutoff frequency
                ; restrict to nsect even meaning all 2d order sections
                ;-------------------------------------------------------------
                (setf order-fc1 (butterworth-size pass-freq1 gp1 stop-freq1 gs1
                        :base 2))
                (setf order-fc2 (butterworth-size pass-freq2 gp2
                        stop-freq2 gs2 :base 2))
                ;(print-object "from size [analog] : "
                ;       (list "fc1-bs: " (second order-fc1)
                ;       " fc2: " (second order-fc2)))
                (setf order (max (first order-fc2) (first order-fc1)))
                (setf fc2 (- .5 (a2d-freq (second order-fc2))))
                ;(print-object "fc2-bs [digital]: " fc2)
                (setf fc2 (d2a-freq fc2))
                ;(print-object "fc2-bs [analog]: " fc2)
                (setf fc1 (second order-fc1))
                ;(print-object "fc1-bs [analog]: " fc1)
                (setf nsect (/ order 2))
                (dotimes (k nsect)
                        (setf y (butterworth-analog-lp-proto order k))
                        (setf y (analog-low2stop y fc1 fc2))
                        (setf y (bilinear4 y))
                        (if (= k 0)
                                (setf yield (list y))
                                (setf yield (append yield (list y)))
                        )
                ) ; END dotimes
                ;(message "END dotimes")
                (return-from bsd yield)
        ) ; END let
        ) ; END block bsd
)


















                      January 15, 1992





                           - 57 -


; t6.lsp
; fft convolution and correlation
; Sat Nov 30 18:45:22 EST 1991
;
;Bill Hatch
;Coleman Research Corporation
;14502 Greenview Drive Suite 206
;Laurel, Maryland 20708
;Phone (301)470-3839
;FAX (301)776-5461
;HOME (301)441-1675
;uunet!bts!bill
;
(defun convolve (x h)
        "-------------------------------------------------------------------
        convolve (x h)  discrete concolution of 2 finite duration sequences
        h and x .  h and x may be different lengths
        Reference: Brigham, The Fast Fourier Transform And Its Applications
        Prentice-Hall 1988, page 208
        -------------------------------------------------------------------"
        (let ( (y 0) (N 0) (P 0) (Q 0) (myx 0) (myh 0)
             )
        (setf P (length x))
        (setf Q (length h))
        (setf N (+ P Q))
        (setf myx (combine x (vec-const 0 (- N P))))
        ;(print-object "myx: " myx)
        (setf myh (combine h (vec-const 0 (- N Q))))
        ;(print-object "myh: " myh)
        (setf y (/ (* (fft myx) (fft myh)) N))
        ;(print-object "fft(y): " y)
        (setf y (fft y t))
        (realpart y)
        ) ; END let
)
(defun correlate (x h)
        "-------------------------------------------------------------------
        correlate (x h)  discrete correlation of 2 finite duration sequences
        h and x .  h and x may be different lengths. The output is scaled
        so that the largest positive peak is 1.0.
        Reference: Brigham, The Fast Fourier Transform And Its Applications
        Prentice-Hall 1988, page 228
        -------------------------------------------------------------------"
        (let ( (y 0) (N 0) (P 0) (Q 0) (myx 0) (myh 0)
             )
        (setf P (length x))
        (setf Q (length h))
        (setf N (+ P Q))
        (setf myx (combine (vec-const 0 (- N P)) x))
        ;(print-object "myx: " myx)
        (setf myh (combine h (vec-const 0 (- N Q) )))
        ;(print-object "myh: " myh)
        (setf y (/ (* (fft myx) (conjugate (fft myh))) N))
        ;(print-object "fft(y): " y)



                      January 15, 1992





                           - 58 -


        (realpart (fft y t))
        ) ; END let
)





(defun test-convolve ()
        "----------------------------------------------------------------
        test-convolve ()
        -----------------------------------------------------------------"
        (let ((N 0) (Q 10) (P 10) (N 0)
             )
                (setf x (list 1 2 3))
                (setf h x)
                (setf y (convolve x h))
                (print-object "convolve x h : " y)
                (message "(should be 1 4 10 12 9 0)")
                (setf y (correlate x x))
                (setf y (/ y (max y)))
                (message "correlation output")
                (print-object "y: " y)
                (print-object "y should be : " (list
                        0
                        .214286
                        .571429
                        1
                        .571429
                        .214286)
                )
        ) ; END let
)
(defun crshift (x)
        "-------------------------------------------------------------
        crshift (x) circular right shift of elements of list x
        CAUTION: this function has NOT been tested as of 12/4/91
        -------------------------------------------------------------"
        (block sh
                (if (not (listp x))
                        (return-from sh (message "crshift: x not a list"))
                )
                (let ((y 0))
                        (setf y (cdr x))
                        (setf y (combine y (car x)))
                        (return-from sh y)
                ) ; END let
        ) ; END block sh
)
(defun clshift (x)
        "-------------------------------------------------------------
        clshift (x) circular left shift of elements of list x
        CAUTION: this function has NOT been tested as of 12/4/91
        -------------------------------------------------------------"



                      January 15, 1992





                           - 59 -


        (block lsh
                (if (not (listp x))
                        (return-from lsh (message "clshift: x not a list"))
                )
                (let ((y 0)(myx 0))
                        (setf myx (reverse x))
                        (setf y (cdr myx))
                        (setf y (combine y (car myx)))
                        (return-from lsh (reverse y))
                ) ; END let
        ) ; END block lsh
)













































                      January 15, 1992


