(XLISP::CHECK-FSL-VERSION 1 3)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #("blin-tnp" PROVIDE) 0 NIL)
#K(#(80 1 3 0 1 2 4 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 4 2 4 5 0 3 5 16 5 6 21 1 4 5 5 38 7 7 23 8 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 9 7 23 8 0 4 4 7 2 1 23 10 0 2 2 4 11 0 2) #(0 20 25 30 47 68) #((NAME VARIABLES NEIGHBOURS VARIANCE EXPECTATION VAR-D-INV COV-D-SELF OBS-VARS OBS-D-ED LOCATION) TREE-NODE-PROTO NIL MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&key full (stream t))
Prints (to :stream) some basic information about the node.
If :full is t, gives full info. Returns nil." :INFO #K(#(77 3 2 0 0 0 21 20 20 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 8 62 23 24 23 22 0 3 3 22 24 62 21 24 23 22 0 3 3 20 24 62 19 24 23 22 0 3 3 18 24 23 22 0 2 3 17 62 16 24 38 23 25 23 24 0 4 24 3 25 15 62 14 24 23 22 0 3 3 13 24 21 0 1 2 2 62 11 24 1 3 0 12 24 21 0 4 5 24 62 11 25 23 22 25 3 3 10 25 62 9 26 23 22 26 3 3 8 26 23 22 27 2 3 7 62 6 28 38 23 29 23 24 28 4 28 3 29 15 62 23 29 23 22 29 3 3 5 29 62 4 30 38 23 31 23 24 30 4 30 3 31 15 23 25 0 6 25 26 27 28 29 30 11 0 12) #(0 95 100 103 108 182) #(COV-D-SELF "~&Cov(D,~a): " VAR-D-INV "~&Var(D)^(-1): " "~&d-E(D): ~a" OBS-D-ED "~&Observed variables: ~a" OBS-VARS NIL "~&Neighbours: ~a" NEIGHBOURS 3 VARIANCE "~&Variance: " "~&Expectation: ~a" EXPECTATION "~&Variables: ~a" VARIABLES "~&Junction Tree Node: ~a" NAME (NIL T) (:FULL :STREAM) FORMAT :FLOAT-DIGITS PRINT-MATRIX LIST) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:INFO) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (vars)
Returns a list of positions of the argument list, as a list." :POSITIONS #K(#(80 3 1 0 1 62 3 4 51 1 4 1 4 25 1 0 2 4 2 80 3 0 0 25 2 0 2 2 1) #(0 19) #(VARIABLES MAPCAR POSITION) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:POSITIONS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (vars (slot-value 'variables)))
Returns an expectation vector for the list of variables supplied
as an argument. Defaults to the full expectation vector for the node." :EX #K(#(77 1 2 1 3 3 0 1 2 3 21 2 1 2 2 0 2 6 1 3 62 5 6 62 5 7 23 4 7 2 6 7 21 0 4 5 7 62 3 7 38 5 8 23 6 8 3 1 8 6 25 7 0 2 7 8 23 8 6 1 6 23 9 6 1 6 38 10 7 25 11 0 3 6 7 4) #(0 15 20 23 37 56) #(EXPECTATION 0 VARIABLES #(%NOT-SUPPLIED) SUBSETP :POSITIONS SEND SELECT LENGTH LIST :INITIAL-ELEMENT MAKE-ARRAY) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:EX) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (v1 v2)
Returns a covariance matrix for the two variable lists supplied." :COV #K(#(80 4 1 0 3 62 4 5 38 1 6 23 2 6 3 1 6 2 38 1 7 23 2 7 3 1 7 3 25 3 0 3 5 6 7) #(0) #(VARIANCE :POSITIONS SEND SELECT) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:COV) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (vlist (slot-value 'variables)))
Returns a variance matrix for the list of variables supplied.
Defaults to the full variance matrix." :VAR #K(#(77 1 2 1 1 1 0 2 21 2 1 2 2 0 2 4 1 3 62 3 4 62 3 5 23 2 5 2 4 5 21 0 4 5 5 38 3 5 25 4 0 4 1 5 4 4 23 5 4 1 4 25 6 0 1 4) #(0 13 18 21 35 46) #(VARIABLES #(%NOT-SUPPLIED) SUBSETP :COV SEND LENGTH IDENTITY-MATRIX) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:VAR) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (vars (slot-value 'variables)))
Returns an adjusted expectation vector for the list of variables
suppied as an argument, based on unabsorbed data. Defaults to the
full adjusted expectation vector for the node." :AEX #K(#(77 1 2 1 5 5 0 1 2 3 4 5 21 2 1 2 2 0 2 8 1 3 62 7 8 62 7 9 23 6 9 2 8 9 21 0 4 5 9 62 6 9 62 5 10 23 7 10 1 10 62 4 11 62 3 12 23 8 10 3 10 11 12 2 43 9 10 9 38 9 10 23 10 10 3 1 10 8 25 11 0 2 9 10 38 12 9 25 10 0 3 1 9 8) #(0 17 22 25 39 84) #(OBS-D-ED VAR-D-INV COV-D-SELF EXPECTATION VARIABLES #(%NOT-SUPPLIED) SUBSETP TRANSPOSE %* :POSITIONS SEND SELECT :EX) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:AEX) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (vars (slot-value 'variables)))
Returns the adjusted variance matrix for the list of variables supplied.
Defaults to the full adjusted variance matrix for the node." :AVAR #K(#(77 1 2 1 1 1 0 3 21 2 1 2 2 0 2 4 1 3 62 3 4 38 2 5 23 3 5 3 1 5 4 38 4 6 23 3 6 3 1 6 4 2 45 5 6 0 57 0) #(0 13 18 21) #(VARIABLES #(%NOT-SUPPLIED) :VAR SEND :RVAR) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:AVAR) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (vars (slot-value 'variables)))
Returns the resolved variance matrix for the list of variables supplied.
Defaults to the full adjusted variance matrix for the node." :RVAR #K(#(77 1 2 1 4 4 0 1 2 3 4 21 2 1 2 2 0 2 7 1 3 62 6 7 62 6 8 23 5 8 2 7 8 21 0 4 5 8 62 4 8 23 6 8 1 8 62 3 9 62 4 10 23 7 8 3 8 9 10 38 8 9 23 9 9 3 1 9 7 38 8 10 23 9 10 3 1 10 7 25 10 0 3 8 9 10 23 11 8 1 7 23 11 9 1 7 23 12 7 2 8 9 38 13 8 25 14 0 3 7 8 5) #(0 16 21 24 38 86) #(VAR-D-INV COV-D-SELF 0 VARIABLES #(%NOT-SUPPLIED) SUBSETP TRANSPOSE %* :POSITIONS SEND SELECT LENGTH LIST :INITIAL-ELEMENT MAKE-ARRAY) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:RVAR) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (vars (slot-value 'variables)))
Returns the resolution transform matrix for the list of variables. Defaults to
the full transform for the node." :TRANSFORM #K(#(77 1 2 1 3 3 0 1 2 6 21 2 1 2 2 0 2 6 1 3 62 3 6 62 5 7 39 4 8 23 5 9 1 7 38 6 10 23 7 10 3 1 10 6 23 8 9 2 9 10 23 9 7 2 8 9 38 10 8 23 7 8 3 1 8 6 23 11 9 1 7 62 4 10 23 12 11 1 8 23 13 6 4 9 10 7 11 25 11 0 1 6) #(0 15 20 23) #(VARIABLES VAR-D-INV COV-D-SELF #(%NOT-SUPPLIED) BIND-COLUMNS COLUMN-LIST :POSITIONS SEND SELECT APPLY :VAR TRANSPOSE GINV %*) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:TRANSFORM) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :RESOLUTION #K(#(77 1 2 1 1 1 0 3 21 2 1 2 2 0 2 4 1 3 62 3 4 38 2 5 23 3 5 3 1 5 4 23 4 5 1 5 23 5 5 1 5 23 6 6 1 4 2 47 5 6 0 57 0) #(0 13 18 21) #(VARIABLES #(%NOT-SUPPLIED) :TRANSFORM SEND DIAGONAL SUM LENGTH) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:RESOLUTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (vars (slot-value 'variables)))
Returns the size-ratio for the adjustment of the given variables." :SIZE-RATIO #K(#(77 1 2 1 1 1 0 5 21 2 1 2 2 0 2 4 1 3 62 3 4 38 2 5 23 3 5 3 1 5 4 38 4 6 23 3 6 3 1 6 4 2 45 5 6 5 38 5 6 23 3 6 3 1 6 4 23 6 6 1 6 38 2 7 23 3 7 3 1 7 4 38 4 8 23 3 8 3 1 8 4 2 45 7 8 7 23 7 5 3 5 6 7 23 8 6 1 4 2 47 5 6 0 57 0) #(0 13 18 21) #(VARIABLES #(%NOT-SUPPLIED) :AEX SEND :EX :VAR GINV %* LENGTH) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:SIZE-RATIO) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (vars data)
Expects a list of variables to be observed, and a vector of
observations. Data slots are updated appropriately. Effect is
propagated around the join tree. Returns nil." :OBSERVE #K(#(80 4 8 0 1 2 3 4 5 6 7 10 63 11 2 0 38 8 12 23 9 12 3 1 12 2 2 45 3 12 12 63 10 12 0 38 10 12 23 9 12 3 1 12 2 23 11 12 1 12 63 9 12 0 38 12 12 62 8 13 23 9 12 4 1 12 2 13 63 7 12 0 62 6 12 16 12 13 21 1 1 2 12 23 13 14 1 13 38 14 15 62 4 16 62 8 17 62 11 18 62 10 19 62 9 20 62 7 21 23 9 0 8 14 15 16 17 18 19 20 21 17 12 12 16 12 13 21 1 1 2 12 11 0 5) #(0 83 132) #(NAME NIL NEIGHBOURS COV-D-SELF VARIABLES VAR-D-INV OBS-D-ED OBS-VARS :EX SEND :VAR GINV :COV SYMBOL-VALUE :PROPAGATE) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:OBSERVE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (dead-node)
Removes a dead node from the neighbour list of the
recieving object. Returns nil." :REMOVE-NEIGHBOUR #K(#(80 3 2 0 1 2 62 4 5 23 2 6 1 2 23 3 5 2 5 6 63 4 5 0 11 0 3) #(0) #(NIL NEIGHBOURS LIST SET-DIFFERENCE) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:REMOVE-NEIGHBOUR) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (call-node nil))
Send this message to any node on the join tree, and evidence
propagated around the graph by the last :OBSERVE will be 
incorporated into the tree. Observed variables will be removed.
Optional argument for internal use only. Returns nil." :ABSORB #K(#(77 1 2 1 10 10 0 1 2 3 4 5 6 7 8 9 6 38 11 13 23 12 13 2 1 13 63 12 13 0 38 13 13 23 12 13 2 1 13 63 11 13 0 62 10 13 62 9 14 23 14 13 2 13 14 38 15 14 23 12 14 3 1 14 13 63 12 14 0 38 16 14 23 12 14 3 1 14 13 63 11 14 0 63 10 13 0 63 9 8 0 63 7 8 0 63 6 8 0 63 5 8 0 62 10 13 50 0 1 3 13 8 62 4 14 16 14 15 21 1 2 3 14 23 17 16 1 15 38 18 17 62 3 18 23 12 0 3 16 17 18 17 14 14 16 14 15 21 1 2 3 14 62 4 13 23 19 14 1 2 23 14 13 2 13 14 16 13 14 21 1 4 5 13 23 17 15 1 14 38 20 16 62 3 17 23 12 0 3 15 16 17 17 13 13 16 13 14 21 1 4 5 13 11 0 8) #(0 112 123 152 174 203) #(NAME NEIGHBOURS COV-D-SELF VAR-D-INV OBS-D-ED NIL OBS-VARS VARIABLES VARIANCE EXPECTATION #(NIL) :AEX SEND :AVAR SET-DIFFERENCE :EX :VAR SYMBOL-VALUE :REMOVE-NEIGHBOUR LIST :ABSORB) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ABSORB) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (call-name call-vars obs-vars obs-d-ed var-d-inv cov-d-call)
Used internally to propagate information introduced by :OBSERVE." :PROPAGATE #K(#(80 8 10 0 1 2 3 4 5 6 7 8 9 10 63 17 4 0 63 16 5 0 63 15 6 0 62 14 18 23 10 18 2 3 18 62 14 19 23 11 19 2 19 18 23 12 20 2 18 19 38 13 21 23 14 21 3 1 21 20 63 13 21 0 38 15 21 23 14 21 3 1 21 20 63 12 21 0 63 14 20 0 51 4 20 1 4 23 16 20 2 20 4 51 3 21 1 3 23 16 21 2 21 18 23 17 20 3 7 20 21 38 15 21 23 14 21 3 1 21 18 23 18 21 1 21 38 19 22 23 14 22 4 1 22 18 19 23 20 21 3 20 21 22 23 21 18 2 20 21 63 11 18 0 62 10 18 23 22 19 1 2 23 11 18 2 18 19 16 18 19 21 1 1 2 18 23 23 20 1 19 38 24 21 62 8 22 62 14 23 62 17 24 62 16 25 62 15 26 62 11 27 23 14 0 8 20 21 22 23 24 25 26 27 17 18 18 16 18 19 21 1 1 2 18 11 0 9 80 3 0 0 25 25 0 2 2 1 80 3 0 0 25 25 0 2 2 1) #(0 176 225 228 238) #(NAME NIL NEIGHBOURS COV-D-SELF VARIANCE EXPECTATION VARIABLES VAR-D-INV OBS-D-ED OBS-VARS INTERSECTION SET-DIFFERENCE APPEND :EX SEND :VAR MAPCAR SELECT GINV :COV %* BIND-COLUMNS LIST SYMBOL-VALUE :PROPAGATE POSITION) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:PROPAGATE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (loc nil))
Sets or returns node location (for plotting purposes). Location
is a list of 2 floats on a (0,1) scale." :LOCATION #K(#(77 1 2 1 1 1 0 0 21 0 1 2 2 63 3 2 0 57 0 62 3 0 57 0) #(0 13 19) #(LOCATION #(NIL)) 0 NIL) TREE-NODE-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:LOCATION) 0 NIL)) EVAL) 0 NIL)
