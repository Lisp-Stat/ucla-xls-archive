(def ind_x (make-array (list 6 3) :initial-contents
           (list '(1 2 3) '(2 3 4) '(1 2 3) '(1 1 1) '(1 0 1) '(2 2 5))))
(def grp_x (make-array '(2 2) :initial-contents
           (list '(1 3) '(3 2))))
(def depen (coerce '(1 2 3 4 5 6) 'vector))
(def grops (coerce (list 1 1 1 2 2 2) 'vector))

(defun multi-level (x y z g)
(let* (
      (n (length y))
      (p (second (array-dimensions x)))
      (q (second (array-dimensions z)))
      (pq (* p q))
      (ng (first (array-dimensions z)))
      (yy (make-array (list n ng) :initial-element 1))
      (nn (make-array (list n ng) :initial-element 0))
      (hh (outer-product g (+ 1 (iseq ng)) #'=))
      (gg (if-else hh yy nn))
      (uu (make-array (list n pq) :initial-element 0))
      (cc (make-array (list ng pq pq) :initial-element 0))
      (bb (make-array (list ng pq) :initial-element 0))      
      (sg (coerce (repeat 0 ng) 'vector))
      (lb (coerce (repeat 0 pq) 'vector))
      (om (make-array (list p p) :initial-element 0))
      )
(dotimes (i p)
(dotimes (j q)
(setf (select uu (iseq n) (+ i (* j p)))
      (* (select x (iseq n) i) (matmult gg (select z (iseq ng) j))))
))
(dotimes (i ng)
(let* (
      (jj (which (= (+ i 1) g)))
      (yj (select y jj))
      (uj (select uu jj (iseq pq)))
      )
(setf (select cc i (iseq pq) (iseq pq))
      (make-array (list 1 pq pq)
      :displaced-to (coerce (matmult (transpose uj) uj) 'vector)))
(setf (select bb i (iseq pq))
      (make-array (list 1 pq) :displaced-to (matmult (transpose uj) yj)))
))
cc
))

(multi-level ind_x depen grp_x grops)