(defun regression-tree-int(x y)
   (let* (
; nobs        -  total # of observations
; dim         -  total # of variables
; node        -  the list of all node object to store all information
; nc          -  node count
; loop-case   -  the list of cases label of observations at this node
; loop-y-list -  the list of index for cases at this node (loop)
; loop-x-list -  a list of lists of indep. variables for cases at this node
; loop-error-before -  error before splitting
; loop-error-after  -  error after splitting
; loop-child-case -  list of cases to be assigned to each child
; loop-no-child   -  # of children at this node
; test-flag       -  T : end loop, NIL : continue loop
; node-count      - a list for all node labels being used
; l-node-count    - length of node-count

       (nobs (length y))
       (case (list (iseq nobs)))
       (node (repeat (list nil) 50))
       reg
       (loop-r2-list nil)
       (loop-sh-list nil)
       phd-var
;       tau  
       f-test
       (node-count (list 0))
       (l-node-count 0)
       (do-list (list (list 0 0)))
       test-flag
       c
       (menu-title data-file)
       class-out-info
       tree-node
       node-out
       )

;  (def tau(nth 0 (get-value-dialog "choose your tau value"
;                                   :initial '.2)))
  (do* 
   ((count 0 (setq count (+ 1 count))))
   ((eql T test-flag))
   (setf child-label nil)
   (setf child-label1 nil)
   (setf loop-terminal nil)
   (setf no-terminal 0)
   (setf parent-list nil)
;   (setf loop-next-cases nil)
   (setf loop-child-case nil)
   (setf loop-child-case1 nil)
   (setf cc 0)
   (setf dd 0)
   (setf lp nil)

 (dolist (l-p do-list)
 (print l-p)
   (setf nc (car l-p))
   (setf loop-case nil)
   (setf loop-x-list nil)
   (setf loop-y-list nil)
   (setf loop-ancestor-nodes nil)
   (setf var-set nil)
   (setf var-sh nil)
   (setf loop-phd-out nil)
   (setf loop-r-squares nil)
   (setf loop-sig-hat nil)
   (setf loop-error-after nil)
   (setf loop-f-test nil)
   (setf loop-f-v nil)
   (setf loop-error-ratio nil)
;   (setf loop-neighbor nil)
;   (setf nbr-case nil)
   (setf loop-no-child nil)
 (print (list 'case-length (length (nth nc case))))
   (setf (nth nc node) (phd-class-model (nth 1 l-p) (nth nc case)))

         (setf loop-case (send (nth nc node) :case))
         (setf loop-x-list (subset x loop-case))
         (setf loop-y-list (select y loop-case))
         (send (nth nc node) :node-label nc)

   (when (= nc 0)
         (send (nth nc node) :ancestor nil)
         (send (nth nc node) :level 0)
         (setf reg(reg-model loop-x-list loop-y-list :print nil))
         (setf temp-r2 (send reg :r-squared))
         (setf temp-sh (send reg :sigma-hat))
         (send (nth nc node) :r2 temp-r2)
         (send (nth nc node) :error-before temp-sh) 
         (setf loop-r2-list (list temp-r2))
         (setf loop-sh-list (list temp-sh))
         )
   (unless (= nc 0)
           (setf loop-ancestor-nodes (append (list 
                      (send (nth nc node) :parent))
                      (send (nth (send (nth nc node) :parent) node) 
                                          :ancestor)))
           (send (nth nc node) :ancestor loop-ancestor-nodes)
           (send (nth nc node) :level (length loop-ancestor-nodes))
           (send (nth nc node) :r2 (nth nc loop-r2-list))
           (send (nth nc node) :error-before (nth nc loop-sh-list))
           )

;   (when (or (< (length loop-case) (* (+ (length x) 1) 2)) 
   (when (or (< (length loop-case) 40)
             (>= (send (nth nc node) :r2) .90))
             (send (nth nc node) :terminal T))

   (when (send (nth nc node) :terminal)
           (format t "~%========================================~%")
           (format t "  pHd Information for node #~s      ~%" nc)
           (format t "========================================~2%")
           (format t "Number of observations : ~s ~2%" (length loop-case))
           (format t "R-squared    : ~s ~2%" (send (nth nc node) :r2))
           (format t "Error-before : ~s~2%" (send (nth nc node) :error-before))
           (format t "========================================~%")
           )

   (unless (send (nth nc node) :terminal)
           (setf phd-var(proj-var loop-x-list loop-y-list))
           (setf var-set(nth 1 phd-var))
           (setf var-sh (nth 2 phd-var))
   (format t "~%===========================================================~%")
   (format t "Information about pHd at # ~s ~2%" nc)
   (format t "set & important variables & weighted splitted sigma-hat_s':~2%")
   (dotimes (i (length var-sh))
               (format t " ~s~2%" (list i (nth i var-set) (nth i var-sh))))
   (format t "===========================================================~%")
   (setf val(nth 0 (get-value-dialog "Which variables set to be selected?")))


          (setf loop-phd-out (phdrt-model (select loop-x-list (nth val var-set))
                                           loop-x-list loop-y-list :print nil))

          (setf loop-error-after (send loop-phd-out :t-sighat2))
          (send (nth nc node) :error-after loop-error-after)
          (send (nth nc node) :res (send loop-phd-out :resid))
          (send (nth nc node) :p1x (send loop-phd-out :phd1))
          (send (nth nc node) :p2x (send loop-phd-out :phd2))
          (send (nth nc node) :phd-proj-var (nth val var-set))
          (send (nth nc node) :phd-evct (car (send loop-phd-out :directions)))
          (send (nth nc node) :phd-eval (send loop-phd-out :eigen-values))
          (send (nth nc node) :p-vals (send loop-phd-out :p-val))
          (send (nth nc node) :r2-list (send loop-phd-out :r-squares))
          (send (nth nc node) :sh-list (send loop-phd-out :sig-hat))
          (send (nth nc node) :case-list (send loop-phd-out :node-size))

        (setf loop-r2-list(append loop-r2-list (send loop-phd-out :r-squares)))
        (setf loop-sh-list(append loop-sh-list (send loop-phd-out :sig-hat)))

                 (def plot (spin-plot (list (send loop-phd-out :phd1)
                                            (send loop-phd-out :resid)
                                            (send loop-phd-out :phd2))
                            :variable-labels (list "phd1" "residuals" "phd2")
                            :title "phd1-res-phd2 view "
                            :location '(600 36) :size '(280 220)))
                      (send plot :linked t)
                      (send plot :use-color t)
                      (send plot :mouse-mode 'hand-rotate)
                      (send plot :axis-rotate)

           (setf loop-f-test (send loop-phd-out :f-test))
           (send (nth nc node) :f-test-val loop-f-test)
           (setf loop-f-v (f-quant .999 (nth 1 loop-f-test)(nth 2 loop-f-test)))
           (send (nth nc node) :f-v loop-f-v)
           (setf loop-error-ratio (/ (- (send (nth nc node) :error-before)
                                        (send (nth nc node) :error-after))
                                     (send (nth nc node) :error-before)))
           (send (nth nc node) :error-ratio loop-error-ratio)


;        (setf error-reduced-rate (/ (- (send (nth nc node) :error-before)
;                                       (send (nth nc node) :error-after))
;                                    (send (nth nc node) :error-before)))
;     (when (= nc 0)
;     (setf loop-neighbor(neighbor (car (car (send loop-phd-out :directions)))
;                        (send loop-phd-out :phd1) tau))
;     (send (nth nc node) :case-neighbor loop-neighbor)
;           )
;     (unless (= nc 0)
;     (setf loop-neighbor(neighbor1 x (car (send loop-phd-out :directions)) tau
;                         loop-case (send (nth nc node) :phd-proj-var)))
;     (setf nbr-case(neighbor2 x loop-case (send (nth nc node) :phd-proj-var)
;                (car (send loop-phd-out :directions)) loop-neighbor
;                (send (nth (send (nth nc node) :parent) node) :case-neighbor)
;                ))
;     (send (nth nc node) :case-neighbor nbr-case)
;     )
;     (setf loop-next-cases(list (car (car loop-neighbor)) 
;                                (car (nth 1 loop-neighbor))))
   )
;;==============================================================================
   (unless (send (nth nc node) :terminal)
           (format t "~%===============================================~%")
           (format t "pHd Information for this intermediate node  #~s  ~%" nc)
           (format t "===============================================~2%")
           (format t "Number of observations : ~s ~2%" (length loop-case))
           (format t "Important variables : ~s ~2%" (nth val var-set))
           (format t "P-values for pHd :~2%")
           (format t "~s~2%" (send loop-phd-out :p-val))
           (format t "Eigenvalues for pHd :~2%")
           (format t "~s~2%" (send loop-phd-out :eigen-values))
           (format t "R-squared    : ~s ~2%" (send (nth nc node) :r2))
           (format t "Error-before : ~s~2%" (send (nth nc node) :error-before))
           (format t "Error-after  : ~s~2%" (send (nth nc node) :error-after))
           (format t "Error-reduced-rate : ~s~2%" loop-error-ratio)
           (format t "the value of F statistics :~s ~2%" loop-f-test)
           (format t "the value of F-test :~s ~2%" loop-f-v)
           (format t "===============================================~%")
           (break)
;           (load "sirct-ida-inter")

           (setf dialog-out (choose-item-dialog
                    "Would you like the node to be :"
                    '("Split" "No split")
                    ))
          )
;;==============================================================================

   (if (= dialog-out 0) (send (nth nc node) :terminal nil)
                        (send (nth nc node) :terminal T))

   (unless (send (nth nc node) :terminal)
           (setf loop-child-case (send loop-phd-out :case-2))
           (send (nth nc node) :child-case loop-child-case)
           (setf loop-child-case1(append loop-child-case1 loop-child-case))

           (setf loop-no-child (length loop-child-case))
           (when (= nc 0)
                 (send (nth nc node) :children (iseq 1 loop-no-child))
                 )
           (when (/= nc 0)
                 (send (nth nc node) :children
                       (iseq l-node-count (+ l-node-count loop-no-child -1)))
                 ) 
           (setf node-count (append node-count (send (nth nc node) :children)))
;           (print (list 'node-count node-count))
           (setf l-node-count (length node-count))
           (setf child-label1 (send (nth nc node) :children)) 
           (setf parent-list (append parent-list
                                     (repeat nc (length child-label1))))
           (setf child-label(append child-label child-label1))
          )
      (setf loop-terminal(append loop-terminal 
                                 (list (send (nth nc node) :terminal))))
  ) 
;(print (list 'count count))
;(print '=====)
;(print (list 'loop-terminal loop-terminal))

      (setf case(append case loop-child-case1))
      (when (= nc 0)
            (when (eql T (send (nth nc node) :terminal))
                  (setf test-flag T))
            (unless (eql T (send (nth nc node) :terminal))
                    (setf lp (repeat 0 (length child-label)))
                    (dotimes (i (length lp))
                        (setf c(list (nth i child-label)(nth i parent-list)))
                        (setf (nth i lp) c)
                        ) 
            )
      )
      (unless (= nc 0)
          (setf dd(set-difference node-count child-label))
          (dolist (i dd)
                   (when (= (send (nth i node) :level) count)
                         (setf cc(+ cc 1))
                         (when (eql T (send (nth i node) :terminal))
                               (setf no-terminal (+ no-terminal 1))
                         )
                   )
           )
          (when (= no-terminal cc) (setf test-flag T))
          (unless (= no-terminal cc)
                  (setf lp (repeat 0 (length child-label)))
                  (dotimes (i (length lp))
                       (setf c(list (nth i child-label) (nth i parent-list)))
                       (setf (nth i lp) c)
                       )
           )
      )
(print (list 'label-parent lp))
(print '*****)
       (setf do-list lp)
 )
       (def node(remove nil node))
       (setf class-out-info(class-output node))
       (setf tree-node(tree node))
;              (setf smooth-node(smooth x node))
;              (def node-out(information-model x y node (nth 0 class-out-info) 
;                                (nth 1 class-out-info) (nth 2 class-out-info) 
;                                 t menu-title))
       (def  node-out (information-model x y node (nth 0 class-out-info)
                                        (nth 1 class-out-info) t menu-title))
       (send node-out :menu)
  node-out))
