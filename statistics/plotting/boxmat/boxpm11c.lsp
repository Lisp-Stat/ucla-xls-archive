
(defmeth boxmat-proto :add-boxplot
	   (y
	    &key (fiv '(0 1 2 3 4) fiv-set)
		 (mean-y (if (not y) (select fiv 2) (mean y)))
		 (x 1.0) (width 1.0) (draw nil)
		 (outliers t)
	   )
  (labels ((xor (a b) (or (and a (not b)) (and (not a) b))))
	  (unless (xor (not(not y)) fiv-set)
		  (error "Exactly one of Y or FIV must be set."))
  )
  (unless (= 2 (send self :num-variables)) (error "only works for 2D plots"))
  (if (not(not y)) (setf fiv (fivenum y)))
  (let* ((half-box (* 0.4 width))
	 (half-foot (* 0.1 width))
	 (low (select fiv 0))
	 (q1 (select fiv 1))
	 (med (select fiv 2))
	 (q3 (select fiv 3))
	 (high (select fiv 4))
	 (num-points (send self :num-points))
	 (num-lines  (send self :num-lines))
	 (cut-range  (slot-value 'cut-range))
	 (fourth-spread (- q3 q1))
	 (low-cut  (- q1 (* cut-range 1.5 fourth-spread)))
	 (high-cut (+ q3 (* cut-range 1.5 fourth-spread)))
	)
    (cond ((= cut-range 0) (setf low-cut low) (setf high-cut high)))
    (send self :add-points (list x) (list mean-y) :draw nil)
    (send self :point-color num-points (slot-value 'mean-color))
    (setf (slot-value 'box-line-start)
		      (concatenate 'list (slot-value 'box-line-start)
					 (list num-lines )))
    (setf (slot-value 'box-point-start)
		      (concatenate 'list (slot-value 'box-point-start)
					 (list num-points)))
    (when outliers (let* ((high-out (select y (which (> y high-cut))))
			  (low-out  (select y (which (< y low-cut))))
			  (y-out (remove nil (combine high-out low-out)))
			  (tmp y)
			  (y-rest (dolist (i y-out tmp)
					  (setf tmp (remove i tmp))))
			  (num-out (length y-out))
			  (pts-out (if (> num-out 0)
				       (+ 1 num-points (iseq num-out))
				       '(nil)
				   )
			  )
			 )
			 (when (> num-out 0)
			       (send self :add-points (repeat x num-out) y-out)
			       (send self :point-symbol pts-out 'dot4)
			       (if (> (length high-out) 0)
				   (setf high
					 (min (remove nil
					      (combine high-cut (max y-rest))))
			       ))
			       (if (> (length low-out)	0)
				   (setf low
					 (max (remove nil
					      (combine low-cut (min y-rest))))
			       ))
			 )
			 (setf (slot-value 'box-out-start)
			       (append (slot-value 'box-out-start)
				       (list pts-out))
			 )
		   )
    )
;   (slot-value 'lines-per-box 9)
    (send self :plotline (- x half-foot) low  (+ x half-foot) low  nil)
    (send self :plotline (- x half-foot) high (+ x half-foot) high nil)
    (send self :plotline x low x q1   nil)
    (send self :plotline x q3  x high nil)
    (send self :plotline (- x half-box) q1  (+ x half-box) q1  nil)
    (send self :plotline (- x half-box) med (+ x half-box) med nil)
    (send self :plotline (- x half-box) q3  (+ x half-box) q3  nil)
    (send self :plotline (- x half-box) q1  (- x half-box) q3  nil)
    (send self :plotline (+ x half-box) q1  (+ x half-box) q3  nil)
  )
)






(defun position-v (element sequence)
    (let* ((elements (combine element))
	   (result elements)
	  )
	  (dotimes (i (length elements))
		   (setf (select result i)
			 (position (select elements i) sequence)
		   )
	  )
	  (if (compound-data-p element)
	      result
	      (first result)
	  )
    )
)


(defun fivenum (x)
 (let* ((x (sort-data x))
	(batch-size (length x))
     (rank-median (/ (1- batch-size) 2))
     (rank-hinge (/ (1- (floor rank-median)) 2))
     (median (mean (select x
	       (list (floor rank-median) (ceiling rank-median)))))
     (low (min x))
     (high (max x))
     (rank-q1 (/ (1+ (floor rank-hinge)) 2))
     (q1 (mean (select x
	       (list (floor rank-q1) (ceiling rank-q1)))))
     (q3 (mean (select (reverse x)
	       (list (floor rank-q1) (ceiling rank-q1)))))
       )
       (list low q1 median q3 high)
 )
)


(defmeth boxmat-proto :point-color (points &optional (color nil color-set))
    (let* ((points-v (combine points))
	   (box-line-start  (combine (slot-value 'box-line-start)))
	   (box-point-start (combine (slot-value 'box-point-start)))
	   (box-out-start (slot-value 'box-out-start))
	   (lines-per-box (slot-value 'lines-per-box))
	   (num-boxes (length box-point-start))
	   (points-in-boxes (which (position-v points-v box-point-start)))
	   (boxes-in-points (which (position-v box-point-start points-v)))
	   (outlier-selected (select box-out-start boxes-in-points))
	   (points-not-in-boxes (remove outlier-selected
	    (which (map-elements #'not (position-v points-v box-point-start)))))
	   (boxes-not-in-points
	     (which (map-elements #'not (position-v box-point-start points-v))))
	   (other-points (select points-v points-not-in-boxes))
	   (linestart-selected (select box-line-start boxes-in-points))
	   (line-selected (outer-product linestart-selected
					 (iseq (* 2 lines-per-box)) #'+))
	   (color-result (iseq (length points-v)))
	  )
	  (cond (color-set

		 (cond((> (length boxes-in-points) 0)
		       (send self :linestart-color line-selected color)
		       (if (> (length (apply #'remove nil outlier-selected)) 0)
			  (call-next-method outlier-selected color)
		       )
		       (call-next-method (select box-point-start
						 boxes-in-points)
					 (slot-value 'mean-color))
		      )
		  )

		 (if (> (length points-not-in-boxes) 0)
		     (call-next-method other-points color)
		 )
		)
	  )
	  (if (> (length boxes-in-points) 0)
	      (setf (select color-result points-in-boxes)
		    (send self :linestart-color linestart-selected))
	  )
	  (if (> (length other-points) 0)
	      (setf (select color-result points-not-in-boxes)
		    (call-next-method other-points))
	  )
	  (if (compound-data-p points)
	      color-result
	      (first color-result)
	  )
    )
)

