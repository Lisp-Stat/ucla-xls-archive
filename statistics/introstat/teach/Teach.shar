#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 12/20/1994 23:11 UTC by sts@iastate.edu
# Source directory /nfs/nfs-1/u0/sts/test/Teach
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#  18555 -rwxr--r-x Teach/CI/ci.sim
#  34096 -rwxr--r-x Teach/CLT/clt8.lsp
#  15531 -rwxr--r-x Teach/LS/lsestm.lsp
#    733 -rwxr--r-x Teach/LS/ls-dataf.lsp
#  22768 -rwxr--r-x Teach/OVL/overlay1.lsp
#  28765 -rwxr--r-x Teach/OVL/overlay2.lsp
#  23634 -rwxr--r-x Teach/OVL/overlay3.lsp
#    301 -rwxr--r-x Teach/OVL/make-col.lsp
#    984 -rwxr--r-x Teach/OVL/colors.lsp
#  29859 -rwxr--r-x Teach/OVL/fun1.lsp
#  30551 -rwxr--r-x Teach/OVL/reg1.lsp
#  10725 -rwxr--r-x Teach/OVL/rgraph1.lsp
#   4840 -rwxr--r-x Teach/OVL/boxplot.lsp
#   2325 -rwxr--r-x Teach/PP/pp-dataf.lsp
#  30343 -rwxr--r-x Teach/PP/pp6.lsp
#  30922 -rwxr--r-x Teach/PP/pp6.lsp~
#   1180 -rw-rw---- Teach/README
#  32707 -rwxr--r-x Teach/SD/sd3.lsp
#  33853 -rwxr--r-x Teach/TR/tr4.lsp
#   2325 -rwxr--r-x Teach/TR/tr-dataf.lsp
#     29 -rwxrw-r-x Teach/Teach_CI
#     30 -rwxrw-r-x Teach/Teach_CLT
#     29 -rwxrw-r-x Teach/Teach_LS
#     29 -rwxrw-r-x Teach/Teach_PP
#     29 -rwxrw-r-x Teach/Teach_SD
#     29 -rwxrw-r-x Teach/Teach_TR
#    486 -rwxr--r-x Teach/ci.lsp
#    645 -rwxr--r-x Teach/clt.lsp
#    604 -rwxr--r-x Teach/ls.lsp
#    730 -rwxr--r-x Teach/pp.lsp
#    580 -rwxr--r-x Teach/sd.lsp
#    757 -rwxr--r-x Teach/tr.lsp
#    594 -rw-rw---- Teach/install.xlispstat
#
# ============= Teach/CI/ci.sim ==============
if test ! -d 'Teach'; then
    echo 'x - creating directory Teach'
    mkdir 'Teach'
fi
if test ! -d 'Teach/CI'; then
    echo 'x - creating directory Teach/CI'
    mkdir 'Teach/CI'
fi
if test -f 'Teach/CI/ci.sim' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/CI/ci.sim (File already exists)'
else
echo 'x - extracting Teach/CI/ci.sim (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/CI/ci.sim' &&
;;;;;;;     CI module written by Tae-Sung Shin            
X
(defproto ci-plot-proto '(blk data1) () scatterplot-proto)
X
;;;;;;;     methods for slots of ci-plot-proto
X 
(defmeth ci-plot-proto :data1 (&optional (data1 nil set))
X  (if set (setf (slot-value 'data1) data1))
X  (slot-value 'data1))
X
(defmeth ci-plot-proto :blk (&optional (blk nil set))
X  (if set (setf (slot-value 'blk) blk))
X  (slot-value 'blk))
X
;;;;;;;     methods for changes of values of data
X
(defmeth ci-plot-proto :tval-chg (blk)
"Set the 'data1 slot with new t-value of blk th block"
X
X  (let* ((data1 (send self :data1))
X	 (data (select data1 (- blk 1)))
X	 (n (select data 0))
X	 (alpha (select data 1))
X	 (tval (t-quant (- 1 (/ alpha 2)) (- n 1))))
X    (setf (select (select data1 (- blk 1)) 5) tval)
X    (send self :data1 data1)))
X
X
(defmeth ci-plot-proto :ntop-chg (nsam)
"Changes number of sample of top part of the plot and 
draw the plot corresponding to the number of sample"
X  (let* ((data1 (send self :data1))
X	 (co (send self :real-to-canvas 0 30))
X	 (x-co (first co))
X	 (y-co (second co)))
X    (setf (select (select data1 0) 0) nsam)
X    (setf (select (select data1 0) 3) (list 0 0))
X    (setf (select (select data1 1) 0) nsam)
X    (setf (select (select data1 1) 3) (list 0 0))
X    (setf (select (select data1 2) 3) (list 0 0))
X    (setf (select (select data1 3) 3) (list 0 0))
X    (send self :data1 data1)
X    (send self :tval-chg 1)
X    (send self :tval-chg 2)
X    (send self :erase-rect x-co (- y-co 10) 50 16)
X    (send self :draw-color 'blue)
X    (send self :draw-text 
X	  (num-to-string nsam) x-co y-co 0 0)
X    (send self :draw-color 'black)
X    (send self :draw-four)))
X
(defmeth ci-plot-proto :nbot-chg (nsam)
"Changes number of sample of bottom part of the plot and 
draw the plot corresponding to the number of sample"
X  (let* ((data1 (send self :data1))
X	 (co (send self :real-to-canvas 0 10))
X	 (x-co (first co))
X	 (y-co (second co)))
X    (setf (select (select data1 2) 0) nsam)
X    (setf (select (select data1 2) 3) (list 0 0))
X    (setf (select (select data1 3) 0) nsam)
X    (setf (select (select data1 3) 3) (list 0 0))
X    (setf (select (select data1 1) 3) (list 0 0))
X    (setf (select (select data1 0) 3) (list 0 0))
X    (send self :data1 data1)
X    (send self :tval-chg 3)
X    (send self :tval-chg 4)
X    (send self :erase-rect x-co (- y-co 10) 50 16)
X    (send self :draw-color 'blue)
X    (send self :draw-text 
X	  (num-to-string nsam) x-co y-co 0 0)
X    (send self :draw-color 'black)
X    (send self :draw-four)))
X
(defmeth ci-plot-proto :cll-chg (cl)
"Changes confidence level of left part of the plot and 
draw the plot corresponding to the confidence level"
X  (let* ((data1 (send self :data1))
X	 (co (send self :real-to-canvas 15 40))
X	 (x-co (first co))
X	 (y-co (- (second co) 10)))
X    (setf (select (select data1 0) 1) (- 1 cl))
X    (setf (select (select data1 0) 3) (list 0 0))
X    (setf (select (select data1 2) 1) (- 1 cl))
X    (setf (select (select data1 2) 3) (list 0 0))
X    (setf (select (select data1 1) 3) (list 0 0))
X    (setf (select (select data1 3) 3) (list 0 0))
X    (send self :data1 data1)
X    (send self :tval-chg 1)
X    (send self :tval-chg 3)
X    (send self :erase-rect x-co (- y-co 10) 60 16)
X    (send self :draw-color 'blue)
X    (send self :draw-text 
X	  (num-to-string cl) (+ x-co 10) y-co 0 0)
X    (send self :draw-color 'black)
X    (send self :draw-four)))
X
(defmeth ci-plot-proto :clr-chg (cl)
"Changes confidence level of left part of the plot and 
draw the plot corresponding to the confidence level"
X  (let* ((data1 (send self :data1))
X	 (co (send self :real-to-canvas 45 40))
X	 (x-co (first co))
X	 (y-co (- (second co) 10)))
X    (setf (select (select data1 1) 1) (- 1 cl))
X    (setf (select (select data1 1) 3) (list 0 0))
X    (setf (select (select data1 3) 1) (- 1 cl))
X    (setf (select (select data1 3) 3) (list 0 0))
X    (setf (select (select data1 0) 3) (list 0 0))
X    (setf (select (select data1 2) 3) (list 0 0))
X    (send self :data1 data1)
X    (send self :tval-chg 2)
X    (send self :tval-chg 4)
X    (send self :erase-rect x-co (- y-co 10) 60 16)
X    (send self :draw-color 'blue)    
X    (send self :draw-text 
X	  (num-to-string cl) (+ x-co 10) y-co 0 0)
X    (send self :draw-color 'black)
X    (send self :draw-four)))
X
(defmeth ci-plot-proto :close ()
X  (exit)
)
X
(defmeth ci-plot-proto :put-text (str x-co y-co)
"draw a string on  (x-co, y-co) in central mode"
X  (let ((re-co (send self :real-to-canvas x-co y-co)))
X    (send self :draw-text str (first re-co) (second re-co) 1 1)))
X
X
(defun sim ()
"generate Confidence Interval Simulation Plot"
X  (let* ((plot (send ci-plot-proto :new 2 :show nil))
X	 (data1 (list 
X		 (list 10 0.05 5 (list 0 0) (list 0 0) (t-quant 0.975 9))
X		 (list 10 0.01 5 (list 0 0) (list 0 0) (t-quant 0.995 9))
X		 (list 40 0.05 5 (list 0 0) (list 0 0) (t-quant 0.975 39))
X		 (list 40 0.01 5 (list 0 0) (list 0 0) (t-quant 0.995 39)))))
X    (send plot :blk 1)
X    (send plot :data1 data1)
X    (send plot :menu nil)
X    (send plot :range 1 0 40)
X    (send plot :range 0 0 60)
X    (send plot :margin 50 20 10 20)
X    (mapcar #'(lambda (a b) 
X		(send plot :put-text "100" a b)) 
X	    '(15 15 45 45) '(1.7 21.7 1.7 21.7))
X    (mapcar #'(lambda (a b) 
X		(send plot :put-text "90" a b)) 
X	    '(5 5 35 35) '(1.7 21.7 1.7 21.7))
X    (mapcar #'(lambda (a b) 
X		(send plot :put-text "110" a b)) 
X	    '(25 25 55 55) '(1.7 21.7 1.7 21.7))
X
;;  set axis and tips
X 
X    (send plot :add-lines '(15 15) '(1.8 2.2))
X    (send plot :add-lines '(15 15) '(21.8 22.2))
X    (send plot :add-lines '(45 45) '(1.8 2.2))
X    (send plot :add-lines '(45 45) '(21.8 22.2))
X    (send plot :add-lines '(5 5) '(1.8 2.2))
X    (send plot :add-lines '(5 5) '(21.8 22.2))
X    (send plot :add-lines '(35 35) '(1.8 2.2))
X    (send plot :add-lines '(35 35) '(21.8 22.2))
X    (send plot :add-lines '(25 25) '(1.8 2.2))
X    (send plot :add-lines '(25 25) '(21.8 22.2))
X    (send plot :add-lines '(55 55) '(1.8 2.2))
X    (send plot :add-lines '(55 55) '(21.8 22.2))
X    (send plot :add-lines (list 15 15) (list 2 10))                  
X    (send plot :add-lines (list 15 15) (list 22 30))
X    (send plot :add-lines (list 45 45) (list 2 10))
X    (send plot :add-lines (list 45 45) (list 22 30))
X    (send plot :add-lines (list 5 25) (list 2 2))
X    (send plot :add-lines (list 5 25) (list 22 22))
X    (send plot :add-lines (list 35 55) (list 2 2))
X    (send plot :add-lines (list 35 55) (list 22 22))
X
;;  write info of window
X
X    (send plot :draw-text "Sampling from    " 10 250 0 0)
X    (send plot :draw-text "Normal Distribution" 10 270 0 0)
X    (send plot :draw-text "mean = 100" 10 290 0 0)
X    (send plot :draw-text "S.D. = 5" 10 310 0 0)
X    (send plot :draw-text "C.I. computed" 10 350 0 0)
X    (send plot :draw-text "assuming S.D is" 10 370 0 0)
X    (send plot :draw-text "unknown" 10 390 0 0)
X    (send plot :use-color t)
X    (send plot :draw-four)
X    (send plot :title "Confidence Interval Simulation")
X    (send plot :ci-plot-controls)
X    (send plot :show-window)
X    #+(or macintosh msdos) (send plot :location 10 28)
X    #+(or macintosh msdos) (send plot :size 619 409)
X    plot))
X
#+msdos (defmeth graph-proto :overlay-click (x y m1 m2)
X		(if (not (dolist (ov (slot-value 'overlays))
X			(if (send ov :do-click x y m1 m2) (return t))))
X				(send self :redraw))
X				t)
X
;;;;; methods for drawing the plot
X
(defmeth ci-plot-proto :draw-four ()
"draw four blocks of CI plot with current parameter values"
X  (let ((blk (send self :blk)))
X    (send self :blk 1)
X    (send self :draw-ci)
X    (send self :blk 2)
X    (send self :draw-ci)
X    (send self :blk 3)
X    (send self :draw-ci)
X    (send self :blk 4)
X    (send self :draw-ci)
X    (send self :blk blk)))
X  
(defmeth ci-plot-proto :draw-ci ()
"draw one block of CI plot given values"
X  (let* ((data1 (send self :data1))
X	 (blk (send self :blk))
X	 (data (select data1 (- blk 1)))
X	 (n (select data 0))
X	 (alpha (select data 1))
X	 (sigma (select data 2))
X	 (cnt (select (select data 3) 1))
X	 (cvg (select (select data 3) 0))
X	 (u (select (select data 4) 1))
X	 (l (select (select data 4) 0))
X	 (x (normal-rand n))
X	 (x1 (+ 100 (* x sigma)))
X	 (xbar (mean x1))
X	 (xdev (standard-deviation x1))
X	 (tval (select data 5))
X	 (half-width  (* (/ xdev (sqrt n)) tval))
X	 (lci1 (- xbar half-width))
X	 (lci (if (< lci1 85) 89 lci1))
X	 (uci1 (+ xbar half-width))
X	 (uci (if (> uci1 115) 111 uci1))
X	 (cvg1 (if (and (< lci 100) (> uci 100)) (+ cvg 1) cvg)))
X    (if (= cvg1 cvg) (send self :draw-color 'red) 
X      (send self :draw-color 'blue))
X    (setf (select (select data1 (- blk 1)) 3) (list cvg1 (+ cnt 1)))
X    (setf (select (select data1 (- blk 1)) 4) (list lci uci))
X    (send self :data1 data1)
X    (send self :put-ci (list l u) blk 0)
X    (send self :put-ci (list lci uci) blk 1 (+ 1 cnt) cvg1)))
X
(defmeth ci-plot-proto :put-ci (ci blk sgn &optional cnt cvg)
"Given CI, block, draw the CI if sgn=1. Otherwise delete previous CI"
X  (let* ((x-co (if (or (= blk 1) (= blk 3)) -85 -55))
X	 (y-co (if (or (= blk 1) (= blk 2)) 20 0))
X	 (lci (+ x-co (select ci 0)))
X	 (uci (+ x-co (select ci 1)))
X	 (xco (first (send self :real-to-canvas 
X			   (/ (+ uci lci) 2) y-co)))
X	 (u (+ y-co 6.75))
X	 (l (+ y-co 5.50))
X	 (s1 (send self :real-to-canvas lci u))
X	 (s2 (send self :real-to-canvas uci l))
X	 (xl (- (first s2) (first s1)))
X	 (yl (- (second s2) (second s1)))
X	 (col (send self :draw-color)))
X    (cond ((= sgn 1)
X	   (send self :draw-color 'black)
X	   (send self :add-lines 
X		 (repeat (+ 100 x-co) 2) (list (+ 2 y-co) (+ 10 y-co)))
X	   (send self :draw-color col)
X	   (send self :paint-rect (first s1) (second s1) xl yl )
X	   (send self :draw-color 'magenta)
X	   (let* ((co (send self :real-to-canvas (+ 85 x-co) (+ y-co 19)))
X		  (x1-co (+ 10(first co)))
X		  (y1-co (second co)))
X	     (send self :erase-rect (+ x1-co 122) (- y1-co 10) 50 60)
X	     (send self :draw-text 
X		   (num-to-string cnt) (+ x1-co 122) y1-co 0 0)
X	     (send self :draw-text 
X		   (num-to-string cvg) (+ x1-co 122) (+ y1-co 20) 0 0)
X	     (send self :erase-rect x1-co (+ y1-co 50) 100 20)
X	     (send self :draw-text 
X		   (format nil "~,3f" (if (= cnt 0) 0 (/ cvg cnt)))  
X		   (+ x1-co 122) (+ y1-co 40) 0 0)
X	     (send self :draw-color 'black)
X	     (send self :draw-line xco (second s1) xco (- (second s2) 1))
X	     (send self :draw-color 'black)))
X	  ((= sgn 0)
X	   (send self :erase-rect (first s1) (second s1) xl yl)))))
X
(defmeth ci-plot-proto :redraw ()
"Redraw CI simulation plot"
X  (call-next-method)
X  (let* ((data1 (send self :data1))
X	 (n1 (select (select data1 0) 0))
X	 (n2 (select (select data1 2) 0))
X	 (a1 (select (select data1 0) 1))
X	 (a2 (select (select data1 1) 1))
X	 (co (send self :real-to-canvas 0 30))
X	 (x-co1 (first co))
X	 (y-co1 (second co))
X	 (co (send self :real-to-canvas 0 10))
X	 (x-co2 (first co))
X	 (y-co2 (second co))
X	 (co (send self :real-to-canvas 15 40))
X	 (x-co3 (first co))
X	 (y-co3 (- (second co) 10))
X	 (co (send self :real-to-canvas 45 40))
X	 (x-co4 (first co))
X	 (y-co4 (- (second co) 10)))
X    (send self :draw-color 'blue)
X    (send self :draw-text 
X	  "n = " x-co1 y-co1 2 0)
X    (send self :draw-text 
X	  (num-to-string n1) x-co1 y-co1 0 0)
X    (send self :draw-text 
X	  "n = " x-co2 y-co2 2 0)
X    (send self :draw-text 
X	  (num-to-string n2) x-co2 y-co2 0 0)
X    (send self :draw-text 
X	  "C.L.=" x-co3 y-co3  2 0)
X    (send self :draw-text 
X	  (num-to-string (- 1 a1)) (+ x-co3 10) y-co3 0 0)
X    (send self :draw-text 
X	  "C.L.=" x-co4 y-co4  2 0)
X    (send self :draw-text 
X	  (num-to-string (- 1 a2)) (+ x-co4 10) y-co4 0 0)
X    (send self :draw-color 'black)
X    (mapcar #'(lambda (a b) 
X		(send self :put-text "100" a b)) 
X	    '(15 15 45 45) '(1.7 21.7 1.7 21.7))
X    (mapcar #'(lambda (a b) 
X		(send self :put-text "90" a b)) 
X	    '(5 5 35 35) '(1.7 21.7 1.7 21.7))
X    (mapcar #'(lambda (a b) 
X		(send self :put-text "110" a b)) 
X	    '(25 25 55 55) '(1.7 21.7 1.7 21.7))
X    (send self :draw-text "Sampling from    " 10 250 0 0)
X    (send self :draw-text "Normal Distribution" 10 270 0 0)
X    (send self :draw-text "mean = 100" 10 290 0 0)
X    (send self :draw-text "S.D. = 5" 10 310 0 0)
X    (send self :draw-text "C.I. computed" 10 350 0 0)
X    (send self :draw-text "assuming S.D is" 10 370 0 0)
X    (send self :draw-text "unknown" 10 390 0 0)
X    (send self :blk 1)
X    (send self :redraw-draw-ci)
X    (send self :blk 2)
X    (send self :redraw-draw-ci)
X    (send self :blk 3)
X    (send self :redraw-draw-ci)
X    (send self :blk 4)
X    (send self :redraw-draw-ci)))
X
(defmeth ci-plot-proto :redraw-draw-ci ()
X  (let* ((data1 (send self :data1))
X	 (blk (send self :blk))
X	 (data (select data1 (- blk 1)))
X	 (cnt (select (select data 3) 1))
X	 (cvg (select (select data 3) 0))
X	 (u (select (select data 4) 1))
X	 (l (select (select data 4) 0))
X	 (cvg1 (if (and (< l 100) (> u 100)) (+ cvg 1) cvg)))
X    (if (= cvg1 cvg) (send self :draw-color 'red) 
X      (send self :draw-color 'blue))
X    (send self :redraw-put-ci (list l u) blk 1 cnt cvg)))
X
(defmeth ci-plot-proto :redraw-put-ci (ci blk sgn &optional cnt cvg)
X  (let* ((x-co (if (or (= blk 1) (= blk 3)) -85 -55))
X	 (y-co (if (or (= blk 1) (= blk 2)) 20 0))
X	 (lci (+ x-co (select ci 0)))
X	 (uci (+ x-co (select ci 1)))
X	 (xco (first (send self :real-to-canvas 
X			   (/ (+ lci uci) 2) y-co)))
X	 (u (+ y-co 6.75))
X	 (l (+ y-co 5.5))
X	 (s1 (send self :real-to-canvas lci u))
X	 (s2 (send self :real-to-canvas uci l))
X	 (xl (- (first s2) (first s1)))
X	 (yl (- (second s2) (second s1)))
X	 (col (send self :draw-color)))
X    (cond ((= sgn 1)
X	   (send self :draw-color 'black)
X	   (send self :add-lines 
X		 (repeat (+ 100 x-co) 2) (list (+ 2 y-co) (+ 10 y-co)))
X	   (send self :draw-color col)
X	   (send self :paint-rect (first s1) (second s1) xl yl)
X	   (send self :draw-color 'mobg)
X	   (let* ((co (send self :real-to-canvas (+ 85 x-co) (+ y-co 19)))
X		  (x1-co (+ 10 (first co)))
X		  (y1-co (second co)))
X	     (send self :draw-text "# samples" x1-co y1-co 0 0)
X	     (send self :draw-text "# covered" x1-co (+ y1-co 20) 0 0)
X	     (send self :draw-text "Coverage rate" x1-co (+ y1-co 40) 0 0)
X	     (send self :draw-color 'magenta)
X	     (send self :draw-text 
X		   (num-to-string cnt) (+ x1-co 122) y1-co 0 0)
X	     (send self :draw-text 
X		   (num-to-string cvg) (+ x1-co 122) (+ y1-co 20) 0 0)
;            (send self :erase-rect x1-co (+ y1-co 50) 100 20)
X	     (send self :draw-text 
X		   (format nil "~,3f" (if (= cnt 0) 0 (/ cvg cnt)))
X		   (+ x1-co 122) (+ y1-co 40) 0 0)
X	     (send self :draw-color 'black)
X	     (send self :draw-line xco (second s1) xco (- (second s2) 1))
X	     (send self :draw-color 'black)))
X	  ((= sgn 0)
X	   (send self :erase-rect (first s1) (second s1) xl yl)))))
X
X
;;;;; overlays for controling the plot
X
(defmeth ci-plot-proto :ci-plot-controls ()
"Install ci plot overlays"
X  (call-method graph-proto :plot-controls)
X  (let* ((c1 (send ci-plot-ntop-control-proto :new 
X		    (* 5 (iseq 1 20))
X		    :location (send self :locate-next-control :height 2)
X		    :title "n:Top" :length (send self :slider-width)
X		    :index 1 ))
X	 (c2 (send ci-plot-nbot-control-proto :new 
X		    (* 5 (iseq 1 20))
X		    :location (send self :locate-next-control :height 2)
X		    :title "n:Bottom" :length (send self :slider-width)
X		    :index 7 ))
X	 (c3  (send ci-plot-cll-control-proto :new 
X		    (list 0.5 0.6 0.7 0.75 0.8 0.85 0.9 0.95 0.975 0.99)
X		    :location (send self :locate-next-control :height 2)
X		    :title "C.L:Left" :length (send self :slider-width)
X		    :index 7 ))
X	 (c4  (send ci-plot-clr-control-proto :new
X		    (list 0.5 0.6 0.7 0.75 0.8 0.85 0.9 0.95 0.975 0.99)
X		    :location (send self :locate-next-control :height 2)
X		    :title "C.L:Right" :length (send self :slider-width)
X		    :index 9 ))
X	 (c5 (send ci-plot-redraw-control-proto :new
X	      :location (send self :locate-next-control :height 2)
X	      :title "Get New Sample")))
X    (send self :add-control c1)
X    (send self :add-control c2)
X    (send self :add-control c3)
X    (send self :add-control c4)
X    (send self :add-control c5)))
X
(defproto ci-plot-redraw-control-proto '() () graph-control-proto)
(defmeth ci-plot-redraw-control-proto :do-action (&rest args) 
X  (send (send self :graph) :draw-four))
X 
(defproto ci-plot-ntop-control-proto '() () slider-control-proto)
(defmeth ci-plot-ntop-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :ntop-chg (+ 5 (* 5 new))))))  
X  (slot-value 'index))
X
(defproto ci-plot-nbot-control-proto '() () slider-control-proto)
(defmeth ci-plot-nbot-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :nbot-chg (+ 5 (* 5 new))))))  
X  (slot-value 'index))
X
(defproto ci-plot-cll-control-proto '() () slider-control-proto)
(defmeth ci-plot-cll-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max))))
X	     (sel (list 0.5 0.6 0.7 0.75 0.8 0.85 0.9 0.95 0.975 0.99)))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :cll-chg (select sel new)))))
X  (slot-value 'index))
X
(defproto ci-plot-clr-control-proto '() () slider-control-proto)
(defmeth ci-plot-clr-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max))))
X	     (sel (list 0.5 0.6 0.7 0.75 0.8 0.85 0.9 0.95 0.975 0.99)))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :clr-chg (select sel new)))))
X  (slot-value 'index))
X
(defmeth graph-proto :plot-controls () 
X  (let* ((margin (send self :margin))
X	 (left (send self :plot-control-left-margin))
X	 (top 12)
X	 (n (+ margin (list left top 0 0))))
X    (apply #'send self :margin n)
X    (send self :add-slot 'overlay-loc '(10 10))
X    (apply #'send self :size (+ (send self :size) (list left top)))
X    #+X11 (send self :size 700 500) ; fits 1/4 of a 14" Sony color monitor
X    (send self :resize)))
X
X
X
X
X
X
X
SHAR_EOF
chmod 0745 Teach/CI/ci.sim ||
echo 'restore of Teach/CI/ci.sim failed'
Wc_c="`wc -c < 'Teach/CI/ci.sim'`"
test 18555 -eq "$Wc_c" ||
	echo 'Teach/CI/ci.sim: original size 18555, current size' "$Wc_c"
fi
# ============= Teach/CLT/clt8.lsp ==============
if test ! -d 'Teach/CLT'; then
    echo 'x - creating directory Teach/CLT'
    mkdir 'Teach/CLT'
fi
if test -f 'Teach/CLT/clt8.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/CLT/clt8.lsp (File already exists)'
else
echo 'x - extracting Teach/CLT/clt8.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/CLT/clt8.lsp' &&
;;;;;           CLT module written by Tae-Sung Shin
X
#+msdos (defmeth graph-proto :overlay-click (x y m1 m2)
X		(if (not (dolist (ov (slot-value 'overlays))
X			(if (send ov :do-click x y m1 m2)
X				(return t)))) 
X		    (send self :redraw))
X		t)
X
; graph-control-proto's checking mouse just once
X
(defproto graph1-control-proto '() () graph-control-proto)
(defmeth graph1-control-proto :do-click (x y a b)
X  (let* ((graph (send self :graph))
X	 (loc (send self :location))
X	 (loc-x (first loc))
X	 (loc-y (+ 5 (second loc))))
X    (when (and (< loc-x x (+ loc-x 10)) (< loc-y y (+ loc-y 10)))
X	  (send graph :paint-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X	  (send self :do-action (list a b))
X	  (send graph :erase-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X	  t)))
X
#+msdos (defmeth popup-menu-control-proto :do-click (x y a b)
X  (let* ((graph (send self :graph))
X	 (loc (send self :location))
X	 (loc-x (first loc))
X	 (loc-y (+ 5 (second loc))))
X    (when (and (< loc-x x (+ loc-x 10)) (< loc-y y (+ loc-y 10)))
X	  (send graph :paint-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X	  (send self :do-action (list a b))
X	  (send graph :erase-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X	  t)))
X
;; CLT-PLOT-PROTO
;;
X
(defproto clt-plot-proto 
X  '(parms parmn index xdata means xlabel ctl graph1 hist2-loc graph2 ctl-loc)
X  () scatterplot-proto)
;;
;;;;;;;;;;;;;;;;;;;; set-up some slots and accessor methods
;;
(defmeth clt-plot-proto :ctl-loc (&optional (ctl-loc nil set))
X  (if set (setf (slot-value 'ctl-loc) ctl-loc))
X  (slot-value 'ctl-loc))
X
(defmeth clt-plot-proto :parms (&optional (parms nil set))
X  (if set (setf (slot-value 'parms) parms))
X  (slot-value 'parms))
X
(defmeth clt-plot-proto :parmn (&optional (parmn nil set))
X  (if set (setf (slot-value 'parmn) parmn))
X  (slot-value 'parmn))
X
(defmeth clt-plot-proto :index (&optional (index nil set))
X  (if set (setf (slot-value 'index) index))
X  (slot-value 'index))
X
(defmeth clt-plot-proto :xdata (&optional (xdata nil set))
X  (if set (setf (slot-value 'xdata) xdata))
X  (slot-value 'xdata))
X
(defmeth clt-plot-proto :xlabel (&optional (xlabel nil set))
X  (if set (setf (slot-value 'xlabel) xlabel))
X  (slot-value 'xlabel))
X
(defmeth clt-plot-proto :means (&optional (means nil set))
X  (if set (setf (slot-value 'means) means))
X  (slot-value 'means))
X
(defmeth clt-plot-proto :ctl (&optional (ctl nil set))
X  (if set (setf (slot-value 'ctl) ctl))
X  (slot-value 'ctl))
X
(defmeth clt-plot-proto :graph1 (&optional (graph1 nil set))
X  (if set (setf (slot-value 'graph1) graph1))
X  (slot-value 'graph1))
X
(defmeth clt-plot-proto :hist2-loc (&optional (hist2-loc nil set))
X  (if set (setf (slot-value 'hist2-loc) hist2-loc))
X  (slot-value 'hist2-loc))
X
(defmeth clt-plot-proto :graph2 (&optional (graph2 nil set))
X  (if set (setf (slot-value 'graph2) graph2))
X  (slot-value 'graph2))
X
;;;; method for closing all plot by closing one of them.
X
(defmeth clt-plot-proto :close ()
X  (when (send self :graph1)
X	(send (send self :graph1) :graph nil)
X	(send (send self :graph1) :close))
X  (when (send self :graph2)
X	(let ((hists (send self :graph2)))
X	  (mapcar #'(lambda (a) (send a :close)) hists)))
X  (call-next-method)
X  (exit)
)
X
;;;;; add values of xdata slot to histogram plot
X
(defmeth clt-plot-proto :put-hist ()
X  (let* ((hist (send self :graph1))
X	 (data (send self :xdata))
X	 (num1 (send hist :num))
X	 (mea1 (send self :means))
X	 (xmean (mean data))
X	 (mea1 (append mea1 (list xmean))))
X    (send self :means mea1)
X    (send hist :num (+ 1 num1))
;    (send hist :draw-color 'blue)
X    (send hist :add-points (list xmean))
X    (send hist :point-color (iseq 0 (send hist :num-points)) 'blue)
X    (when (= (round (/ num1 30)) (/ num1 30)) 
X	  (send hist :adjust-to-data)
X	  (send (send hist :ctl) :index (send hist :num-bins)))
X    (send hist :erase-rect 380 10 100 20)
;    (send hist :draw-color 'blue)
X    (send hist :draw-text 
X	  (concatenate 'string "Number of Simulations : " 
X		       (num-to-string (send hist :num))) 200 20 0 0)))
X
X
;;;;; def of histogram 1 proto
X
(defproto hist1-proto '(num graph ctl) () histogram-proto)
(defmeth hist1-proto :num (&optional (num nil set))
X  (if set (setf (slot-value 'num) num))
X  (slot-value 'num))
(defmeth hist1-proto :graph (&optional (graph nil set))
X  (if set (setf (slot-value 'graph) graph))
X  (slot-value 'graph))
(defmeth hist1-proto :ctl (&optional (ctl nil set))
X  (if set (setf (slot-value 'ctl) ctl))
X  (slot-value 'ctl))
(defmeth hist1-proto :close ()
X  (when (send self :graph)
X	(send (send self :graph) :graph1 nil)
X	(send (send self :graph) :close))
X  (call-next-method))  
(defmeth hist1-proto :redraw ()
X  (call-next-method)
X  (send self :draw-text 
X	(concatenate 'string "Number of Simulations : " 
X		     (num-to-string (send self :num))) 200 20 0 0))
X
X
;;;;; generate a histogram saved from histogram 1
X
(defmeth clt-plot-proto :save-plot ()
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select Distribution!" 170 20 0 0)
X  (let* ((n1 (length (send self :xdata)))
X	 (num1 (send (send self :graph1) :num))
X	 (dist1 (send self :xlabel))
X	 (parms (send self :parms))
X	 (p1 (select parms 0))
X	 (p2 (if (select (send self :parmn) 1) (select parms 1) nil))
X	 (graph2 (if (send self :graph2) (send self :graph2)))
X	 (sp (send hist2-proto :new 1 :show nil 
X		   :title "Saved Histogram of Sample Means"))
X	 (graph2 (append graph2 (list sp))))
X    (send sp :parm (list p1 p2))
X    (send sp :num num1)
X    (send sp :n1 n1)
X    (send sp :dist dist1)
X    (send sp :margin 0 60 0 0)
X    (send sp :size 300 300)
X    (send sp :add-points (send self :means))
X    (send sp :range 0 (first (send (send self :graph1) :range 0))
X	  (second (send (send self :graph1) :range 0)))
X    (send sp :x-axis 
X	  (first (send (send self :graph1) :x-axis))
X	  (second (send (send self :graph1) :x-axis))
X	  (third (send (send self :graph1) :x-axis)))
X    (send sp :adjust-to-data)
X    (send sp :num-bins (send (send self :graph1) :num-bins))
X    (send sp :tile 2)
X    (send sp :graph self)
X    (send self :graph2 graph2)
X    (send sp :show-window) 
X    (if (send self :hist2-loc)
X	(let* ((loc (send self :hist2-loc)))
X	  (send sp :location (+ 20 (first loc)) (+ 20 (second loc)))))
X    (send self :hist2-loc (send sp :location))
#+(or macintosh msdos) (send sp :size 300 200)
#+(or macintosh msdos) (send sp :location 10 220)
X    self)))
X
;;;;; def of the saved histogram
X
(defproto hist2-proto '(num n1 dist parm graph) () histogram-proto)
(defmeth hist2-proto :num (&optional (num nil set))
X  (if set (setf (slot-value 'num) num))
X  (slot-value 'num))
(defmeth hist2-proto :n1 (&optional (n1 nil set))
X  (if set (setf (slot-value 'n1) n1))
X  (slot-value 'n1))
(defmeth hist2-proto :dist (&optional (dist nil set))
X  (if set (setf (slot-value 'dist) dist))
X  (slot-value 'dist))
(defmeth hist2-proto :parm (&optional (parm nil set))
X  (if set (setf (slot-value 'parm) parm))
X  (slot-value 'parm))
(defmeth hist2-proto :graph (&optional (graph nil set))
X  (if set (setf (slot-value 'graph) graph))
X  (slot-value 'graph))
(defmeth hist2-proto :close ()
X  (when (send self :graph)
X	(let* ((graph2 (send (send self :graph) :graph2))
X	      (k (set-difference graph2 (list self))))
X	  (send (send self :graph) :graph2 k)))
X  (call-next-method))
X 
(defmeth hist2-proto :redraw ()
X  (call-next-method)
X  (send self :draw-text 
X	(concatenate 'string "Distribution : " 
X		     (send self :dist) "(" 
X		     (num-to-string (first (send self :parm)))
X		     (if (second (send self :parm)) 
X			 (concatenate 'string 
X				      ","
X				      (num-to-string 
X				       (second (send self :parm)))))
X		     ")" )  10 20 0 0)
X  (send self :draw-text 
X	(concatenate 'string "Sample size : " 
X		     (num-to-string (send self :n1))) 10 40 0 0)
X  (send self :draw-text 
X	(concatenate 'string "Number of Simulations : " 
X		     (num-to-string (send self :num))) 10 60 0 0))
X
;;; distribution selection control set up
X
X
(defproto simulate-menu-proto '(menu) () popup-menu-control-proto)
(defmeth simulate-menu-proto :isnew (loc)
X  (call-next-method loc :title "Distributions"))
(defmeth simulate-menu-proto :menu ()
X  (let ((graph (send self :graph)))
X    (when (null (slot-value 'menu))
X	  (let* ((menu (send menu-proto :new "Menu"))
X		 (normal (send menu-item-proto :new "Normal" 
X		  :action  #'(lambda () (send graph :generate-data 0 t))))
X		 (chisq (send menu-item-proto :new "Chi-square" 
X		  :action #'(lambda () (send graph :generate-data 1 t))))
X		 (t (send menu-item-proto :new "T" 
X		  :action #'(lambda () (send graph :generate-data 2 t))))
X		 (unif (send menu-item-proto :new "Uniform" 
X		  :action #'(lambda () (send graph :generate-data 3 t))))
X		 (expon (send menu-item-proto :new "Exponential" 
X		  :action #'(lambda () (send graph :generate-data 4 t))))
X		 (cauchy (send menu-item-proto :new "Cauchy" 
X		  :action #'(lambda () (send graph :generate-data 5 t))))
X		 (binom (send menu-item-proto :new "Binomial" 
X		  :action #'(lambda () (send graph :generate-data 6 t))))
X		 (pois (send menu-item-proto :new "Poisson" 
X		  :action #'(lambda () (send graph :generate-data 7 t)))))
X	    
X	    (send menu :append-items 
X		  normal chisq t unif expon cauchy binom pois)
X	    (setf (slot-value 'menu) menu)))
X    (slot-value 'menu)))
X
;;;;; methods for plot controls
X 
(defmeth graph-proto :plot-controls () 
X  (let* ((margin (send self :margin))
X	 (left (send self :plot-control-left-margin))
X	 (top 12)
X	 (n (+ margin (list left top 0 0))))
X    (apply #'send self :margin n)
X    (send self :add-slot 'overlay-loc '(10 10))
X    (apply #'send self :size (+ (send self :size) (list left top)))
X    #+X11 (send self :size 490 320); fits 1/4 of a 14" Sony color monitor
X    (send self :resize)))
X
(defmeth clt-plot-proto :install-get-sample-control ()
X      (let* (
X	     (control (send graph-control-proto :new
X			    :location (send self :locate-next-control)
X			    :title "New Sample"))
X	     (owner self))
X	(defmeth control :do-action (&rest args) 
X	  (send owner :new-sample))
X	(send self :add-control control)))
X
(defmeth clt-plot-proto :once100-control ()
X      (let* (
X	     (control (send #+msdos graph1-control-proto 
X			    #+(or macintosh unix) graph-control-proto 
X			    :new
X			    :location  (send self :locate-next-control)
X			    :title "Add 100 Samples"))
X	     (owner self))
X	(defmeth control :do-action (&rest args) 
X	  (send owner :once100))
X	(send self :add-control control)))
X
(defmeth clt-plot-proto :save-control ()
X  (let* (
X	 (control1 (send graph1-control-proto :new
X			:location (send self :locate-next-control) 
X			:title "Save Histogram"))
X	 (owner self))
X    (defmeth control1 :do-action (&rest args) 
X      (send owner :save-plot))
X    (send self :add-control control1)))
X
;;;;; generate 100 means and draw them on histogram
(defmeth clt-plot-proto :once100 ()
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select Distribution!" 170 20 0 0)
X    (let* ((distributions (transpose (send self :return-distributions)))
X	   (sim-funs (select distributions 4))
X	   (function (select sim-funs (send self :index)))
X	   (means (mapcar #'(lambda (i) (mean (funcall function))) 
X			  (iseq 1 100)))
X	   (means1 (send self :means))
X	   (means1 (append means1 means))
X	   (hist (send self :graph1)))
X      (send self :means means1)
X      (send hist :num (+ 100 (send hist :num)))
X    (send hist :add-points means)
X    (send hist :point-color (iseq 0 (send hist :num-points)) 'blue)
X    (send hist :adjust-to-data)
X    (send (send hist :ctl) :index (send hist :num-bins))
X    (send hist :erase-rect 400 10 100 20)
X    (send hist :draw-text 
X	  (concatenate 'string "Number of Simulations : " 
X		       (num-to-string (send hist :num))) 200 20 0 0)
X    )))
X
;;;; method for action after selecting New sample control
X
(defmeth clt-plot-proto :new-sample ()
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select Distribution!" 170 20 0 0)
X    (let* ((distributions (transpose (send self :return-distributions)))
X	   (sim-funs (select distributions 4))
X	   (function (select sim-funs (send self :index))))
X      (funcall function)
X      (send self :clt-draw-points (length (send self :xdata)))
X      (send self :put-hist))))
X
;;
;;;;;;;;;;;;;;;;;;;;;; methods related to Distribution 
;; 
X
(defmeth clt-plot-proto :return-distributions ()
X  "Accessor method for slot :distribution-list."
X  (cond ((null (send self :has-slot 'distribution-list))
X	 (send self :make-distribution-list))
X	((null (slot-value 'distribution-list))
X	 (send self :make-distribution-list))
X	(t (slot-value 'distribution-list))))
X
(defmeth clt-plot-proto :make-distribution-list ()
X  "Creates slot containing the list of lists of distribution
X   names and corresponding activating functions."
X  (send self :add-slot 'distribution-list
X	(list
X	 (list "Normal" #'(lambda (a) (send self :draw-normal a)) 
X	       (list "Mean:" "S.D.:" "Sample Size:")
X	       (list 0 1 4) #'(lambda () (send self :simulate-normal ))
X	       (list (iseq 0 20) (iseq 1 20) (* 4 (iseq 1 20)))) 
X	 (list "Chi-square"  #'(lambda (a) (send self :draw-chisquare a))
X	       (list "DF:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda () (send self :simulate-chisquare ))
X	       (list (iseq 1 20) (iseq 1 20) (* 4 (iseq 1 20))))
X	 (list "t"  #'(lambda (a) (send self :draw-t a ))
X	       (list "DF:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda () (send self :simulate-t ))
X	       (list (iseq 1 20) (iseq 1 20) (* 4 (iseq 1 20))))
X	 (list "Uniform" #'(lambda (a) (send self :draw-uniform a))
X	       (list "a:" "b:" "Sample Size:")
X	       (list 0 1 4) #'(lambda () (send self :simulate-uniform))
X	       (list (iseq 0 20) (iseq 1 20) (* 4 (iseq 1 20))))
X	 (list "Exponential" #'(lambda (a) (send self :draw-expon a))
X	       (list "Theta:" nil "Sample Size:")
X	       (list 1 1 4) #'(lambda () (send self :simulate-expon ))
X	       (list (iseq 1 20) (iseq 1 20) (* 4 (iseq 1 20))))
;        (list "Beta" #'(lambda (a) (send self :draw-beta a))
;              (list "a:" "b:" "Sample Size:")
;              (list 1 1 4) #'(lambda () (send self :simulate-beta ))
;              (list (iseq 1 20) (iseq 1 20) (* 4 (iseq 1 20))))
X	 (list "Cauchy" #'(lambda (a) (send self :draw-cauchy a))
X	       (list "Mean:" nil "Sample Size:")
X	       (list 0 0 4) #'(lambda () (send self :simulate-cauchy ))
X	       (list (iseq 0 20) (iseq 1 20) (* 4 (iseq 1 20))))
X	 (list "Binomial" #'(lambda (a) (send self :draw-binomial a))
X	       (list "n:" "p:" "Sample Size:")
X	       (list 10 0.05 4) #'(lambda () (send self :simulate-binomial ))
X	       (list (iseq 4 30) (* .05 (iseq 1 19)) (* 4 (iseq 1 20))))
X	 (list "Poisson" #'(lambda (a) (send self :draw-poisson a))
X	       (list "Lambda:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda () (send self :simulate-poisson ))
X	       (list (iseq 1 20) (iseq 0 20) (* 4 (iseq 1 20)))))))
X
;;;;; method for actions after selection of distribution
X
(defmeth clt-plot-proto :generate-data (ind getparms)
X  " The actual method for generating from distributions in the
X    distribution-list; calls the appropriate function using the
X    index and uses the get-parms dialog to request parameters." 
X  (if getparms 
X      (let* ((distributions (transpose (send self :return-distributions)))
X	     (name (first distributions))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (parmvalu (fourth distributions))
X	     (seqs (select distributions 5))
X	     (seq (select seqs ind))
X	     (parmn (select parmname ind))
X	     (ctl (send self :ctl))
X	     (n (select ctl 0))
X	     (a (select ctl 1))
X	     (b (if (select ctl 2) (select ctl 2) (send self :add-parm2-ctl))))
X	(send self :xlabel (select name ind))
X	(send n :title (select parmn 2))
X	(send a :title (select parmn 0))
X	(if (select parmn 1) (send b :title (select parmn 1))
X	  (send self :delete-parm2-ctl))
X	(send self :index ind)
X	(send (send self :graph1) :num 0)
;       (send self :means nil)
X	(send self :parmn parmn)
X	(send self :parms (list (select (select seq 0) 0)
X				(select (select seq 1) 0) 
X				(select (select seq 2) 0)))
X	(send n :sequence (select seq 2))
X	(send a :sequence (select seq 0))
X	(if (select parmn 1) (send b :sequence (select seq 1)))
X	(send n :index 0)
X	(send a :index 0)
X	(if (select parmn 1) (send b :index 0))
X	(funcall (select function ind) nil))))
X
(defun convert-text (string)
X  (with-input-from-string (s string)(read s)))
X
;;;;; methods for draw distribution density
X
(defmeth clt-plot-proto :draw-normal (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((mu (first parms))
X		      (sigma (second parms))
X		      (n (third parms))
X		      (xmin (+ mu (* sigma (normal-quant .01))))
X		      (xmax (+ mu (* sigma (normal-quant .99))))
X		      (x (rseq xmin xmax 50)) 
X		      (sample 
X		       (send self :xdata (+ mu (* sigma (normal-rand n)))))
X		      (y (mapcar #'normal-dens (/ (- x mu) sigma))))
X		  (send self :draw-fun xmin xmax sample x y)))))
X
(defmeth clt-plot-proto :add-lines2 (x y)
X  (mapcar #'(lambda (a b) (send self :add-lines 
X				(list (list a a) (list 0 b)))) x y))
X
(defmeth clt-plot-proto :draw-fun (xmin xmax sample x y) 
X  (let ((parms (send self :parms)))
X    (when parms 
X	  (let* ((mu (first parms))
X		 (sigma (sqrt (second parms)))
X		 (n (third parms))
X		 (maxy (max y))
X		 (y (* (/ 1 maxy) y))
X		 (nice-range (get-nice-range xmin xmax 7))
X		 (n1 (first nice-range))
X		 (n2 (second nice-range))
X		 (n3 (third nice-range)))
X	    (send self :clear)
X	    (send self :range 0 n1 n2)
X	    (send self :x-axis t t 5)
X	    (let* ((sam1 
X		    (mapcar 
X		     #'(lambda (a) (if (and (<= a n2) (>= a n1)) a)) sample))
X		   (sam1 (set-difference sam1 '(nil))))
X	      (if (= (length x) 50) (send self :add-lines (list x y))
X		(send self :add-lines2 x y))
X	      (send self :add-points sam1 (repeat .2 (length sam1))))
X	      (send self :point-color 
X		    (iseq 0 (send self :num-points)) 'black)
X	      (send self :means nil)
X	      (let* ((mn (mean sample))
X		     (means (send self :means))
X		     (means (append means (list mn)))
X		     (y-co (+ 0.01 (* .2 maxy)))
X		     (real-co (send self :real-to-canvas n1 (* 2 maxy))))
X		(send self :add-points (list mn) (list .3))
X		(send self :point-color (- (send self :num-points) 1) 'blue)
X		(send self :point-symbol (- (send self :num-points) 1) 'X)
X		(when (find t (> n1 sample)) 
X		      (send self :add-points (list n1) (list .2))
X		      (send self :point-color 
X			    (- (send self :num-points) 1) 'red)
X		      (send self :point-symbol 
X			    (- (send self :num-points) 1) 'cross))
X		(when (find t (< n2 sample)) 
X		      (send self :add-points (list n2) (list .2))
X		      (send self :point-color 
X			    (- (send self :num-points) 1) 'red)
X		      (send self :point-symbol 
X			    (- (send self :num-points) 1) 'cross))
X	      (send self :redraw-content)
X	      (send self :draw-color 'blue)
X	      (send self :draw-text 
X		    (concatenate 'string "x : Sample mean = " 
X				 (num-to-string mn)) 
X		    180 20 0 0)
X	      (send self :draw-color 'red)
X	      (send self :draw-text "+ : data outside plotting range" 
X		    180 40 0 0) 
X	      (send self :draw-color 'black))
X	    (if (< 0 (send (send self :graph1) :num-points))
X		(send (send self :graph1) :clear))
X	    (send (send self :graph1) :range 0 xmin xmax)
X	    (send (send self :graph1) :x-axis t)
X	    (send self :put-hist)))))
X
(defmeth clt-plot-proto :draw-chisquare (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms))
X		       (xmax (chisq-quant .99 df))
X		       (xmin 0)
X		       (x (rseq xmin xmax 50)) 
X		       (sample (send self :xdata (chisq-rand n df)))
X		       (y (mapcar #'(lambda (i) (chisq-dens i df)) x)))
X		  (send self :draw-fun xmin xmax sample x y)))))
X
(defmeth clt-plot-proto :draw-t (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms))
X		       (xmax (t-quant .99 df))
X		       (xmin (t-quant .01 df))
X		       (x (rseq xmin xmax 50)) 
X		       (sample (send self :xdata (t-rand n df)))
X		       (y (mapcar #'(lambda (i) (t-dens i df)) x)))
X		  (send self :draw-fun xmin xmax sample x y)))))
X
(defun unif-dens (a b x)
X  (let* ((dis (- b a))
X	 (dens (/ 1 dis))
X	 (ans (if (and (< a x) (> b x)) dens 0)))
X    ans))
X
(defmeth clt-plot-proto :draw-uniform (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((a (first parms))
X		       (b (second parms))
X		       (n (third parms))
X		       (xmax (+ b .5))
X		       (xmin (- a .5))
X		       (x (rseq xmin xmax 50)) 
X		       (sample (send self :xdata 
X				     (+ (* (- b a) (uniform-rand n)) a)))
X		       (y (mapcar #'(lambda (i) (unif-dens a b i)) x)))
X		  (send self :draw-fun xmin xmax sample x y)))))
X
(defmeth clt-plot-proto :draw-expon (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((theta (first parms))
X		       (n (third parms))
X		       (xmax (* theta (gamma-quant .99 1)))
X		       (xmin (* theta (gamma-quant .01 1)))
X		       (x (rseq xmin xmax 50)) 
X		       (sample (send self :xdata (* theta (gamma-rand n 1))))
X		       (y (mapcar #' (lambda (i) 
X				       (* theta (gamma-dens i 1))) 
X				       (/ x theta))))
X		  (send self :draw-fun xmin xmax sample x y)))))
X
X
(defmeth clt-plot-proto :draw-cauchy (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((mu (first parms))
X		       (n (third parms))
X		       (xmax (+ mu (cauchy-quant .99)))
X		       (xmin (+ mu (cauchy-quant .01)))
X		       (x (rseq xmin xmax 50)) 
X		       (sample (send self :xdata (+ mu (cauchy-rand n))))
X		       (y (mapcar #' (lambda (i) 
X				       (cauchy-dens i)) (- x mu))))
X		  (send self :draw-fun xmin xmax sample x y)))))
X
(defmeth clt-plot-proto :draw-binomial (&optional set)
X (let ((parms (send self :parms)))
X    (when parms (let* ((m (first parms))
X		       (p (second parms))
X		       (n (third parms))
X		       (xmax m)
X		       (xmin 0)
X		       (x (iseq 0 m)) 
X		       (sample (send self :xdata (binomial-rand n m p)))
X		       (y (mapcar #' (lambda (i) 
X				       (binomial-pmf i m p)) x)))
X		  (send self :draw-fun xmin xmax sample x y)))))
X
(defmeth clt-plot-proto :draw-poisson (&optional set)
X (let ((parms (send self :parms)))
X    (when parms (let* ((lamda (first parms))
X		       (n (third parms))
X		       (xmax (round (poisson-quant .9999 lamda)))
X		       (xmin 0)
X		       (x (iseq xmin xmax)) 
X		       (sample (send self :xdata (poisson-rand n lamda)))
X		       (y (mapcar #' (lambda (i) 
X				       (poisson-pmf i lamda)) x)))
X		  (send self :draw-fun xmin xmax sample x y)))))
X
;;;;; methods for generating simulation data
X
(defmeth clt-plot-proto :simulate-normal ()
X  (let ((parms (send self :parms)))
X    (when parms (let* ((mu (first parms))
X		       (sigma (second parms))
X		       (n (third parms))
X		       (y (send self :point-coordinate 1 2)))
X		  (send self :xdata (+ mu (* sigma (normal-rand n))))))))
X
X
(defmeth clt-plot-proto :redraw ()
X  (call-next-method)
X  (if (< 0 (send self :num-lines))
X	   (let* ((y (send self :point-coordinate 1 0))
X		  (y-co (+ .01 y))
X		  (mn (mean (send self :xdata)))
X		  (real-co (send self :real-to-canvas 
X				 (first (send self :range 0)) 
X				 (second (send self :range 1)))))            
X	     (send self :point-symbol (- (send self :num-points) 1) 'X)
X	     (send self :point-color (- (send self :num-points) 1) 'blue)
X	     (send self :draw-color 'blue)
X	     (send self :draw-text 
X		   (concatenate 'string "x : Sample mean = " 
X				 (num-to-string mn))
X		   180 20 0 0)
X	     (send self :draw-color 'red)
X	     (send self :draw-text "+ : data outside plotting range" 
X		   180 40 0 0)
X	     (send self :draw-color 'black))))
X
;;;;; draw points of 'xdata slot values on main plot 
(defmeth clt-plot-proto :clt-draw-points (n)
X  (let* (
X	(samples (send self :xdata))
X	(cll (first (send self :range 0)))
X	(crr (second (send self :range 0)))     
X	(sam1 
X	 (mapcar #'(lambda (a) (if (and (>= crr a) (<= cll a)) a)) samples))
X	(sam1 (set-difference sam1 '(nil))))
X    (send self :clear-points)
X    (send self :add-points sam1 
X	  (repeat .2 (length sam1)))
X    (send self :point-color (iseq 0 (send self :num-points)) 'black)
X    (let* ((mn (mean samples))
X	   (real-co (send self :real-to-canvas 
X			  (first (send self :range 0)) 
X			  (second (send self :range 1)))))
X      (send self :add-points (list mn) (list .3))
X      (send self :point-color (- (send self :num-points) 1) 'blue)
X      (send self :point-symbol (- (send self :num-points) 1) 'X)
X      (when (find t (> (first (send self :range 0)) samples)) 
X		    (send self :add-points 
X			  (list (first (send self :range 0))) (list .2))
X		    (send self :point-color 
X			  (- (send self :num-points) 1) 'red)
X		    (send self :point-symbol 
X			  (- (send self :num-points) 1) 'cross))
X      (when (find t (< (second (send self :range 0)) samples)) 
X	    (send self :add-points 
X		  (list (second (send self :range 0))) (list .2))
X	    (send self :point-color 
X		  (- (send self :num-points) 1) 'red)
X	    (send self :point-symbol 
X		  (- (send self :num-points) 1) 'cross))
X      (send self :redraw-content)
X      (send self :erase-rect 
X	    180 10 270 20)
X      (send self :draw-color 'blue)
X      (send self :draw-text 
X	    (concatenate 'string "x : Sample mean = " 
X			 (num-to-string mn))
X	    180 20 0 0)
X      (send self :draw-color 'black)
X      )))
X  
X
(defmeth clt-plot-proto :simulate-chisquare ()
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms))
X		       (y (send self :point-coordinate 1 2)))
X		  (send self :xdata (chisq-rand n df)))))) 
X
(defmeth clt-plot-proto :simulate-t ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((df (first parms))
X		      (n (third parms)))
X		  (send self :xdata (t-rand n df))))))
X
X
(defmeth clt-plot-proto :simulate-uniform ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((a (first parms))
X		      (b (second parms))
X		      (n (third parms)))
X		  (send self :xdata (+ a (* (- b a) (uniform-rand n))))))))
X
X
X
(defmeth clt-plot-proto :simulate-expon ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((theta (first parms))
X		      (n (third parms)))
X		  (send self :xdata 
X			(send self :xdata (* theta (gamma-rand n 1))))))))
X
X
(defmeth clt-plot-proto :simulate-cauchy ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((mu (first parms))
X		      (n (third parms)))
X		  (send self :xdata (+ mu (cauchy-rand n)))))))
X
X
(defmeth clt-plot-proto :simulate-binomial ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((n (first parms))
X		      (p (second parms))
X		      (m (third parms)))
X		  (send self :xdata (binomial-rand m n p))))))
X
X
(defmeth clt-plot-proto :simulate-poisson ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((lamda (first parms))
X		      (n (third parms)))
X		  (send self :xdata (poisson-rand n lamda))))))
X
X 
;;; installation method
X
(defmeth histogram-proto :plot-controls ()
X  (call-next-method))
(defmeth hist1-proto :plot-controls ()
X  (call-next-method) 
X  (send self :ctl
X	(send hist-control-proto :new (iseq 2 20)
X	      :location (send self :locate-next-control :height 2)
X	      :title "NumBins" :length (send self :slider-width)
X	      :index))
X  (send self :add-control (send self :ctl))
X  (send self :install-kernel-density))
X
(defmeth hist-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max))))) 
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :num-bins (+ 2 new)))
X	))  
X  (slot-value 'index))
X
(defmeth clt-plot-proto :install-menu-controls ()
X    (call-method graph-proto :plot-controls)
X    (send self :add-control (send simulate-menu-proto :new
X				  (send self :locate-next-control)))
X    (let ((n (send clt-n-control-proto :new 
X		   (* 4 (iseq 1 20))
X		   :location (send self :locate-next-control :height 2)
X		   :title "sample size" :length (send self :slider-width)
X		   :index 0))
X	  (a (send clt-parm1-control-proto :new 
X		   (* 4 (iseq 1 20))
X		   :location (send self :locate-next-control :height 2)
X		   :title "parm1" :length (send self :slider-width)
X		   :index 0))    
X	  (b (send clt-parm2-control-proto :new 
X		   (* 4 (iseq 1 20))
X		   :location (send self :locate-next-control :height 2)
X		   :title "parm2" :length (send self :slider-width)
X		   :index 0)))
X      (send self :ctl (list n a b))
X      (send self :add-control n)
X      (send self :add-control a)
X      (send self :add-control b))
X    (send self :install-get-sample-control)
X    (send self :save-control)
X    (send self :once100-control))
X
X
(defun cltplot ()
"generate 2 plots for central limit theorem simulation"
X  (let  ((plotobj (send clt-plot-proto :new 5 
X			:title "Central Limit Theorem Simulation")))
X    (send plotobj :use-color T)
#+unix    (send plotobj :menu nil)
X    (send plotobj :tile 4)
X    (send plotobj :location 7 58)
X    (send plotobj :graph1 (send hist1-proto :new 1 :show nil 
X				:title "Histogram of Sample Means"))
X    (send (send plotobj :graph1) :num 0)
X    (send (send plotobj :graph1) :menu nil)
X    (send (send plotobj :graph1) :graph plotobj)
X    (send (send plotobj :graph1) :tile 3)
X    (send (send plotobj :graph1) :size 510 365)
X    (send (send plotobj :graph1) :margin 0 50 0 0)
X    (send (send plotobj :graph1) :plot-controls)
X    (send (send plotobj :graph1) :show-window)
X    (send plotobj :install-menu-controls)
X    (let* ((mz (send plotobj :margin))
X	   (m1 (first mz))
X	   (m2 (second mz))
X	   (m3 (third mz))
X	   (m4 (fourth mz)))
X      (setf m2 42)
X      (send plotobj :margin m1 110 m3 m4))
#+(or macintosh msdos)    (send plotobj :location 10 28)
#+(or macintosh msdos)    (send plotobj :size 450 200)
#+(or macintosh msdos)    (send (send plotobj :graph1) :location 200 230)
#+(or macintosh msdos)    (send (send plotobj :graph1) :size 450 230)
X    plotobj))
X
;;;;; methods for actions after selecting parameter controls
X
(defmeth clt-plot-proto :n-chg (ind)
X  (if (not (= (send (send self :graph1) :num) 0))
X  (let* ((nctl (select (send self :ctl) 0))
X	 (distributions (transpose (send self :return-distributions)))
X	 (function (select distributions 4))
X	 (parmname (third distributions))
X	 (index (send self :index))
X	 (parms (send self :parms)))
X    (setf (select parms 2) (select (send nctl :sequence) ind))
X    (send self :parms parms)
X    (send self :means nil)
X    (send (send self :graph1) :num 0)
X    (send (send self :graph1) :clear nil)
X    (funcall (select function index))
X    (send self :clt-draw-points (length (send self :xdata)))
X    (send self :put-hist)))
X  (if (not (send self :xdata))
X      (send self :draw-text 
X	    "First, Select Distribution!" 170 20 0 0)))
X
(defmeth clt-plot-proto :parm1-chg (ind)
X  (if (not (= (send (send self :graph1) :num) 0))
X  (let* ((p1ctl (select (send self :ctl) 1))
X	 (distributions (transpose (send self :return-distributions)))
X	 (function (second distributions))
X	 (parmname (third distributions))
X	 (index (send self :index))
X	 (parms (send self :parms)))
X    (setf (select parms 0) (select (send p1ctl :sequence) ind))
X    (send self :parms parms)
X    (send self :means nil)
X    (send (send self :graph1) :num 0)
X    (funcall (select function index) t)))
X  (if (not (send self :xdata)) (send self :draw-text 
X		   "First, Select Distribution!" 170 20 0 0)))
X
(defmeth clt-plot-proto :parm2-chg (ind)
X  (if (not (= (send (send self :graph1) :num) 0))
X  (let* ((p2ctl (select (send self :ctl) 2))
X	 (distributions (transpose (send self :return-distributions)))
X	 (function (second distributions))
X	 (parmname (third distributions))
X	 (index (send self :index))
X	 (parms (send self :parms)))
X    (setf (select parms 1) (select (send p2ctl :sequence) ind))
X    (send self :parms parms)
X    (send self :means nil)
X    (send (send self :graph1) :num 0)
X    (funcall (select function index) t)))
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select Distribution!" 170 20 0 0)))
X
;;;;; delete the second parameter control
X
(defmeth clt-plot-proto :delete-parm2-ctl ()
X  (send self :ctl-loc (send (select (send self :ctl) 2) :location))
X  (send self :delete-control (select (send self :ctl) 2))
X  (setf (select (send self :ctl) 2) nil))
X
;;;;; add the second parameter control
X
(defmeth clt-plot-proto :add-parm2-ctl ()
X  (let* ((ctl (send self :ctl))
X	 (n (select ctl 0))
X	 (a (select ctl 1))
X	 (b (send clt-parm2-control-proto :new 
X		   (* 4 (iseq 1 20))
X		   :location (send self :ctl-loc)
X		   :title "parm2" :length (send self :slider-width)
X		   :index 0)))
X      (send self :ctl (list n a b))
X      (send self :add-control b)
X      b))
X
;;;;; definitions of plot control protos
X
(defproto clt-n-control-proto '() () slider-control-proto)
(defmeth clt-n-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :n-chg new))))  
X  (slot-value 'index))
X
(defproto clt-parm1-control-proto '() () slider-control-proto)
(defmeth clt-parm1-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :parm1-chg new))))  
X  (slot-value 'index))
X
X
(defproto clt-parm2-control-proto '() () slider-control-proto)
(defmeth clt-parm2-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :parm2-chg new))))  
X  (slot-value 'index))
X
X
X
X
X
X
X
SHAR_EOF
chmod 0745 Teach/CLT/clt8.lsp ||
echo 'restore of Teach/CLT/clt8.lsp failed'
Wc_c="`wc -c < 'Teach/CLT/clt8.lsp'`"
test 34096 -eq "$Wc_c" ||
	echo 'Teach/CLT/clt8.lsp: original size 34096, current size' "$Wc_c"
fi
# ============= Teach/LS/lsestm.lsp ==============
if test ! -d 'Teach/LS'; then
    echo 'x - creating directory Teach/LS'
    mkdir 'Teach/LS'
fi
if test -f 'Teach/LS/lsestm.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/LS/lsestm.lsp (File already exists)'
else
echo 'x - extracting Teach/LS/lsestm.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/LS/lsestm.lsp' &&
X
X
;(def datalist (variables))
X
(defproto ls-estm-proto '(coeff data actl bctl ls-fit ls-cor) () scatterplot-proto)
X
(defmeth ls-estm-proto :coeff (&optional (coeff nil set))
X  (if set (setf (slot-value 'coeff) coeff))
X  (slot-value 'coeff))
X
(defmeth ls-estm-proto :data (&optional (data nil set))
X  (if set (setf (slot-value 'data) data))
X  (slot-value 'data))
X
(defmeth ls-estm-proto :actl (&optional (actl nil set))
X  (if set (setf (slot-value 'actl) actl))
X  (slot-value 'actl))
X
(defmeth ls-estm-proto :bctl (&optional (bctl nil set))
X  (if set (setf (slot-value 'bctl) bctl))
X  (slot-value 'bctl))
X
(defmeth ls-estm-proto :ls-fit (&optional (ls-fit nil set))
X  (if set (setf (slot-value 'ls-fit) ls-fit))
X  (slot-value 'ls-fit))
X
(defmeth ls-estm-proto :ls-cor (&optional (ls-cor nil set))
X  (if set (setf (slot-value 'ls-cor) ls-cor))
X  (slot-value 'ls-cor))
X
(defmeth ls-estm-proto :close () 
(exit)
)
X
#+msdos (defmeth popup-menu-control-proto :do-click (x y a b)
(let* ((graph (send self :graph))
X       (loc (send self :location))
X       (loc-x (first loc))
X       (loc-y (+ 5 (second loc))))
X  (when (and (< loc-x x (+ loc-x 10)) (< loc-y y (+ loc-y 10)))
X	(send graph :paint-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X	(send self :do-action (list a b))
X	(send graph :erase-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X	t)))
X
#+msdos (defmeth graph-control-proto :do-click (x y a b)
(let* ((graph (send self :graph))
X       (loc (send self :location))
X       (loc-x (first loc))
X       (loc-y (+ 5 (second loc))))
X  (when (and (< loc-x x (+ loc-x 10)) (< loc-y y (+ loc-y 10)))
X	(send graph :paint-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X	(send self :do-action (list a b))
X	(send graph :erase-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X	t)))
X
(defmeth ls-estm-proto :a-chg (ind)
X  (let* ((coeff (send self :coeff))
X	(index1 (send (send self :actl) :sequence))
X	(a (select index1 ind)))
X    (send self :coeff (list a (second coeff)))
X    (send self :draw-color 'white)
X    (send self :abline (first coeff) (second coeff))
;    (send self :draw-color 'black)
X    (send self :redraw-cont)))
X
(defmeth ls-estm-proto :b-chg (ind)
X  (let* ((coeff (send self :coeff))
X	(index1 (send (send self :bctl) :sequence))
X	(b (select index1 ind)))
X    (send self :coeff (list (first coeff) b))
X    (send self :draw-color 'white)
X    (send self :abline (first coeff) (second coeff))
X    (send self :draw-color 'black)
X    (send self :redraw-cont)))
X
(defun ls ()
X  (let* ((plot (send ls-estm-proto :new 2 :show nil
X		     :title "Least Square Estimation")))
X    (send plot :variable-label 0 "X")
X    (send plot :variable-label 1 "Y")
X    (send plot :coeff (list 2.5 0))
X    (send plot :x-axis t t 6)
X    (send plot :y-axis t t 6)
X    (send plot :range 1 0 5)
X    (send plot :range 0 0 5)
X    (send plot :menu nil)
;    (send plot :plot-controls)
#+unix    (send plot :margin 220 12 0 0)
#+(or macintosh msdos)   (send plot :margin 80 12 0 0)    
X    (send plot :show-window)
X    (send plot :plot-controls)
#+(or macintosh msdos)    (send plot :size 620 415)
#+(or macintosh msdos)    (send plot :location 10 28)
X    plot))
X
#+msdos (defmeth graph-proto :overlay-click (x y m1 m2)
X		(if (not (dolist (ov (slot-value 'overlays))
X			(if (send ov :do-click x y m1 m2) (return t))))
X				(send self :redraw))
X				t)
X
(defmeth ls-estm-proto :redraw-plot ()
X  (let* ((data (send self :data))
X	 (y (first data))
X	 (x (second data)))
X    (send self :add-points (list x y))
X    (send self :adjust-to-data)
X    (send self :clear)
X    (let* ((reg (regression-model x y :print nil))
X	   (coeff (send reg :coef-estimates))
X	   (alpha (first coeff))
X	   (beta (second coeff))
X	   (s-alpha (first (send reg :coef-standard-errors)))
X	   (s-beta (second (send reg :coef-standard-errors)))
X	   (index-a (/ (round (* 1000
X	    (rseq (- alpha (* 2.5 s-alpha)) (+ alpha (* 3.5 s-alpha)) 100)))
X		       1000))
X	   (a (select index-a 30))
X	   (index-b 
X	    (rseq (- beta (* 4.5 s-beta)) (+ beta (* 1.5 s-beta)) 100))
X	   (b (select index-b 30))
X	   (coeff (list a b))
X	   (minx (/ (sum (send self :range 0)) 2))
X	   (maxy (second (send self :range 1)))
X	   (co (send self :real-to-canvas minx maxy))
X	   (minx (+ 20 (first co)))
X	   (maxy (- (second co) 20)))
X      (send self :plot-points data)
X      (send self :draw-color 'blue)
X      (send self :frame-rect (- minx 200) (- maxy 35) 400 40)
X      (send self :print-eqn a b minx (- maxy 20))
X      (send self :draw-text "Residual SS :" minx maxy 2 0)
X      (send self :draw-color 'black)
X      (send self :coeff coeff)
X      (send (send self :actl) :sequence index-a)
X      (send (send self :bctl) :sequence index-b)
X      (send (send self :actl) :index 30)
X      (send (send self :bctl) :index 30))))
X
(defmeth ls-estm-proto :print-eqn (a b minx maxy)
X  (send self :erase-rect (- minx 150) (- maxy 10) 300 13)
X  (send self :draw-text 
X	(concatenate 'string "y = " (num-to-string a) " + " 
X		     (num-to-string b) "*x") minx maxy 1 0))
X
X	 
(defmeth ls-estm-proto :abline (a b)
X  (let* ((data (send self :data))
X	 (y (first data))
X	 (x (second data))
X	 (rng-x (send self :range 0))
X	 (rng-y (send self :range 1))
X	 (rx (first rng-x))
X	 (ry (+ (* rx b) a))
X	 (real-co1 (cond 
X		    ((< ry (first rng-y)) 
X		     (list 
X		      (if (= b 0) (first rng-y) 
X			(/ (- (first rng-y) a) b)) (first rng-y)))
X		    ((> ry (second rng-y))
X		     (list 
X		      (if (= b 0) (first rng-y)
X			(/ (- (second rng-y) a) b)) (second rng-y)))
X		    (t (list rx ry))))
X	 (rx (second rng-x))
X	 (ry (+ (* rx b) a))
X	 (real-co2 (cond 
X		    ((< ry (first rng-y)) 
X		     (list 
X		      (if (= b 0) (first rng-y)
X			(/ (- (first rng-y) a) b)) (first rng-y)))
X		    ((> ry (second rng-y))
X		     (list 
X		      (if (= b 0) (first rng-y)
X			(/ (- (second rng-y) a) b)) (second rng-y)))
X		    (t (list rx ry))))
X	 (rx1 (first real-co1))
X	 (ry1 (second real-co1))
X	 (rx2 (first real-co2))
X	 (ry2 (second real-co2))
X	 (real-co1 (send self :real-to-canvas rx1 ry1))
X	 (real-co2 (send self :real-to-canvas rx2 ry2)))
;    (send self :draw-color 'red)
X    (send self :line-width 2)
X    (send self :draw-line 
X	  (first real-co1) (second real-co1) 
X	  (first real-co2) (second real-co2))
;    (send self :draw-color 'black)
X    (send self :line-width 1)))
X
(defmeth ls-estm-proto :redraw-cont ()
X  (let* ((coeff (send self :coeff))
X	 (a (first coeff))
X	 (b (second coeff)))
X    (send self :draw-color 'red)
X    (send self :abline a b)
X    (send self :draw-color 'black)
X    (send self :redraw-cc)))
X
(defmeth ls-estm-proto :redraw-cc ()
X  (let* ((coeff (send self :coeff))
X	 (a (first coeff))
X	 (b (second coeff))
X	 (minx (/ (sum (send self :range 0)) 2))
X	 (maxy (second (send self :range 1)))
X	 (co (send self :real-to-canvas minx maxy))
X	 (minx (+ 20 (first co)))
X	 (maxy (- (second co) 20)))
X    (send self :draw-color 'blue)
X    (if (send self :data)
X	(let* ((data (send self :data))
X	       (y (first data))
X	       (x (second data))
X	       (r (- y (+ a (* b x))))
X	       (rss (sum (* r r ))))
X	  (send self :plot-points data)
X	  (if (send self :ls-fit) (send self :ls-fit-show))
X	  (send self :draw-color 'blue)
X	  (send self :erase-rect minx (- maxy 10) 100 13)
X	  (send self :draw-text (num-to-string rss) (+ 20 minx) maxy 0 0)))
X    (send self :print-eqn a b minx (- maxy 20))
X    (send self :draw-color 'black)))
X  
X
(defmeth ls-estm-proto :redraw ()
X  (call-next-method)
X  (let* ((coeff (send self :coeff))
X	 (a (first coeff))
X	 (b (second coeff))
X	 (minx (/ (sum (send self :range 0)) 2))
X	 (maxy (second (send self :range 1)))
X	 (co (send self :real-to-canvas minx maxy))
X	 (minx (+ 20 (first co)))
X	 (maxy (- (second co) 20)))
X    (if (send self :data)
X	(let* ((data (send self :data))
X	       (y (first data))
X	       (x (second data))
X	       (r (- y (+ a (* b x))))
X	       (rss (sum (* r r ))))
X	  (send self :plot-points data)
X	  (if (send self :ls-fit) (send self :ls-fit-show))
X	  (if (send self :ls-cor) (send self :ls-cor-show))
X	  (send self :draw-color 'blue)
X	  (send self :frame-rect (- minx 200) (- maxy 35) 400 40)
X	  (send self :draw-text "Residual SS :" minx maxy 2 0)
X	  (send self :draw-text (num-to-string rss) (+ 20 minx) maxy 0 0)
X	  (send self :draw-color 'black)))
X    (send self :draw-color 'blue)
X    (send self :frame-rect (- minx 200) (- maxy 35) 400 40)
X    (send self :print-eqn a b minx (- maxy 20))
X    (send self :draw-color 'red)
X    (send self :abline a b)
X    (send self :draw-color 'black)))
X
(defmeth ls-estm-proto :plot-points (data)
X  (let* ((data (list (first data) (second data)))
X	 (data (transpose data))
X	 (tdata (mapcar #'(lambda (item) 
X			    (send self :real-to-canvas 
X				  (second item) (first item))) data)))
X    (flet ((put-point (co)
X		      (send self :draw-symbol 'disk t (first co) (second co))))
X	  (send self :draw-color 'blue)
X	  (mapcar #'put-point tdata)
X	  (send self :draw-color 'black))))
X
(defmeth ls-estm-proto :ls-fit-show ()
X  (let* ((co (send self :ls-fit))
X	 (a (first co))
X	 (b (second co))
X	 (rss (third co))
X	 (data (send self :data))
X	 (x (second data)))
X    (send self :draw-color 'magenta)
X    (send self :draw-text "Least Squares Fit" 10 200 0 0)
X    (send self :draw-text 
X	  (concatenate 'string "Intercept : " (num-to-string a)) 10 230 0 0)
X    (send self :draw-text 
X	  (concatenate 'string "Slope : " (num-to-string b)) 10 250 0 0)
X    (send self :draw-text "Sum of Squared Residuals" 10 280 0 0)
X    (send self :draw-text (num-to-string rss) 50 300 0 0)
X    (send self :draw-text "Residual Standard" 10 330 0 0)
X    (send self :draw-text "Deviation" 30 350 0 0) 
X    (send self :draw-text (num-to-string (/ rss (- (length x) 2))) 50 370 0 0)
X    (send self :abline a b)
X    (send self :draw-color 'black)))
X
(defproto lsdata-menu-proto '(menu) () popup-menu-control-proto)
X
(defmeth lsdata-menu-proto :isnew (loc)
X  (call-next-method loc :title "Select Data"))
X
(defmeth lsdata-menu-proto :menu ()
X  (let ((graph (send self :graph))
X	(datalist (variables)))
X    (defmeth graph :data-redraw (item1)
X      (send self :ls-cor nil)
X      (send self :ls-fit nil)
X      (send self :data (eval item1))
X      (let* ((data (send self :data))
X		    (y (first data))
X		    (x (second data))
X		    (yttl (third data))
X		    (xttl (fourth data)))
X	
X	(format t "~%")
X	(format t "X variable ~20a ~%" xttl) 
X	(prin1 x)(terpri)
X	(format t "Y variable ~20a ~%" yttl) 
X	(prin1 y)(terpri))
X
X
X      (send self :clear)
X      (send self :redraw-plot))
X    (flet ((mk-item (item)
X		    (send menu-item-proto :new (string item) 
X			  :action  
X			  #'(lambda () (send graph :data-redraw item)))))
X	  (when (null (slot-value 'menu))
X		(let* ((menu (send menu-proto :new "Menu"))
X		       (items (mapcar #'mk-item datalist)))
X		  (flet ((append-item (item)
X				      (send menu :append-items item)))
X			(mapcar #'append-item items))
X		  (setf (slot-value 'menu) menu)))
X	  (slot-value 'menu))))
X
(defproto ls-estm-a-control-proto '() () slider-control-proto)
(defmeth ls-estm-a-control-proto :do-action (j)) 
(defmeth ls-estm-a-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :a-chg new))))  
X  (slot-value 'index))
X
(defproto ls-estm-b-control-proto '() () slider-control-proto)
(defmeth ls-estm-b-control-proto :do-action (j))
(defmeth ls-estm-b-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :b-chg new))))  
X  (slot-value 'index))
X
(defproto ls-fit-control-proto '() () graph-control-proto)
(defmeth ls-fit-control-proto :do-action (&rest args)
X  (if (not (send (send self :graph) :data)) 
X      (send (send self :graph) :draw-text 
X	    "First, Select Data!" 300 80 0 0)
X    (let* ((graph (send self :graph))
X	   (data (send graph :data))
X	   (y (first data))
X	   (x (second data))
X	   (reg (regression-model x y :print nil))
X	   (coeff (send reg :COEF-ESTIMATES))
X	   (rss (send reg :residual-sum-of-squares)))
X      (send graph :ls-fit (list (first coeff) (second coeff) rss))
X      (send graph :ls-fit-show))))
X
(defun cor (x y)
X     (/ (sum (* y (- x (mean x)))) 
X	(* (sqrt (sum (^ (- x (mean x)) 2))) 
X	   (sqrt (sum (^ (- y (mean y)) 2))))))
X 
(defproto ls-cor-control-proto '() () graph-control-proto)
(defmeth ls-cor-control-proto :do-action (&rest args)
X  (if (not (send (send self :graph) :data)) 
X      (send (send self :graph) :draw-text 
X	    "First, Select Data!" 300 80 0 0)
X    (let* ((graph (send self :graph))
X	   (data (send graph :data))
X	   (y (first data))
X	   (x (second data))
X	   (corr (cor x y))
X	   )
X      (send graph :ls-cor T)
X      (send graph :draw-color 'red)
X      (send graph :draw-text 
X	    "Sample Correlation Coeff" 10 400 0 0)
X      (send graph :draw-text (num-to-string corr) 50 420 0 0)
X      (send graph :draw-color 'black))))
X
(defmeth ls-estm-proto :ls-cor-show ()
X  (let* (
X	 (data (send self :data))
X	 (y (first data))
X	 (x (second data))
X	 (corr (cor x y)))
X    (send self :draw-color 'red)
X    (send self :draw-text 
X	  "Sample Correlation Coeff" 10 400 0 0)
X    (send self :draw-text (num-to-string corr) 10 420 0 0)
X    (send self :draw-color 'black)))
X
(defproto ls-stline-control-proto '() () graph-control-proto)
(defmeth ls-stline-control-proto :do-action (&rest args) 
X  (let* ((plot (send self :graph)))
X    (send plot :clear)
X    (send plot :data nil)
X    (send plot :ls-fit nil)
X    (send plot :coeff (list 2.5 0))
X    (send plot :x-axis t t 6)
X    (send plot :y-axis t t 6)
X    (send plot :range 1 0 5)
X    (send plot :range 0 0 5)
X    (send (send plot :actl) :sequence (rseq 0 5 51))
X    (send (send plot :bctl) :sequence (rseq -3 3 61))
X    (send (send plot :actl) :index 25)
X    (send (send plot :bctl) :index 30)
X    (send plot :redraw)))
X
X
(defmeth graph-proto :plot-controls () 
X  (let* ((margin (send self :margin))
X	 (left (send self :plot-control-left-margin))
X	 (top 12)
X	 (n (+ margin (list left top 0 0))))
X    (apply #'send self :margin n)
X    (send self :add-slot 'overlay-loc '(10 10))
X    (apply #'send self :size (+ (send self :size) (list left top)))
X    #+X11 (send self :size 700 500) ; 
X    (send self :resize)))
X
(defmeth ls-estm-proto :plot-controls ()
X  (call-method graph-proto :plot-controls)
X  (send self :add-control 
X	(send self :actl
X	      (send ls-estm-a-control-proto :new (rseq 0 5 51)
X		    :location (send self :locate-next-control :height 2)
X		    :index 25
X		    :title "Intercept" :length (send self :slider-width))))
X
X  (send self :add-control 
X	(send self :bctl
X	      (send ls-estm-b-control-proto :new (rseq -3 3 61)
X		    :location (send self :locate-next-control :height 2)
X		    :index 30
X		    :title "Slope" :length (send self :slider-width))))
X
X  (send self :add-control (send lsdata-menu-proto :new
X				(send self :locate-next-control)))
X  (send self :add-control 
X	(send ls-fit-control-proto :new
X	      :location (send self :locate-next-control)
X	      :title "Fit Least Square"))
X
X  (send self :add-control 
X	(send ls-cor-control-proto :new
X	      :location (send self :locate-next-control)
X	      :title "Correlation"))
X
X  (send self :add-control 
X	(send ls-stline-control-proto :new
X	      :location (send self :locate-next-control)
X	      :title "Reset")))
X
X    
X
SHAR_EOF
chmod 0745 Teach/LS/lsestm.lsp ||
echo 'restore of Teach/LS/lsestm.lsp failed'
Wc_c="`wc -c < 'Teach/LS/lsestm.lsp'`"
test 15531 -eq "$Wc_c" ||
	echo 'Teach/LS/lsestm.lsp: original size 15531, current size' "$Wc_c"
fi
# ============= Teach/LS/ls-dataf.lsp ==============
if test -f 'Teach/LS/ls-dataf.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/LS/ls-dataf.lsp (File already exists)'
else
echo 'x - extracting Teach/LS/ls-dataf.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/LS/ls-dataf.lsp' &&
(def tensile-strength (list (list 162 233 232 231 231 237 224 219 203 189 
210 210 196 180 200 173 188 161 119 161 151 165 151 128 161 146 148 
144 134 127) (list 45 55 61 66 71 71 81 86 53 60 64 68 79 81 56 68 75 
83 88 59 71 80 82 89 51 59 65 74 81 86)  "Tensile-strength" "Hardness"))
X
(def oak-seedling (list (list 5.8 4.5 5.9 6.2 6 7.5 6.1 8.6 8.9 8.2 14.2 11.9 11.1 11.5 14.5 14.8) (list 300 350 400 400 450 450 480 480 530 530 580 580 620 620 670 700) "Shoot-elongation" "degree-hours"))
X
(def snake-river (list (list 10.5 16.7 18.2 17.0 16.3 10.5 23.1 12.4 24.9 22.8 14.1 12.9 8.8 17.4 14.9 10.5 16.1) (list 23.1 32.8 31.8 32 30.4 24 39.5 24.2 52.5 37.9 30.5 25.1 12.4 35.1 31.5 21.1 27.6) "Water-yield" "Water-content"))
X
X
X
SHAR_EOF
chmod 0745 Teach/LS/ls-dataf.lsp ||
echo 'restore of Teach/LS/ls-dataf.lsp failed'
Wc_c="`wc -c < 'Teach/LS/ls-dataf.lsp'`"
test 733 -eq "$Wc_c" ||
	echo 'Teach/LS/ls-dataf.lsp: original size 733, current size' "$Wc_c"
fi
# ============= Teach/OVL/overlay1.lsp ==============
if test ! -d 'Teach/OVL'; then
    echo 'x - creating directory Teach/OVL'
    mkdir 'Teach/OVL'
fi
if test -f 'Teach/OVL/overlay1.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/OVL/overlay1.lsp (File already exists)'
else
echo 'x - extracting Teach/OVL/overlay1.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/OVL/overlay1.lsp' &&
;;;
;;;  plot control prototypes
;;;
X
(defmeth graph-proto :add-control (c) (send self :add-overlay c))
(defmeth graph-proto :delete-control (c) (send self :delete-overlay c))
X
;;; graph control proto
;;; written by Luke Tierney
X
(defproto graph-control-proto 
X  '(action location title) nil graph-overlay-proto)
X
(defmeth graph-control-proto :location (&optional (new nil set))
X  (when set
X        (send self :erase)
X        (setf (slot-value 'location) new)
X        (send self :redraw))
X  (slot-value 'location))
X
(defmeth graph-control-proto :title (&optional (new nil set))
X  (when set
X        (send self :erase)
X        (setf (slot-value 'title) new)
X        (send self :redraw))
X  (slot-value 'title))
X
(defmeth graph-control-proto :erase ()
X  (let ((graph (send self :graph))
X        (loc (send self :location))
X        (sz (send self :size)))
X    (if graph (apply #'send graph :erase-rect (append loc sz)))))
X
(defmeth graph-control-proto :size () 
X  (let ((graph (send self :graph))
X        (title (send self :title)))
X    (if graph
X        (list (+ 10 5 (send graph :text-width title)) 20)
X        (list 10 10))))
X
(defmeth graph-control-proto :redraw ()
X  (let* ((graph (send self :graph))
X         (loc (send self :location))
X         (loc-x (first loc))
X         (loc-y (second loc))
X         (title (send self :title)))
X    (send self :erase)
X    (send graph :frame-rect loc-x (+ 5 loc-y) 10 10)
X    (send graph :draw-text title (+ 15 loc-x) (+ 15 loc-y) 0 0)))
X
(defmeth graph-control-proto :do-click (x y a b)
X  (let* ((graph (send self :graph))
X         (loc (send self :location))
X         (loc-x (first loc))
X         (loc-y (+ 5 (second loc))))
X    (when (and (< loc-x x (+ loc-x 10)) (< loc-y y (+ loc-y 10)))
X          (send graph :paint-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X          (send self :do-action (list a b))
X          (send graph :while-button-down
X                #'(lambda (x y) (send self :do-action nil)) nil)
X          (send graph :erase-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X          t)))
X
(defmeth graph-control-proto :do-action (x) )
X
;;; Rockers
;;; written by Luke Tierney
X
(defproto rocker-control-proto () () graph-control-proto)
X
(defmeth rocker-control-proto :size () 
X  (let ((graph (send self :graph))
X        (title (send self :title)))
X    (if graph
X        (list (+ 10 5 10 5 (send graph :text-width title)) 20)
X        (list 10 10))))
X
(defmeth rocker-control-proto :redraw ()
X  (let* ((graph (send self :graph))
X         (loc (send self :location))
X         (loc-x (first loc))
X         (loc-y (second loc))
X         (title (send self :title)))
X    (send self :erase)
X    (send graph :frame-rect loc-x (+ 5 loc-y) 10 10)
X    (send graph :frame-rect (+ 15 loc-x) (+ 5 loc-y) 10 10)
X    (send graph :draw-text title (+ 30 loc-x) (+ 15 loc-y) 0 0)))
X
(defmeth rocker-control-proto :do-click (x y a b)
X  (let* ((graph (send self :graph))
X         (loc (send self :location))
X         (loc-x1 (first loc))
X         (loc-x2 (+ 15 loc-x1))
X         (loc-y (+ 5 (second loc))))
X    (if (< loc-y y (+ loc-y 10))
X        (let* ((arg (cond 
X                     ((< loc-x1 x (+ loc-x1 10)) '-)
X                     ((< loc-x2 x (+ loc-x2 10)) '+)))
X               (loc-x (case arg (- loc-x1) (+ loc-x2))))
X          (when arg
X                (send graph :paint-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X                (send self :do-action (list a b) arg)
X                (send graph :while-button-down
X                      #'(lambda (x y) (send self :do-action nil arg)) nil)
X                (send graph :erase-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X                t)))))
X
(defmeth rocker-control-proto :do-action (x arg) (sysbeep))
X
;;; Sliders
;;; written by Luke Tierney
X
(defproto slider-control-proto 
X  '(index sequence display) () graph-control-proto)
X
(defmeth slider-control-proto :isnew (sequence &key 
X                                               (title "Value")
X                                               (length 100)
X                                               (display sequence)
X                                               (location '(10 20))
X                                               (index 0)
X                                               graph) 
X  (call-next-method :title title :location location)
X  (send self :sequence sequence :display display)
X  (send self :add-slot 'length length) 
X  (send self :index index)
X  (if graph (send graph :add-control self)))
X
(defmeth slider-control-proto :size () 
X  (list (slot-value 'length) 30))
X
(defmeth slider-control-proto :redraw ()
X  (let* ((graph (send self :graph))
X         (loc (send self :location))
X         (loc-x (first loc))
X         (loc-y (second loc))
X         (w (first (send self :size))))
X    (when graph
X          (send graph :draw-text (send self :title) loc-x (+ loc-y 15) 0 0)
X          (send graph :frame-rect loc-x (+ loc-y 20) w 10)
X          (send self :draw-indicator))))
X
(defmeth slider-control-proto :draw-indicator (&optional index)
X  (let* ((graph (send self :graph))
X         (loc (send self :location))
X         (loc-x (first loc))
X         (loc-y (second loc))
X         (w (first (send self :size)))
X         (min (send self :min))
X         (max (send self :max))
X         (index (if index index (send self :index)))
X         (val (floor (* (- w 7) (/ (- index min) (- max min))))))
X    (when graph
X          (let ((tw (send graph :text-width (send self :title))))
X            (send graph :start-buffering)
X            (send graph :erase-rect (+ 1 tw loc-x) loc-y (- w tw) 20)
X            (send graph :draw-text 
X                  (format nil "~a" (elt (send self :display) index))
X                  (+ loc-x w) (+ loc-y 15) 2 0)
X            (send graph :buffer-to-screen (+ 1 tw loc-x) loc-y (- w tw) 20))
X          (send graph :erase-rect (+ 1 loc-x) (+ 21 loc-y) (- w 2) 8)
X          (send graph :paint-rect (+ 1 loc-x val) (+ 21 loc-y) 5 8))))
X
(defmeth slider-control-proto :min () 0)
X
(defmeth slider-control-proto :max () (- (length (slot-value 'sequence)) 1))
X
(defmeth slider-control-proto :sequence (&optional (seq nil set) &key 
X                                                   (display seq))
X  (when set
X        (setf (slot-value 'sequence) (coerce seq 'vector))
X        (setf (slot-value 'display) (coerce display 'vector)))
X  (slot-value 'sequence))
X
(defmeth slider-control-proto :display () (slot-value 'display))
X
(defmeth slider-control-proto :index (&optional (new nil set))
X  (if set
X      (let* ((new (max (send self :min) (min new (send self :max))))) 
X        (setf (slot-value 'index) new)
X        (send self :draw-indicator)
X        (send self :do-action (elt (send self :sequence) new))))
X  (slot-value 'index))
X
(defmeth slider-control-proto :update-index (&optional (new nil set))
X  (if set
X      (let* ((new (max (send self :min) (min new (send self :max))))) 
X        (setf (slot-value 'index) new)
X        (send self :draw-indicator)))
X  (slot-value 'index))
X
(defmeth slider-control-proto :do-click (x y a b)
;;;kludge to allow indicator to update when drawing next frame
; (when (and (null (send self :has-slot 'first-time))
;            (send self :graph))
;       (let ((control self))
;         (send (send self :graph) :finish-next-frame 
;               #'(lambda () (send control :redraw)))
;         (send self :add-slot 'first-time nil)))
;;;end kludge
X  (let* ((graph (send self :graph))
X         (loc (send self :location))
X         (loc-x (nth 0 loc))
X         (loc-y (nth 1 loc))
X         (w (first (send self :size))))
X    (when (and (< loc-x x (+ loc-x w)) (< (+ loc-y 20) y (+ loc-y 30)))
X          (cond ((and a b) (send self :option-shift-click))
X                (b (send self :option-click))
X                (a (send self :shift-click))
X                (t
X          (let ((pos (+ (floor (* (- w 7) (/ (send self :index) 
X                                             (send self :max))))
X                        loc-x)))
X            (cond
X              ((<= pos x (+ pos 5))
X               (let ((off (- x pos)))
X                 (send graph :while-button-down
X                       #'(lambda (x y)
X                           (let ((val (max (+ loc-x 1)
X                                           (min (- x off) 
X                                                (+ loc-x (- w 6))))))
X                             (setf pos val)
X                             (send self :draw-indicator 
X                                   (floor (* (send self :max) 
X                                             (/ (- pos loc-x) (- w 7)))))))))
X                 (send self :index 
X                       (floor (* (send self :max) 
X                                 (/ (- pos loc-x) (- w 7))))))
X              ((< loc-x x pos)
X               (send graph :while-button-down
X                     #'(lambda (x y)
X                         (let ((pos (+ (floor (* w (/ (send self :index) 
X                                                      (send self :max))))
X                                       loc-x)))
X                           (if (< x pos)
X                               (send self :index (- (send self :index) 1)))))
X                     nil))
X              ((< pos x (+ loc-x w))
X               (send graph :while-button-down
X                     #'(lambda (x y)
X                         (let ((pos (+ (floor (* w (/ (send self :index) 
X                                                      (send self :max))))
X                                       loc-x)))
X                           (if (> x pos)
X                               (send self :index (+ (send self :index) 1)))))
X                     nil))))))
X          t)))
X
;;;;
;;;; Rotation example
;;; written by Luke Tierney
;;;;
X
;;; Rotation around axes
X
(defproto spin-rotate-control-proto '(v) () rocker-control-proto)
X
(defmeth spin-rotate-control-proto :isnew (v)
X  (call-next-method :v v :location (list 10 (case v (0 10) (1 30) (2 50)))))
X
(defmeth spin-rotate-control-proto :title ()
X  (send (send self :graph) :variable-label (slot-value 'v)))
X
(defmeth spin-rotate-control-proto :do-action (first sign)
X  (let ((graph (send self :graph)))
X    (if first
X        (let* ((v (slot-value 'v))
X               (v1 (if (= v 0) 1 0))
X               (v2 (if (= v 2) 1 2))
X               (trans (send graph :transformation))
X               (cols (column-list 
X                      (if trans 
X                          trans 
X                          (identity-matrix (send graph :num-variables)))))
X               (angle (send graph :angle)))
X          (send graph :idle-on (car first))
X          (send graph :slot-value 'rotation-type
X                (make-rotation (nth v1 cols) (nth v2 cols) 
X                               (case sign (+ angle) (- (- angle)))))))
X    (send graph :rotate)))
X
;;; Plot Rocking Control
X
(defproto spin-rock-control-proto '(v) () graph-control-proto)
X
(defmeth spin-rock-control-proto :isnew (loc)
X  (call-next-method :location loc :title "Rock Plot"))
X
(defmeth spin-rock-control-proto :do-action (first) 
X  (send (send self :graph) :rock-plot))
X
(defmeth spin-proto :rock-plot (&optional (a .15))
X  (let* ((angle (send self :angle))
X         (k (round (/ a angle))))
X    (dotimes (i k) (send self :rotate-2 0 2 angle))
X    (dotimes (i (* 2 k)) (send self :rotate-2 0 2 (- angle)))
X    (dotimes (i k) (send self :rotate-2 0 2 angle))))
X
;;;;
;;;;
;;;; Symbol Button Overlay Proto
;;;; Written by James Harner, Univ. of West Virginia, used by permission
;;;;
X
(defproto symbol-button-overlay-proto '() nil graph-control-proto)
X
(defmeth symbol-button-overlay-proto :isnew (location)
X  (call-next-method :location location))
X
;;;
;;; Other Methods
;;;
X
(defmeth symbol-button-overlay-proto :which-symbol (x y) 
X  (let* ((s-x (+ 0 (first (send self :location))))
X         (s-y (+ 10 (second (send self :location))))
X         (y1 (- s-y 8))
X         (y2 (- s-y 1))
X         (y3 (+ s-y 1))
X         (y4 (+ s-y 8)))
X    (cond
X      ((and (< (+ s-x  0) x (+ s-x  7)) (< y1 y y2)) 'dot)
X      ((and (< (+ s-x  8) x (+ s-x 14)) (< y1 y y2)) 'dot1)
X      ((and (< (+ s-x 15) x (+ s-x 22)) (< y1 y y2)) 'dot2)
X      ((and (< (+ s-x 23) x (+ s-x 29)) (< y1 y y2)) 'dot3)
X      ((and (< (+ s-x 30) x (+ s-x 37)) (< y1 y y2)) 'dot4)
X      ((and (< (+ s-x 38) x (+ s-x 44)) (< y1 y y2)) 'disk)
X      ((and (< (+ s-x  0) x (+ s-x  7)) (< y3 y y4)) 'diamond)
X      ((and (< (+ s-x  8) x (+ s-x 14)) (< y3 y y4)) 'cross)
X      ((and (< (+ s-x 15) x (+ s-x 22)) (< y3 y y4)) 'square)
X      ((and (< (+ s-x 23) x (+ s-x 29)) (< y3 y y4)) 'wedge1)
X      ((and (< (+ s-x 30) x (+ s-x 37)) (< y3 y y4)) 'wedge2)
X      ((and (< (+ s-x 38) x (+ s-x 44)) (< y3 y y4)) 'x))))
X      
(defmeth symbol-button-overlay-proto :redraw () 
X  (let* ((s-x (+ 0 (first (send self :location))))
X         (s-y (+ 10 (second (send self :location))))
X         (plot (send self :graph)))
X    (send plot :frame-rect s-x (- s-y 8) 45 17)
X    (send plot :draw-symbol 'dot nil     (+ s-x  3) (- s-y 4))
X    (send plot :draw-symbol 'dot1 nil    (+ s-x 10) (- s-y 4))
X    (send plot :draw-symbol 'dot2 nil    (+ s-x 17) (- s-y 4))
X    (send plot :draw-symbol 'dot3 nil    (+ s-x 24) (- s-y 4))
X    (send plot :draw-symbol 'dot4 nil    (+ s-x 31) (- s-y 4))
X    (send plot :draw-symbol 'disk nil    (+ s-x 40) (- s-y 4))
X    (send plot :draw-symbol 'diamond nil (+ s-x  5) (+ s-y 4))
X    (send plot :draw-symbol 'cross nil   (+ s-x 12) (+ s-y 4))
X    (send plot :draw-symbol 'square nil  (+ s-x 18) (+ s-y 4))
X    (send plot :draw-symbol 'wedge1 nil  (+ s-x 26) (+ s-y 4))
X    (send plot :draw-symbol 'wedge2 nil  (+ s-x 33) (+ s-y 4))
X    (send plot :draw-symbol 'x nil       (+ s-x 40) (+ s-y 4))))
X
(defmeth symbol-button-overlay-proto :do-click (x y m1 m2)
X  (let* ((graph (send self :graph))
X         (which (send graph :points-selected))
X         (symbol (send self :which-symbol  x y)))
X    (when (and symbol which)
X          (dolist (plot (remove-duplicates (cons graph (send graph :links))))
X                  (send plot :depth-cuing nil)
X                  (send plot :point-symbol which symbol)
X                  (send plot :redraw-content)
X                  (send plot :points-selected which))
X			 t)))
X
;;;;
;;;;
;;;; Color Button Overlay Proto
;;;; Written by James Harner, Univ. of West Virginia, used by permission
;;;;
X
(defproto color-button-overlay-proto '() nil graph-control-proto)
X
(defmeth color-button-overlay-proto :isnew (location)
X  (call-next-method :location location))
X
;;;
;;; Other Methods
;;;
X
(defmeth color-button-overlay-proto :which-color (x y) 
X  (let* ((s-x (+ 1  (first (send self :location))))
X         (s-y (+ 10 (second (send self :location))))
X         (y1 (- s-y 8))
X         (y2 (- s-y 1))
X         (y3 (+ s-y 1))
X         (y4 (+ s-y 8)))
X    (cond
X      ((and (< (+ s-x  0) x (+ s-x  7)) (< y1 y y2)) (select *colors* 0))
X      ((and (< (+ s-x  8) x (+ s-x 15)) (< y1 y y2)) (select *colors* 1))
X      ((and (< (+ s-x 16) x (+ s-x 23)) (< y1 y y2)) (select *colors* 2))
X      ((and (< (+ s-x 24) x (+ s-x 31)) (< y1 y y2)) (select *colors* 3))
X      ((and (< (+ s-x  0) x (+ s-x  7)) (< y3 y y4)) (select *colors* 4))
X      ((and (< (+ s-x  8) x (+ s-x 15)) (< y3 y y4)) (select *colors* 5))
X      ((and (< (+ s-x 16) x (+ s-x 23)) (< y3 y y4)) (select *colors* 6))
X      ((and (< (+ s-x 24) x (+ s-x 31)) (< y3 y y4)) (select *colors* 7)))))
X
X
(defmeth color-button-overlay-proto :redraw ()
X  (let* ((s-x (+ 1 (first (send self :location))))
X         (s-y (+ 10 (second (send self :location))))
X         (plot (send self :graph))
X         (color (send plot :draw-color)))
X    (send plot :frame-rect (- s-x 1) (- s-y 8) 33 17)
X    (send plot :draw-color (select *colors* 0))
X    (send plot :paint-rect (+ s-x  0) (- s-y 7) 7 7)
X    (send plot :draw-color (select *colors* 1))
X    (send plot :paint-rect (+ s-x  8) (- s-y 7) 7 7)
X    (send plot :draw-color (select *colors* 2))
X    (send plot :paint-rect (+ s-x 16) (- s-y 7) 7 7)
X    (send plot :draw-color (select *colors* 3))
X    (send plot :paint-rect (+ s-x 24) (- s-y 7) 7 7)
X    (send plot :draw-color (select *colors* 4))
X    (send plot :paint-rect (+ s-x  0) (+ s-y 1) 7 7)
X    (send plot :draw-color (select *colors* 5))
X    (send plot :paint-rect (+ s-x  8) (+ s-y 1) 7 7)
X    (send plot :draw-color (select *colors* 6))
X    (send plot :paint-rect (+ s-x 16) (+ s-y 1) 7 7)
X    (send plot :draw-color (select *colors* 7))
X    (send plot :paint-rect (+ s-x 24) (+ s-y 1) 7 7)
X    (send plot :draw-color color)))
X
(defmeth color-button-overlay-proto :do-click (x y m1 m2)
X  (let* ((graph (send self :graph))
X         (which (send graph :points-selected))
X         (color (send self :which-color x y)))
X    (when (and color which)
X          (cond ((send graph :links)
X                 (dolist (plot (send graph :links))
X                         (send plot :point-color which color)
X                         (send plot :redraw-content)
X                         (send plot :points-selected which)))
X            (t
X             (send graph :point-color which color)
X             (send graph :redraw-content)
X             (send graph :points-selected which))))))
X
;;;
;;;  graph proto installation method for these protos
;;;
X
(defmeth graph-proto :install-color-symbol-buttons ()
X  (let* ((loc (send self :locate-next-control :height 20 :absolute t))
X         (loc2 (if (screen-has-color) (+ loc '(40 0)) loc)))
X    (when (screen-has-color)
X          (send self :use-color t)
X          (send self :add-control (send color-button-overlay-proto :new loc)))
X    (send self :add-control (send symbol-button-overlay-proto :new loc2))))
X
;;; checkbox control proto --- written by S. Weisberg
X
(defproto checkbox-control-proto '(selected) () graph-control-proto)
X
(defmeth checkbox-control-proto :bitmap (selected)
X  (let* ((check-bitmap '#2a(( 1 0 0 0 0 0 0 1  )
X                            ( 0 1 0 0 0 0 1 0  )
X                            ( 0 0 1 0 0 1 0 0  )
X                            ( 0 0 0 1 1 0 0 0  )
X                            ( 0 0 0 1 1 0 0 0  )
X                            ( 0 0 1 0 0 1 0 0  )
X                            ( 0 1 0 0 0 0 1 0  )
X                            ( 1 0 0 0 0 0 0 1  ) ))
X         (blank-bitmap '#2a(( 0 0 0 0 0 0 0 0 )
X                            ( 0 0 0 0 0 0 0 0 )
X                            ( 0 0 0 0 0 0 0 0 )
X                            ( 0 0 0 0 0 0 0 0 )
X                            ( 0 0 0 0 0 0 0 0 )
X                            ( 0 0 0 0 0 0 0 0 )
X                            ( 0 0 0 0 0 0 0 0 )
X                            ( 0 0 0 0 0 0 0 0 )))
X         (loc (send self :location))
X         (loc-x (first loc))
X         (loc-y (second loc))
X         (graph (send self :graph))
X         (map (if selected check-bitmap blank-bitmap)))
X    (send graph :draw-bitmap map (+ 1 loc-x) (+ 6 loc-y))))
X
(defmeth checkbox-control-proto :selected (&optional (new nil set))
X  (when set (setf (slot-value 'selected) new))
X  (slot-value 'selected))
X
(defmeth checkbox-control-proto :redraw () 
X  (let* ((graph (send self :graph))
X         (loc (send self :location))
X         (loc-x (first loc))
X         (loc-y (second loc))
X         (title (send self :title)))
X    (send self :erase)
X    (send graph :frame-rect loc-x (+ 5 loc-y) 10 10)
X    (send graph :draw-text title (+ 15 loc-x) (+ 15 loc-y) 0 0)
X    (send self :bitmap (slot-value 'selected))))
X
(defmeth checkbox-control-proto :do-click (x y a b)
X  (let* ((out nil)
X         (graph (send self :graph))
X         (loc (send self :location))
X         (loc-x (first loc))
X         (loc-y (+ 5 (second loc))))
X    (when (and (< loc-x x (+ loc-x 10)) (< loc-y y (+ loc-y 10)))
X          (setf out t)
X          (cond
X            ((and a b) (send self :option-shift-click))
X            (a (send self :shift-click))
X            (b (send self :option-click))
X            (t
X             (send self :selected (not (send self :selected)))
X             (send self :do-action ))))
X    out))
(defmeth graph-control-proto :option-shift-click () (sysbeep))
(defmeth graph-control-proto :option-click () (sysbeep))
(defmeth graph-control-proto :shift-click () (sysbeep))
(defmeth checkbox-control-proto :do-action () (sysbeep))
X
;;;;
;;;; Instances of Checkbox-control-proto
;;;;
X
X
;;;
;;;  toggle-linear-trend-control-proto
;;;
X
(defproto toggle-linear-trend-control-proto '(data now-computing label)
X  () checkbox-control-proto)
(defmeth toggle-linear-trend-control-proto :isnew (loc title)
X  (call-next-method :location loc :title title))
(defmeth toggle-linear-trend-control-proto :do-action ()
X  (send (send self :graph) :add-slot 'detrended 
X        (if (send self :selected) t nil))
X  (setf (slot-value 'now-computing) t)
X  (if (send self :selected)
X      (send self :delete-trend)
X      (send self :restore-trend))
X  (setf (slot-value 'now-computing) nil))
(defmeth toggle-linear-trend-control-proto :delete-trend (&key update-points)
X  (let* ((graph (send self :graph))
X         (n (iseq (send graph :num-points)))
X         (inc (let* ((a (make-list (send graph :num-points))))
X                    (setf (select a (send graph :points-showing))
X                          (repeat t (length (send graph :points-showing))))
X                    a))
X         (p (iseq (send graph :num-point-variables)))
X         (d (send graph :point-coordinate p (repeat (list n) (length p))))
X         (r (regression-model (select d (remove 1 p)) (select d 1) :print nil
X                              :included inc)))
X        (setf (slot-value 'data) (send r :y))
X        (cond (update-points
X            (send graph :point-coordinate 1 (iseq (send graph :num-points))
X                  (send r :raw-residuals)))
X				  (t (send graph :variable-label 1 
X				       (format nil "~a.detrended" (send graph :variable-label 1)))
X                 (send graph :draw-next-frame '(1) 
X							  (list (send r :raw-residuals)))))
X        ))
(defmeth toggle-linear-trend-control-proto :restore-trend ()
X  (let* ((data (slot-value 'data))
X         (graph (send self :graph)))
X		  (send graph :variable-label 1 (slot-value 'label))
X        (send graph :draw-next-frame '(1) (list data))))
X
;;; installation method
X
(defmeth graph-proto :install-toggle-linear-trend ()
X  (let* ((control (send toggle-linear-trend-control-proto :new 
X                        (send self :locate-next-control) "Rem.Lin.Trend")))
X		  (send control :slot-value 'label (send self :variable-label 1))
X        (send self :finish-next-frame #'(lambda ()
X                (cond ((send control :slot-value 'now-computing) 
X                       (send self :r-adjust-to-data))
X                      ((send control :slot-value 'selected)
X                       (send control :delete-trend :update-points t)
X                       (send self :adjust-to-data))
X                      (t ))))
X        (send self :add-control control)))
SHAR_EOF
chmod 0745 Teach/OVL/overlay1.lsp ||
echo 'restore of Teach/OVL/overlay1.lsp failed'
Wc_c="`wc -c < 'Teach/OVL/overlay1.lsp'`"
test 22768 -eq "$Wc_c" ||
	echo 'Teach/OVL/overlay1.lsp: original size 22768, current size' "$Wc_c"
fi
# ============= Teach/OVL/overlay2.lsp ==============
if test -f 'Teach/OVL/overlay2.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/OVL/overlay2.lsp (File already exists)'
else
echo 'x - extracting Teach/OVL/overlay2.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/OVL/overlay2.lsp' &&
;;;
;;;   Plot control protos
;;;
X
;;; heteroscedasticity control proto
X
(defproto hetero-control-proto '(text) () graph-control-proto)
(defmeth hetero-control-proto :isnew (loc text)
X  (call-next-method :location loc :title "Change Model")
X  (setf (slot-value 'text) text))
(defmeth hetero-control-proto :redraw ()
X  (call-next-method)
X  (when (slot-value 'text) (send (send self :graph) 
X                  :draw-text (slot-value 'text) 
X                  (- (send (send self :graph) :canvas-width) 10) 10 2 0)))
(defmeth hetero-control-proto :do-action (modifier)
X  (let* ((graph (if (send self :has-slot 'graph) (send self :graph) nil)))
X    (when (and graph modifier)
X          (send graph :hetero-change-model)
X          (send graph :redraw))))
X
(defproto hetero2-control-proto '() () checkbox-control-proto)
(defmeth hetero2-control-proto :isnew (loc)
X  (call-next-method  :location loc :title "Abs. Residuals"))
(defmeth hetero2-control-proto :do-action () 
X  (let* ((graph (send self :graph)))
X    (send graph :update-res (slot-value 'selected))))
X
;;;
;;; scale proto -toggles abc/aaa scaling in 3-D plots
;;;
X
(defproto scale-control-proto '() () checkbox-control-proto)
(defmeth scale-control-proto :isnew (loc)
X  (call-next-method  :location loc :title "Fixed Scaling"))
(defmeth scale-control-proto :do-action () 
X  (let* ((graph (send self :graph)))
X   (if (slot-value 'selected) (send graph :scale-type 'fixed)
X      (send graph :scale-type 'variable))))
X
;;; installation method
X
(defmeth graph-proto :install-scale-control ()
X  (send self :add-control (send scale-control-proto :new 
X                        (send self :locate-next-control))))
X
X
;;;
;;; orthogonalize axes proto --- for spin plots
;;;
X
(defproto ortho-control-proto '(axes) () checkbox-control-proto)
(defmeth ortho-control-proto :isnew (loc)
X  (call-next-method  :location loc :title "Orth. Axes")
X  (setf (slot-value 'axes) '(0 2)))
(defmeth ortho-control-proto :do-action () 
X  (let* ((graph (send self :graph))
X         (p (send graph :num-point-variables)))
X    (if (null (slot-value 'axes)) 
X        (setf (slot-value 'axes) (remove 1 (iseq p))))
X   (if (slot-value 'selected) (send graph :ortho (slot-value 'axes))
X      (send graph :original-data))))
(defmeth ortho-control-proto :shift-click ()
X  (let* ((graph (send self :graph))
X         (p (send graph :num-point-variables))
X         (names (coerce (send graph :variable-labels) 'list))
X         (axes (first (choose-subset-dialog "Space to Orthogonalize" names))))
X    (when (> (length axes) 1) (setf (slot-value 'axes) axes))))
X
;;;
;;; Sequential orthogonalization
;;;
X
(defmeth spin-proto :ortho (&optional vars)
"
Message args: (&optional vars)
Replaces variables named in the list VARS with sequentially orthogonalized 
variables in the order given in VARS.  If VARS is nil, the entire plot is 
replaced with orthogonalized variables.  Orthogonalization is via the 
QR decomposition."
(let* ((p (send self :num-point-variables))
X       (n (send self :num-points))
X       (vars (if vars vars (iseq p)))
X       (rep (repeat (list (iseq n)) (length vars)))
X       (data (send self :point-coordinate vars rep))
X       (pr (project data :included (send self :point-showing (iseq n))))
X       (orthdata (rest (column-list (send pr :q))))
X       (full-d-orthdata (if (eq (length orthdata) (length vars)) 
X             orthdata
X             (append orthdata (repeat (list (repeat 0 n)) 
X                       (- (length vars) (length orthdata)))))))
X  (send self :add-slot 'data (send self :point-coordinate
X                                 (iseq p) (repeat (list (iseq n)) p)))
X  (send self :add-slot 'names 
X		  (mapcar #'(lambda (j) (send self :variable-label j)) (iseq p)))
X  (send self :start-buffering)
X  (send self :point-coordinate vars rep full-d-orthdata)
X  (mapcar #'(lambda (j) (send self :variable-label (select vars j)
X    (format nil "~a\.~a" (select (slot-value 'names) (select vars j))
X		 (select (slot-value 'names) (select vars (iseq j))))))
X   	 (iseq 1 (- (length vars) 1)))
X  (send self :r-adjust-to-data)
X  (send self :buffer-to-screen)))
X
(defmeth spin-proto :original-data ()
"
Message args: ()
Returns the plot of the original data. Useful for undoing an orthogonalization."
(let* ((p (send self :num-point-variables))
X		 (n (iseq (send self :num-points))))
X    (send self :start-buffering)
X    (send self :point-coordinate (iseq p) 
X			 (repeat (list n) p) (slot-value 'data))
X    (mapcar #'(lambda (j) (send self :variable-label j 
X									     (select (slot-value 'names) j))) (iseq p))
X    (send self :r-adjust-to-data)
X    (send self :buffer-to-screen)))
X
X
(defmeth spin-proto :install-ortho-control ()
X  (send self :add-control (send ortho-control-proto :new 
X                                (send self :locate-next-control))))
X
;;;;
;;;; curve controls for 2-d plots --- general prototype
;;;;
X
(defproto curve-control-proto '(smoother args color lines) 
X  () checkbox-control-proto)
(defmeth curve-control-proto :isnew (loc title smoother args color)
X  (call-next-method  :location loc :title title) 
X  (send self :smoother smoother)
X  (send self :args args)
X  (send self :color color)
X  self)
(defmeth curve-control-proto :smoother (&optional new)
X  (when new (setf (slot-value 'smoother) new))
X  (slot-value 'smoother))
(defmeth curve-control-proto :args (&optional new)
X  (when new (setf (slot-value 'args) new))
X  (slot-value 'args))
(defmeth curve-control-proto :color (&optional new)
X  (when new (setf (slot-value 'color) new))
X  (when (send self :graph)
X        (send (send self :graph) :get-color (slot-value 'color))))
(defmeth curve-control-proto :do-action () 
X  (when (send self :graph) (send self :draw-curve))
X  (send self :bitmap (slot-value 'selected))
X  (send self :redraw))
(defmeth curve-control-proto :draw-curve ()
X   (let* ((graph (send self :graph)))
X         (cond ((slot-value 'selected)
X                  (let* ((color (send self :color))
X                         (args (send self :args))
X                         (smoother (send self :smoother))
X                         (vals (apply #'funcall smoother args))
X                         (nl (send graph :num-lines)))
X                 (send graph :add-lines vals :color color :draw nil)
X                 (send graph :redraw-content)
X                 (setf (slot-value 'lines)
X                            (iseq nl (send graph :num-lines)))))
X                (t
X                  (send graph :linestart-masked (slot-value 'lines) t)
X                  (send graph :redraw-content)))
X         (slot-value 'selected)))
X
X
;;;
;;;   Instances of curve-control-proto:  Installation
;;;
X
;;;  install zero line button
X
(defmeth scatterplot-proto :install-zero-line ()
X  (let* ((zero #'(lambda (args) (list (send self :range 0) '(0 0))))
X         (control (send curve-control-proto :new
X                (send self :locate-next-control) "Zero line"
X                zero (list nil) (select *colors* 1))))
X  (send self :finish-next-frame #'(lambda () 
X                           (when (send control :slot-value 'selected)
X                                 (send control :draw-curve))))
X  (send self :add-control control)
X  control))
X
;;;
;;; install join points
;;;
X
(defmeth scatterplot-proto :install-join-points ()
X  (let* ((join #'(lambda (args) (send self :join-points)))
X         (control (send curve-control-proto :new
X                (send self :locate-next-control) "Join points"
X                join (list nil) (select *colors* 6))))
X  (send self :finish-next-frame #'(lambda () 
X                           (when (send control :slot-value 'selected)
X                                 (send control :draw-curve))))
X  (send self :add-control control)
X  control))
X
(defmeth scatterplot-proto :join-points ()
X   (let* ((n (iseq (send self :num-points)))
X          (x (send self :point-coordinate 0 n))
X          (y (send self :point-coordinate 1 n))
X          (or (order x)))
X         (list (select x or) (select y or))))
X
(defmeth scatterplot-proto :draw-join-points ()
X  (when (null (send self :has-slot 'join-points))
X        (send self :add-slot 'join-points nil))
X  (cond ((null (slot-value 'join-points))
X         (let* ((nl (send self :num-lines))
X               (send self :add-lines (send self :join-points))
X               (setf (slot-value 'join-points) 
X                     (iseq nl (send self :num-lines))))))
X        (t
X         (send self :linestart-masked (slot-value 'join-points) t)
X         (send self :redraw-content)
X         (setf (slot-value 'join-points) nil)))
X  (slot-value 'join-points))
X
;;;
;;; added variable plot controls
;;;
X
(defproto avp-control-proto '() () curve-control-proto)
(defmeth avp-control-proto :do-action ()
X  (call-next-method )
X  (let* ((graph (send self :graph)))
X    (send graph :redraw)))
(defmeth avp-control-proto :draw-curve ()
X  (let* ((graph (send self :graph)))
X        (cond ((slot-value 'selected)
X               (let* ((nl (send graph :num-lines))
X                      (args (send self :args))
X                      (color (send self :color)))
X                     (send graph :start-buffering)
X                     (apply #'send graph :p-contour args)
X                     (setf (slot-value 'lines) 
X                           (iseq nl (send graph :num-lines)))
X                     (send graph :linestart-color (slot-value 'lines) color)
X                     (send graph :buffer-to-screen)))
X              (t
X               (send graph :linestart-masked (slot-value 'lines) t)
X               (send graph :redraw-content)))
X        (slot-value 'selected)))
X
(defmeth scatterplot-proto :avp-controls ()
X  (let* ((con1 (send avp-control-proto :new
X                        (send self :locate-next-control) "CaseWt Perturb"
X                        #'(lambda (a) ())
X                        (list "case-weights") 'blue))
X         (con2 (send avp-control-proto :new
X                        (send self :locate-next-control) "Pred Perturb"
X                        #'(lambda (a) ())
X                        (list "predictors") 'red)))
X        (send self :add-control con1)
X        (send self :add-control con2)
X        (send self :finish-next-frame
X              #'(lambda () (when (send con1 :slot-value 'selected)
X                                 (send con1 :draw-curve))
X                        (when (send con2 :slot-value 'selected)
X                              (send con2 :draw-curve))))
X        (list con1 con2)))
;;;
;;;  Contour methods for added variable plots
;;;
X
(defmeth graph-proto :p-contour (type &optional (c .57735))
"
Message args: (type &optional (c .57735))
Adds perturbation contours to an added variable plot of type type.  
Used by the avp-controls method."
X  (let* ((inc (which (send (slot-value 'owner) :included)))
X         (which (iseq 0 (1- (send self :num-points))))
X         (num (send self :num-lines))
X         (det (if (send self :has-slot 'detrended)
X                  (slot-value 'detrended) nil))
X         (xx (select (send self :point-coordinate 0 which) inc))
X         (yy (select (send self :point-coordinate 1 which) inc))
X         (c (* c (sqrt (sum (^ (if (equal type "case-weights")
X                                   (* (- yy (if det 0 xx)) xx)
X                                   (- yy (* xx (if det 1 2))))
X                                   2)))))
X         (xr (send self :range 0))
X         (yr (send self :range 1)))
X    (flet ((f (x sign) (+ (if det 0 x) (/ (* c sign) x))))
X      (send self :start-buffering)
X      (cond
X        ((equal type "case-weights")
X         (send self :add-function #'(lambda (x) (f x 1)) 
X            (first xr) (/ c (first yr)))
X         (send self :add-function #'(lambda (x) (f x 1)) 
X            (/ c (second yr)) (second xr)) 
X         (send self :add-function #'(lambda (x) (f x -1)) 
X            (first xr) (/ c (- (second yr))))
X         (send self :add-function #'(lambda (x) (f x -1)) 
X            (/ c (- (first yr))) (second xr)))
X       (t
X        (send self :abline    c  (if det 1 2))
X        (send self :abline (- c) (if det 1 2))))
X      (send self :redraw-content)
X      (send self :buffer-to-screen))))
X
X
;;; smoother slider control
X
(defproto smoother-slider-control-proto '(smoother args color lines menu) 
X  () slider-control-proto)
(defmeth smoother-slider-control-proto :isnew (seq display loc length index
X                                                   title smoother args color)
X  (call-next-method  seq :location loc :title title :length length
X                     :length length :index index :display display) 
X  (send self :smoother smoother)
X  (send self :args args)
X  (send self :color color)
X  self)
(defmeth smoother-slider-control-proto :smoother (&optional new)
X  (when new (setf (slot-value 'smoother) new))
X  (slot-value 'smoother))
(defmeth smoother-slider-control-proto :args (&optional new)
X  (when new (setf (slot-value 'args) new))
X  (slot-value 'args))
(defmeth smoother-slider-control-proto :color (&optional new)
X  (when new (setf (slot-value 'color) new))
X  (when (send self :graph)
X        (send (send self :graph) :get-color (slot-value 'color))))
(defmeth smoother-slider-control-proto :do-action (j) 
X  (when (send self :graph) 
X        (send self :args (list (select (send self :display) j)))
X        (send self :draw-curve)))
(defmeth smoother-slider-control-proto :draw-curve ()
X   (let* ((graph (send self :graph)))
X         (when (slot-value 'lines)
X               (send graph :linestart-masked (slot-value 'lines) t))
X         (when (> (send self :index) 0)
X                  (let* ((color (send self :color))
X                         (args (send self :args))
X                         (smoother (send self :smoother))
X                         (vals (apply #'funcall smoother args))
X                         (nl (send graph :num-lines)))
X               (mapcar #'(lambda (v)
X                 (send graph :add-lines (list (first vals) v)
X                       :color color :draw nil)) (rest vals))
X                 (send graph :redraw-content)
X                 (setf (slot-value 'lines)
X                            (iseq nl (send graph :num-lines)))))
X         (send graph :redraw-content)
X         ))
(defmeth smoother-slider-control-proto :shift-click () (sysbeep))
X
X
;;;
;;; instances of smoother-slider-control-proto
;;;
(defproto estimate-control-proto '(degree maxdegree) 
X  () smoother-slider-control-proto)
X
(defmeth estimate-control-proto :menu ()
X  (let* ((graph (send self :graph)))
X    (when (null (slot-value 'menu)) 
X        (let* ((menu (send menu-proto :new "Estimates menu"))
X               (ols (send menu-item-proto :new "OLS Fit"
X                          :action #'(lambda () (send self :update-type 0))))
X               (m-huber (send menu-item-proto :new "Huber M-est"
X                          :action #'(lambda () (send self :update-type 1))))
X               (m-cau (send menu-item-proto :new "Cauchy M-est"
X                          :action #'(lambda () (send self :update-type 2))))
X               (m-biw (send menu-item-proto :new "Biweight M-est"
X                          :action #'(lambda () (send self :update-type 3))))
X               ) 
X          (send menu :append-items ols m-huber m-cau m-biw)
X          (setf (slot-value 'menu) menu)))
X    (slot-value 'menu)))
X
X
(defmeth estimate-control-proto :shift-click ()
X  (let* ((menu (send self :menu))
X         (loc (+ (send (send self :graph) :location) (send self :location))))
X    (send menu :popup (+ 10 (first loc)) (+ 10 (second loc)))
X    (send self :redraw)))
X
X
(defmeth estimate-control-proto :degree (&optional new)
X    (when new (setf (slot-value 'degree) new))
X      (slot-value 'degree))
X
(defmeth estimate-control-proto :maxdegree (&optional new)
X    (when new (setf (slot-value 'maxdegree) new))
X      (slot-value 'maxdegree))
X
(defmeth scatterplot-proto :fit-curve (degree method &rest args)
X  (flet ((polynomial-fit (beta min max &key (points 30))
X                    (let* ((x (rseq min max points))
X                           (y (apply #'+ (mapcar #'(lambda (b d) (* b (^ x d))) 
X                               beta (iseq (length beta))))))
X                          (list x y))))
X   (let* ((n (send self :points-showing))
X          (x0 (send self :point-coordinate 0 n))
X          (xbar (mean x0))
X          (y (send self :point-coordinate 1 n))
X          (x0 (- x0 xbar))
X          (x (mapcar #'(lambda (d) (^ x0 d)) (iseq 1 degree)))
X          (b (cond ((eq method 'ols)
X                    (let ((r (regression-model x y :print nil)))
X                         (send r :coef-estimates)))
X                    (t (robust-coefs x y (apply #'make-wf args))))))
X         (+ (list xbar 0)
X            (apply #'polynomial-fit b (- (send self :range 0) xbar))))))
X
(defmeth estimate-control-proto :update-type (arg) 
X  (let* ((graph (send self :graph))
X         (names (list 'ols 'huber 'cauchy 'biweight))
X         (seq (list '(1) (rseq .25 3 12) (rseq .5 3.8 12) (rseq .5 6 12)))
X         (default (list 0 6 7 9)))
X        (cond ((= arg 0)
X               (send self :slot-value 'index 0)
X               (send self :sequence (iseq (+ 1 (send self :maxdegree))))
X               (send self :slot-value 'display 
X                     (combine nil (iseq 1 (send self :maxdegree))))
X               (send self :smoother #'(lambda (args) 
X                 (send self :degree args)
X                 (send graph :fit-curve (send self :degree) 'ols)))
X               (send self :title "OLS")
X               (send self :index (send self :degree)))
X              ((<= arg 3)
X               (send self :slot-value 'index 0)
X               (send self :sequence (iseq 11))
X               (send self :slot-value 'display (combine nil (select seq arg)))
X               (send self :smoother #'(lambda (args)
X                 (send graph :fit-curve (send self :degree) 'robust 
X                       (select names arg) args)))
X               (send self :title (format nil "~a M(~a)" (send self :degree)
X                                         (select names arg)))
X               (send self :index (select default arg))))))
X
;;;
;;; installation method
;;;
X
(defmeth scatterplot-proto :install-estimate-control (&key (maxdegree 5))
X  (let* ((control (send estimate-control-proto :new
X                (iseq (+ 1 maxdegree)) (combine nil (iseq 1 maxdegree))
X                (send self :locate-next-control :height 2) 
X                (send self :slider-width) 0 "OLS-Fit"
X                nil (list 1.345) (select *colors* 6))))
X  (send control :maxdegree maxdegree)
X  (send control :degree 1)
X  (send control :smoother #'(lambda (args) (send control :degree args)
X                        (send self :fit-curve args 'ols)))
X  (send self :start-next-frame #'(lambda ()
X            (when (> (send self :num-lines) 0) (send self :clear-lines))))
X  (send self :finish-next-frame #'(lambda () 
X                (when (> (send control :index) 0) (send control :draw-curve))))
X  (send self :add-control control)
X  control))
X
;;;
;;; compute m-estimates, from Tierney (1990), p. 174-175.
;;;
X
(defun robust-coefs (x y wf &key 
X                       (weights (repeat 1 (length y))) 
X                       (tol .0001)
X                       (count-limit 40))
X  (let ((x (if (matrixp x) x (apply #'bind-columns x))))
X    (labels ((as-list (x) (coerce (compound-data-seq x) 'list))
X             (rel-err (x y) 
X               (mean (/ (abs (- x y)) (+ 1 (abs x)))))
X             (reg-coefs (weights)
X               (let* ((m (make-sweep-matrix x y weights))
X                      (p (array-dimension x 1)))
X                 (as-list
X                  (select (first (sweep-operator m (iseq 1 p)))
X                          (1+ p)
X                          (iseq 0 p)))))
X             (fitvals (beta)
X               (+ (first beta) (matmult x (rest beta))))
X             (improve-guess (beta)
X               (let* ((resids (- y (fitvals beta)))
X                      (scale (/ (median (abs resids)) .6745))
X                      (wts (funcall wf (/ resids scale))))
X                 (reg-coefs wts)))
X             (good-enough-p (last beta count)
X               (if (> count count-limit)
X                   (format t "Iteration limit exceeded~%"))
X               (or (> count count-limit)
X                   (and last (< (rel-err beta last) tol)))))
X      (do ((last nil beta)
X           (count 0 (+ count 1))
X           (beta (reg-coefs weights) (improve-guess beta)))
X          ((good-enough-p last beta count) beta)))))
X
(defun make-wf (name &optional
X                     (k (case name
X                              (biweight 4.685)
X                              (cauchy 2.385)
X                              (huber 1.345))))
X  #'(lambda (r) 
X    (let ((u (abs (/ r k))))
X      (case name
X            (biweight (^ (- 1 (^ (pmin u 1) 2)) 2))
X            (cauchy (/ 1 (+ 1 (^ u 2))))
X            (huber (/ 1 (pmax u 1)))))))
X
;;; install kernel density estimate for histograms
X
(defmeth histogram-proto :install-kernel-density ()
X  (let* ((smoother #'(lambda (w type)
X                       (let* ((d (send self :point-coordinate 0
X                                       (send self :points-showing))))
X                         (kernel-dens d :type type :width 
X                                      (* w (standard-deviation d))))))
X         (control (send kernel-slider-control-proto :new
X                        (iseq 11) (combine nil (rseq 0.2 2 10) )
X                        (send self :locate-next-control :height 2) 
X                        (send self :slider-width) 0  "GaussKerDens"
X                        smoother (list 0 'g) (select *colors* 4))))
X    (send self :add-control control)
X    (send self :finish-next-frame #'(lambda () 
X            (when (> (send control :index) 0) (send control :draw-curve))))
X    (defmeth control :shift-click () (sysbeep))
X    control))
X
X
(defproto kernel-slider-control-proto '() () smoother-slider-control-proto)
X
(defmeth kernel-slider-control-proto :shift-click ()
X  (let* ((menu (send self :menu))
X         (loc (+ (send (send self :graph) :location) (send self :location))))
X    (send menu :popup (+ 10 (first loc)) (+ 10 (second loc)))
X    (send self :redraw)))
X
(defmeth kernel-slider-control-proto :do-action (j) 
X  (when (send self :graph) 
X        (send self :args (list (select (send self :display) j)
X                               (second (send self :args))))
X        (send self :draw-curve)))
X
(defmeth kernel-slider-control-proto :menu ()
X  (let* ((graph (send self :graph)))
X    (when (null (slot-value 'menu))
X        (let* ((menu (send menu-proto :new "Smoothers menu"))
X               (gau (send menu-item-proto :new "Gaussian Kernel"
X                          :action #'(lambda () (send self :update-type 0))))
X               (biw (send menu-item-proto :new "Biweight Kernel"
X                          :action #'(lambda () (send self :update-type 1))))
X               (unif (send menu-item-proto :new "Uniform Kernel"
X                          :action #'(lambda () (send self :update-type 2))))
X               (tri (send menu-item-proto :new "Triangular Kernel"
X                          :action #'(lambda () (send self :update-type 3))))
X               (low0 (send menu-item-proto :new "Lowess 0 M-steps"
X                           :action #'(lambda () (send self :update-type 4))))
X               (low1 (send menu-item-proto :new "Lowess 1 M-steps"
X                           :action #'(lambda () (send self :update-type 5))))
X               (low2 (send menu-item-proto :new "Lowess 2 M-steps"
X                           :action #'(lambda () (send self :update-type 6))))
X               (low3 (send menu-item-proto :new "Lowess 3 M-steps"
X                           :action #'(lambda () (send self :update-type 7))))
X               (rob (send menu-item-proto :new "Quantile/Median Smoother"
X                          :action #'(lambda () (send self :update-type 8))))
;              (cvn (send menu-item-proto :new "Optimal bandwidth by CV"
;                        :action #'(lambda () (send self :cv nil))))
;              (cvt (send menu-item-proto :new "Opt bandwidth plus plot"
;                        :action #'(lambda () (send self :cv t))))
X               )
X          (send menu :append-items 
;               cvn cvt 
X                gau biw unif tri low0 low1 low2 low3 rob) 
X          (setf (slot-value 'menu) menu)))
X    (slot-value 'menu)))
X
(defmeth kernel-slider-control-proto :update-type (arg)
X  (let* ((graph (send self :graph)))
X   (send self :args (list (first (send self :args)) 
X                         (case arg (0 'g) (1 'b) (2 'u) (3 't)
X                               (4 0) (5 1) (6 2) (7 3) (8 5))))
X   (send self :title (case arg (0 "GaussKer") (1 "Biweight") (2 "Uniform")
X                          (3 "Triangle")
X                          (4 "Lowess0") (5 "Lowess1") (6 "Lowess2")
X                          (7 "Lowess3") (8 "Quant/Med")))
X   (send self :smoother (cond ((< arg 4) 
X                   #'(lambda (w type)
X                             (let* ((n (send graph :points-showing))
X                                    (d (send graph :point-coordinate '(0 1)
X                                                   (list n n))))
X                                   (kernel-smooth (first d) (second d)
X                                          :type type :width 
X                                          (* w (apply #'- (reverse (range 
X                                                        (first d)))))))))
X                   ((< arg 8) #'(lambda (w steps)
X                             (let* ((n (send graph :points-showing))
X                                    (d (send graph :point-coordinate '(0 1)
X                                                   (list n n))))
X                                   (lowess (first d) (second d)
X                                                  :f w :steps steps))))
X                   (t #'(lambda (p type) 
X                      (let* ((n (send graph :points-showing))
X                        (w (floor (* (min p 1) (length n))))
X                        (data (send graph :point-coordinate '(0 1) (list n n)))
X                        (orderx (order (first data)))
X                        (sortedx (select (first data) orderx))
X                        (sortedy (select (second data) orderx))
X                        (data2 (transpose (envelope sortedx sortedy :l w))))
X                     (list sortedx (first data2) (second data2) 
X                           (third data2)))))))
X  (send self :draw-curve)
X  (send self :redraw)))
X
(defmeth scatterplot-proto :install-kernel ()
X  (let* ((smoother #'(lambda (w type)
X                             (let* ((n (send self :points-showing))
X                                    (d (send self :point-coordinate '(0 1)
X                                                   (list n n))))
X                                   (kernel-smooth (first d) (second d)
X                                          :type type :width 
X                                          (* w (apply #'- (reverse (range
X                                                        (first d)))))))))
X         (control (send kernel-slider-control-proto :new
X                        (iseq 15) (combine nil .1 (rseq 0.3 1 8) 
X                                           1.2 1.4 1.6 1.8 2)
X                        (send self :locate-next-control :height 2) 
X                        (send self :slider-width) 0  "GaussSmooth"
X                        smoother (list 0 'g) (select *colors* 4))))
X    (send self :start-next-frame #'(lambda () 
X         (when (> (send control :index) 0) (send self :clear-lines))))
X    (send self :finish-next-frame #'(lambda () 
X         (when (> (send control :index) 0) (send control :draw-curve))))
X    (send self :add-control control)
X    control))
X
;*******************************************************************
; Methods for an envelope
;
X
(defun envelope (x y &key l)
"Message args: (x y &key l)
Used in the :install-robust-refs method of graph-proto. Assumes the x values
are in inceaseing order."
X (labels ((big-select (data j)
X             (if (or (< j 0) (>= j (length data))) 1e16 (select data j)))
X          (close-subs (data l i)
X             (do ((lr (list i i) (+ lr 
X                        (if (< (big-select data (- (first lr) 1))
X                               (big-select data (+ (second lr) 1)))
X                        (list -1 0) (list 0 1))))
X                 (count 0 (+ count 1)))
X                ((> count (- l 2)) (iseq (first lr) (second lr)))))
X          (envelopei-2 (x y l i)
X             (let* ((dev (abs (- x (select x i))))
X                    (close-subs (close-subs dev l i)))
X                (quantile (select y close-subs) '(.25 .5 .75)))))
X    (let ((l (if l l 5)))
X     (mapcar #'(lambda (i) (envelopei-2 x y (floor l) i)) (iseq (length x))))))
SHAR_EOF
chmod 0745 Teach/OVL/overlay2.lsp ||
echo 'restore of Teach/OVL/overlay2.lsp failed'
Wc_c="`wc -c < 'Teach/OVL/overlay2.lsp'`"
test 28765 -eq "$Wc_c" ||
	echo 'Teach/OVL/overlay2.lsp: original size 28765, current size' "$Wc_c"
fi
# ============= Teach/OVL/overlay3.lsp ==============
if test -f 'Teach/OVL/overlay3.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/OVL/overlay3.lsp (File already exists)'
else
echo 'x - extracting Teach/OVL/overlay3.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/OVL/overlay3.lsp' &&
;;;
;;;  Extract values on an axis and save as a variable
;;;
X
(defproto extract-axis-proto '(axis) () graph-control-proto)
(defmeth extract-axis-proto :isnew (loc title axis)
X  (call-next-method :location loc :title title)
X  (setf (slot-value 'axis) axis))
(defmeth extract-axis-proto :do-click (x y a b)
X  (let* ((graph (send self :graph))
X         (loc (send self :location))
X         (loc-x (first loc))
X         (loc-y (+ 5 (second loc))))
X    (when (and (< loc-x x (+ loc-x 10)) (< loc-y y (+ loc-y 10)))
X          (send self :do-action (list a b))
X          t)))
X
(defmeth extract-axis-proto :do-action (first)
X  (let ((str (get-string-dialog "Name saved quantity" :initial "PLOT-DIR")))
X  (if str
X	(set  (intern (string-upcase str))
X	      (send (send self :graph) :point-transformed-coordinate
X		    (slot-value 'axis) 
X		    (iseq (send (send self :graph) :num-points)))))))
X
(defmeth spin-proto :install-extract-axis (axis)
X  (let* ((title (if (= 0 axis) "Extract Horiz" "Extract Vert"))
X         (control (send extract-axis-proto :new
X                        (send self :locate-next-control)
X                        title axis)))
X        (send self :add-control control)
X        (send self :redraw)
X        control))
X
X
;;;
;;;  Spin off a 2-D plot from the 3-D plot
;;;
X
(defproto extract-2d-proto '() () graph-control-proto)
(defmeth extract-2d-proto :isnew (loc title )
X  (call-next-method :location loc :title title))
(defmeth extract-2d-proto :do-click (x y a b)
"This override does not have a while button down action."
X  (let* ((graph (send self :graph))
X         (loc (send self :location))
X         (loc-x (first loc))
X         (loc-y (+ 5 (second loc))))
X    (when (and (< loc-x x (+ loc-x 10)) (< loc-y y (+ loc-y 10)))
X          (send self :do-action (list a b))
X          t)))
X
(defmeth extract-2d-proto :do-action (first)
X  (let* ((plot (send self :graph))
X         (n (send plot :num-points))
X         (reg (if (send plot :has-slot 'owner)
X                  (send plot :slot-value 'owner)
X                  nil))
X         (d (send plot :point-transformed-coordinate
X                   '(0 1) (repeat (list (iseq n)) 2)))
X         (graph (cond (reg (apply #'send reg :plot d))
X                      (t (let ((p (apply #'plot-points d)))
X                              (send p :plot-controls)
X                              p)))))
X        (send graph :x-axis t t)
X        (send graph :y-axis t t)
X        (send graph :title "Extract from spinning plot")
X        (send graph :variable-label '(0 1) '("Horizontal" "Vertical"))
X        graph))
X
(defmeth spin-proto :install-extract-2d ()
X  (let* ((title "Extract 2-D Plot")
X         (control (send extract-2d-proto :new
X                        (send self :locate-next-control)
X                        title )))
X        (send self :add-control control)
X        (send self :redraw)
X        control))
;;;;
;;;; Miscellaneous controls
;;;;
X
X
;;; home control sends a 3-D plot "Home"
X
(defproto home-control-proto '(v) () graph-control-proto)
(defmeth home-control-proto :isnew (loc)
X  (call-next-method :location loc :title "Home"))
(defmeth home-control-proto :do-click (x y a b)
X  (let* ((graph (send self :graph))
X         (loc (send self :location))
X         (loc-x (first loc))
X         (loc-y (+ 5 (second loc))))
X    (when (and (< loc-x x (+ loc-x 10)) (< loc-y y (+ loc-y 10)))
X          (send self :do-action (list a b))
X          t)))
(defmeth home-control-proto :do-action (first) 
X  (let* ((graph (send self :graph))) 
X    (send graph :add-slot '4d-position -1)
X    (when graph (send graph :transformation nil)) 
X    (when (= 4 (send graph :num-point-variables)) (send graph :draw-title))))
X
(defmeth graph-proto :install-home-control ()
X  (send self :add-control (send home-control-proto :new
X              (send self :locate-next-control))))
X
;;; transformation controls
X
(defproto transform-control-proto '(axis data now-computing) () 
X  slider-control-proto)
(defmeth  transform-control-proto :isnew (loc lam pow &key graph 
X                                                 length 
X                                                 (axis 0)
X                                                 (title "Power")) 
X  (call-next-method lam :location loc :graph graph :length length
X                    :display (* .01 (round (* 100 pow)))
X                    :title title :index 8)
X  (send self :axis axis))
(defmeth transform-control-proto :axis (&optional (new nil set))
X  (when set (setf (slot-value 'axis) new))
X  (slot-value 'axis))
X
(defmeth transform-control-proto :data (&key reset)
X  (cond (reset (setf (slot-value 'data) nil))
X        ((slot-value 'data) (slot-value 'data))
X        (t (setf (slot-value 'data)
X                  (send (send self :graph) :point-coordinate
X                        (send self :axis) 
X                        (iseq (send (send self :graph) :num-points))))))
X  (slot-value 'data))
X
(defmeth  transform-control-proto :do-action (index) 
X  (when (send self :graph)
X        (let* ((graph (send self :graph))
X               (n (send graph :num-points))
X               (data (send self :data))
X               (pow (select (send self :display) index))
X               (new (send self :transform data pow)))
X          (setf (slot-value 'now-computing) t)
X          (send graph :start-buffering)
X          (send graph :draw-next-frame (list (slot-value 'axis))
X                  (list new))
X          (send graph :r-adjust-to-data)
X          (send graph :buffer-to-screen)
X          (setf (slot-value 'now-computing) nil))))
X
(defmeth transform-control-proto :transform (x lambda)
X  (when (<= (min x) 0)
X        (error "Negative data"))
X  (cond ((= lambda 0) (log x))
X        ((= lambda 1) x)
X        (t (/ (- (^ x lambda) 1) lambda))))
X
;;; installation method
;;; (Modified below for use in DATAPLOT)
(defmeth graph-proto :install-transform-control () 
X  (when (null (send self :has-slot 'overlay-loc))
X        (call-method graph-proto :plot-controls)) 
X  (let* ((p (send self :num-point-variables))
X         (n (iseq (send self :num-points)))
X         (names (coerce (send self :variable-labels) 'list))
X         (names (if names (mapcar #'(lambda (n) (substr n 0 6)) names) 
X             (mapcar #'(lambda (a) (format nil "Var~a" a)) (iseq p)))))
X    (mapcar #'(lambda (p name) 
X                (when (> (min (send self :point-coordinate p n)) 0) 
X                      (let* ((control (send transform-control-proto :new
X                                  (send self :locate-next-control :height 2)
X                                  (iseq 13) (rseq -1 2 13)
X                                  :length (send self :slider-width)
X                                  :axis p )))
;                           (send self :start-next-frame #'(lambda ()
;                                (when (null (send control :slot-value 
;                                                  'now-computing))
;                                     (send control :data :reset t)
;                                     (send control :update-index 8))))
X			(send self :add-control control))))
X	    (reverse (iseq p)) (reverse names))
;*******************This is the modification ********************
;*******************(not done since works without it) **************
;	    (list 1) (select names '(0)))
X    (when (equal (send self :slot-value 'proto-name) 'scatmat-proto)
X          (defmeth self :redraw-content ()
X                   (call-next-method)
X                   (mapcar #'(lambda (ov) (send ov :redraw))
X                           (slot-value 'overlays)))
X          (defmeth self :redraw ()
X            (call-next-method)
X            (mapcar #'(lambda (ov) (send ov :redraw)) 
X                    (slot-value 'overlays))))))
X            
X            
;;; histogram controls
X
(defproto hist-control-proto '() () slider-control-proto)
(defmeth  hist-control-proto :do-action (j)) 
(defmeth hist-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max))))) 
X        (setf (slot-value 'index) new)
X        (send self :draw-indicator)
X        (send self :do-action (elt (send self :sequence) new))
X        (if (send self :graph) (send (send self :graph) 
X                                     :num-bins (+ 2 new)))))  
X  (slot-value 'index))
X
(defmeth graph-proto :dynamic-plot-control (seq display)
X  (send self :add-control (send dynamic-plot-control-proto :new
X                   (send self :locate-next-control :height 2)
X                        seq display
X                        :length (send self :slider-width))))
X
X
;;; dynamic plot slider
X
(defproto dynamic-plot-control-proto () () slider-control-proto)
(defmeth  dynamic-plot-control-proto :isnew (loc lam pow &key graph 
X                                                 (length 80)
X                                                 (title "Power")) 
X  (call-next-method lam :location loc :graph graph :length length
X                    :display (* .01 (round (* 100 pow)))
X                    :title title))
(defmeth  dynamic-plot-control-proto :do-action (j) 
X  (when (slot-value 'graph)
X        (let* ((graph (send self :graph)))
X          (send graph :draw-next-frame '(0 1)
X                (list (select (send graph :slot-value 'data-x) j) 
X                      (select (send graph :slot-value 'data-y) j))))))
X
X
(defproto popup-menu-control-proto '(menu) () graph-control-proto)
X
(defmeth popup-menu-control-proto :isnew (loc &key (title "Popup Menu"))
X  (call-next-method :location loc :title title))
X
(defmeth popup-menu-control-proto :menu ()
X  (let* ((graph (send self :graph)))
X    (when (null (slot-value 'menu))
X        (let* ((menu (send menu-proto :new "Menu"))
X               (item (send menu-item-proto :new "Home Away from Home"
X                         :action #'(lambda () (sysbeep)))))
X          (send menu :append-items item)
X          (setf (slot-value 'menu) menu)))
X    (slot-value 'menu)))
X
(defmeth popup-menu-control-proto :do-action (first)
X  (let* ((menu (send self :menu))
X         (loc (+ (send (send self :graph) :location) (send self :location))))
X    (send menu :popup (+ 10 (first loc)) (+ 10 (second loc)))
X    (send self :redraw)))
X
;;; 3-d residual control proto
X
(defproto 3d-control-proto '(menu) () popup-menu-control-proto)
(defmeth 3d-control-proto :isnew (loc)
X  (call-next-method loc :title "Rotations Menu"))
X
(defmeth 3d-control-proto :menu ()
X  (let* ((graph (send self :graph)))
X    (when (null (slot-value 'menu))
X        (let* ((menu (send menu-proto :new "Menu"))
X               (yhat (send menu-item-proto :new "Rotate to Yhat"
X                         :action #'(lambda () 
X                            (send graph :rotate-to-yhat))))
X               (e1 (send menu-item-proto :new "Rotate to e1"
X                         :action #'(lambda () 
X                            (send graph :rotate-to-e1))))
X               (ares (send menu-item-proto :new "ARES rotation"
X                         :action #'(lambda () 
X                            (send graph :rotate-ares))))
X               (coord (send menu-item-proto :new "Print Screen Coordinates"
X                     :action #'(lambda () (send graph :screen-coordinates))))
X               (int0 (send menu-item-proto :new "Move ... to Horizontal"
X                     :action #'(lambda () (send graph :interchange 0))))
X               (int1 (send menu-item-proto :new "Move ... to Vertical"
X                     :action #'(lambda () (send graph :interchange 1))))
X               (int2 (send menu-item-proto :new "Move ... to Out of Page"
X                     :action #'(lambda () (send graph :interchange 2)))))
X          (send menu :append-items  ares yhat e1 coord int0 int1 int2)
X          (setf (slot-value 'menu) menu)))
X    (slot-value 'menu)))
X
X
(defmeth spin-proto :rotate-to-yhat ()
"
Puts yhat12 on the x-axis."
X  (let* ((p (send self :num-variables))
X         (tr (if (send self :transformation) (send self :transformation)
X                 (identity-matrix p)))
X         (from (mapcar #'(lambda (j k) (if (or (= j 0) (= j 2)) k 0)) (iseq p) 
X                       (* (send self :scale (iseq p)))))) 
X    (send self :rotate-from-to (matmult tr from) 0)
X    (send self :rotate-from-to (matmult (send self :transformation)
X                       (mapcar #'(lambda (j) (if (= j 1) 1 0)) (iseq p))) 1)
X    (send self :add-slot '4d-position -1)))
X
(defmeth spin-proto :rotate-to-e1 ()
"
Puts e1 on the y-axis by rotating from the current location of (1 1 0 ...) to (0 1 0 ...)."
X  (let* ((p (send self :num-point-variables))
X         (tr (if (send self :transformation) (send self :transformation)
X                 (identity-matrix p)))
X         (from (mapcar #'(lambda (j k) (if (< j 2) k 0)) (iseq p) 
X                       (* (send self :scale (iseq p))))))
X    (send self :rotate-from-to (matmult tr from) 1)
X    (send self :rotate-from-to (matmult (send self :transformation)
X                       (mapcar #'(lambda (k) (if-else (= k 2) 1 0)) (iseq p)))
X          0)
X    (send self :add-slot '4d-position -1)))
X
(defmeth spin-proto :rotate-ares (&optional (inc 20))
"
See Cook and Weisberg (1990), Three dimensional residual plots, 
Interface symposium, page 164."
X  (when (null (send self :has-slot 'ares-direction))
X        (send self :add-slot 'ares-direction '+)) 
X  (cond ((eq (slot-value 'ares-direction) '+) (send self :ares-plus inc))
X    (t (send self :ares-minus inc))))
X
(defmeth spin-proto :ares-minus (&optional (inc 20))
X  (send self :add-slot 'ares-direction '+)
X  (let* ((scale (send self :scale '(0 1 2)))
X         (n (send self :num-point-variables))
X         (a (nth 0 scale))
X         (b (nth 1 scale))
X         (c (nth 2 scale))
X         (make-axis #'(lambda (j) (mapcar #'(lambda (k) (if-else (= j k) 1 0)) 
X                                          (iseq n))))
X         (theta-inc (/ (- (/ pi 2) (atan (/ c a))) inc)) ;;ok
X         (m (make-rotation (funcall make-axis 0)
X                           (- (funcall make-axis 2)) theta-inc))
X         (vec (matmult (make-rotation (funcall make-axis 0)
X                                      (- (funcall make-axis 2)) 
X                                      (atan (/ c a)))
X                      (coerce (funcall make-axis 0) 'vector))) 
X         (theta-values (rseq (atan (/ c a)) (/ pi 2) (+ 1 inc))) ;;ok
X         (theta-rot (make-rotation (funcall make-axis 0) (funcall make-axis 2)
X                                   (- theta-inc)))
X         (eta-values (atan (* (/ a b)
X                              (- 1 (/ (/ c a) (tan theta-values)))))) ;;ok
X         (eta-inc (- (cdr eta-values) (rmel inc eta-values)))
X         (tr (if (send self :transformation) (send self :transformation)
X                 (identity-matrix n)))) 
X    (send self :apply-transformation 
X          (make-rotation (matmult tr 
X                          (coerce (* scale (+ (funcall make-axis 0) 
X                                          (funcall make-axis 2))) 'vector))
X                         (funcall make-axis 0)))
X    (send self :apply-transformation 
X          (make-rotation (matmult (send self :transformation) 
X                                  (funcall make-axis 1)) 
X                         (funcall make-axis 1)))
X ;   (send self :rotate-to-yhat)
X    (dotimes (i inc)
X             (setf vec (matmult m vec))
X             (setf tr (matmult (make-rotation vec (funcall make-axis 1) 
X                                              (nth i eta-inc)) 
X                               theta-rot (send self :transformation)))
X             (send self :transformation tr))))
X
(defmeth spin-proto :ares-plus (inc)
"
Message args: ()
Performs rotation from (e1,yh1) to (e yh) when yh2.1 is being plotted on the x-axis"
X  (send self :add-slot 'ares-direction '-)
X  (let* ((scale (send self :scale '(0 1 2)))
X         (n (send self :num-point-variables))
X         (a (nth 0 scale))
X         (b (nth 1 scale))
X         (c (nth 2 scale))
X         (make-axis #'(lambda (j) (mapcar #'(lambda (k) (if-else (= j k) 1 0)) 
X                                          (iseq n))))
X         (theta-inc (/ (- (/ pi 2) (atan (/ c a))) inc)) ;;ok
X         (m (make-rotation (- (funcall make-axis 2)) (funcall make-axis 0)
X                          theta-inc)) 
X         (vec (coerce (- (funcall make-axis 2)) 'vector))
X         (theta-values (rseq (atan (/ c a)) (/ pi 2) (+ 1 inc))) ;;ok
X         (eta-values (atan (* (/ a b)
X                              (- 1 (/ (/ c a) (tan theta-values)))))) ;;ok
X         (eta-inc (- (cdr eta-values) (rmel inc eta-values))))
X    (send self :start-buffering)
X    (send self :transformation nil)
X    (send self :rotate-2 0 2 (- (/ pi 2)))
X    (send self :rotate-2 1 2 (atan (/ a b)))
X    (send self :buffer-to-screen)
X    (dotimes (i inc)                           
X             (send self :apply-transformation 
X                   (make-rotation '(0 1 0) vec (nth i (reverse eta-inc))))
X             (setf vec (matmult m vec))
X             (send self :rotate-2 0 2 theta-inc))))
X
X
;;; print screen coordinates
X
(defmeth spin-proto :screen-coordinates ()
X  (let* ((p (send self :num-point-variables)))
X  (print-matrix (apply #'bind-rows 
X                       (mapcar #'(lambda (j) (send self :name-on-axis j))
X                               (iseq p))))))
X                                         
X
(defmeth spin-proto :name-on-axis (j)
X  (let* ((p (send self :num-point-variables))
X         (tr (if (send self :transformation) (send self :transformation)
X                 (identity-matrix p)))
X         (pr (/ (coerce (coerce (select tr j (iseq p)) 'vector) 'list)
X                 (send self :scale (iseq p))))) 
X    (* .001 (round (* 1000 (/ pr (sqrt (inner-product pr pr))))))))
X
;;; interchange axes
X
(defmeth spin-proto :interchange (axis &key from)
X  (let* ((graph self)
X         (n (send graph :num-point-variables))
X         (lab (send self :variable-label (iseq n)))
X         (names (list "Move ... to Horizontal" "Move ... to Vertical"
X                      "Move ... to Out of Page" "Move ... Off-screen"))
X         (title (format nil "~a" (select names axis)))
X         (from (if from from (choose-item-dialog title lab)))
X         (s (send graph :scale (iseq n)))
X         (trans (if (send graph :transformation) (send graph :transformation)
X                    (identity-matrix n))))
X    (send graph :redraw)
X    (when from
X          (when (numberp from)
X                (setf from (mapcar #'(lambda (a) (if (= a from) 1 0)) 
X                                  (iseq n))))
X          (send graph :add-slot '4d-position -1) 
X          (send graph :rotate-from-to (matmult trans (* from s)) axis))))
X
(defmeth spin-proto :rotate-from-to (from to)
"
Message args: (from to)
Rotates the plot from FROM in the direction TO.  from and two are
(1) lists of the same length as num-variables or
(2) intergers that label the axes, in which case rotation is in the plane of 
the corresponding axes.  By assumption, both from and to are in screen 
coordinates.  If they are in absolute coordinates, then they should 
be premultiplied as, for example, (matmult (send self :transformation) 
(coerce (* (send self :scale '(0 ...)) from) 'vector))."
X  (labels ((make-vec (v) (if (listp v) v
X                (mapcar #'(lambda (z) (if (eq v z) 1 0)) 
X                        (iseq (send self :num-point-variables)))))
X           (make-ang (from to) 
X                     (let* ((ip1 (inner-product from to))
X                            (ip (* (inner-product from from)
X                                   (inner-product to to))))
X                       (if (< ip 1.e-9) 0 (acos (/ ip1 (sqrt ip)))))))
X    (let* ((from (make-vec from))
X           (to   (make-vec to))
X           (ang  (abs (make-ang from to)))
X           (num-steps (max 2 (floor (/ (abs ang)
X                                       (abs (send self :angle))))))
X           (gamma (if (send self :transformation) (send self :transformation)
X                   (identity-matrix (send self :num-point-variables))))
X           (rot1 (make-rotation from to (/ ang num-steps))))
X      (cond
X        ((< (abs ang) 1.e-9) nil)           ;;;return if angle is 0
X        (t (dotimes (j num-steps) (send self :apply-transformation rot1)))))))
X
X
X
;;;;
;;;; General Installation Methods
;;;;
X
(defmeth graph-proto :locate-next-control (&key (height 1) (absolute nil)
X                                                (update t))
X  (let ((a (slot-value 'overlay-loc))
X        (size (cond (absolute height)
X                    (t (+ 2 (* height (+  2 (send self :text-ascent) 
X                                         (send self :text-descent))))))))
X    (when update (setf (slot-value 'overlay-loc)
X                       (list (first a) (+ (second a) size))))
X    a))
X
(defmeth graph-proto :plot-control-left-margin ()
X  (+ 35 (send self :text-width "Rem. Lin. Trend")))
X
(defmeth graph-proto :slider-width ()
X  (+ 15 (send self :text-width "Rem. Lin. Trend")))
X    
;;;
;;; plot-control methods
;;;
X
(defmeth graph-proto :plot-controls () 
X  (let* ((margin (send self :margin))
X         (left (send self :plot-control-left-margin))
X         (top 12)
X         (n (+ margin (list left top 0 0))))
X    (apply #'send self :margin n)
X    (send self :add-slot 'overlay-loc '(10 10))
X    (apply #'send self :size (+ (send self :size) (list left top)))
#+X11 (send self :size 510 365) ; fits 1/4 of a 14" Sony color monitor
X    (send self :resize)))
X
;;; installation method
X
(defmeth histogram-proto :plot-controls ()
X  (call-next-method)
X  (send self :add-control (send hist-control-proto :new (iseq 2 20)
X                :location (send self :locate-next-control :height 2)
X                :title "NumBins" :length (send self :slider-width)))
X  (send self :install-kernel-density)
X  (send self :install-transform-control))
X
(defmeth scatterplot-proto :plot-controls ()
X  (call-next-method)
X  (send self :install-color-symbol-buttons)   
X  (send self :install-toggle-linear-trend)
; (send self :install-OLS)
X  (send self :install-zero-line)
X  (send self :install-join-points)
X  (send self :install-estimate-control)
; (send self :install-m-est)
X  (send self :install-kernel)
; (send self :install-lowess)
X  )
X
(defmeth spin-proto :plot-controls ()
X  (call-next-method)
#+X11 (send self :install-color-symbol-buttons)
X  (send self :install-toggle-linear-trend)
X  (send self :install-ortho-control)
X  (send self :install-scale-control)
X  (send self :install-home-control)
X  (send self :add-control (send spin-rock-control-proto :new 
X                                (send self :locate-next-control)))
X  (send self :install-extract-axis 0)
X  (send self :install-extract-2d))
X
(defmeth scatmat-proto :plot-controls ()
X  (call-next-method)
X  (send self :install-color-symbol-buttons)
X  (send self :install-transform-control))
X
(defmeth spin-proto :spin-resid-controls ()
X  (call-method graph-proto :plot-controls)
#+X11 (send self :install-color-symbol-buttons)
X  (send self :install-scale-control)
X  (send self :install-home-control)
X  (send self :add-control (send spin-rock-control-proto :new 
X                                (send self :locate-next-control)))
X  (send self :install-extract-axis 0)
X  (send self :install-extract-2d)
X  (send self :add-control (send 3d-control-proto :new
X                                (send self :locate-next-control)))
X  (send self :redraw))
X
(defmeth scatterplot-proto :boxplot-controls ()
X  (call-method graph-proto :plot-controls)
X  (send self :install-color-symbol-buttons))
;;
;;;;;;;;;;;;;;; this is my method and not found in sandy's overlay3
;;
(defmeth scatterplot-proto :my-plot-controls ()
X  (send self :plot-controls)
X  (send self :install-transform-control))
SHAR_EOF
chmod 0745 Teach/OVL/overlay3.lsp ||
echo 'restore of Teach/OVL/overlay3.lsp failed'
Wc_c="`wc -c < 'Teach/OVL/overlay3.lsp'`"
test 23634 -eq "$Wc_c" ||
	echo 'Teach/OVL/overlay3.lsp: original size 23634, current size' "$Wc_c"
fi
# ============= Teach/OVL/make-col.lsp ==============
if test -f 'Teach/OVL/make-col.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/OVL/make-col.lsp (File already exists)'
else
echo 'x - extracting Teach/OVL/make-col.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/OVL/make-col.lsp' &&
(make-color 'brown .8 .5 2)
(make-color 'violet .8 .5 .9)
(make-color 'libg .0 .8 .7)
(make-color 'dgray 0 .55 .65)
(make-color 'jungle .5 .65 .5)
(make-color 'blood 1.0 .4 .5)
(make-color 'orange 1.0 .6 .0)
(make-color 'apple 1.0 .9 .0)
(make-color 'libr 1.0 .9 .75)
(make-color 'mobg 0.0 .85 .75)
X
X
SHAR_EOF
chmod 0745 Teach/OVL/make-col.lsp ||
echo 'restore of Teach/OVL/make-col.lsp failed'
Wc_c="`wc -c < 'Teach/OVL/make-col.lsp'`"
test 301 -eq "$Wc_c" ||
	echo 'Teach/OVL/make-col.lsp: original size 301, current size' "$Wc_c"
fi
# ============= Teach/OVL/colors.lsp ==============
if test -f 'Teach/OVL/colors.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/OVL/colors.lsp (File already exists)'
else
echo 'x - extracting Teach/OVL/colors.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/OVL/colors.lsp' &&
;;;;
;;;;    colors.lsp
;;;;
;;;;    Display new color combinations.
;;;;    Doesn't work with graph-window-proto, but does with graph-proto
;;;;    (via plot-points).
X
(setf w (plot-points '(0) '(0)))
(send w :use-color t)
(send w :x-axis nil)
(send w :y-axis nil)
(setf rgb '(0 0 0))
(apply #'make-color 'new-color rgb)
(setf red 0)
(setf green 1)
(setf blue 2)
X
(defun change-color (color value)
X  (setf (nth color rgb) value)
X  (free-color 'new-color)
X  (apply #'make-color 'new-color rgb)
X  (send w :back-color 'new-color)
X  (send w :redraw) )
X
(defun color-slider (numpts color title text locate)
X  (let ((dialog 
X	 (interval-slider-dialog '(0 1) :points numpts
X			:action #'(lambda (x) (change-color color x))
X			:title title :text text)))
X    (apply #'send dialog :location locate)
X    (send w :add-subordinate dialog)))
X
(color-slider 101 red "Red" "Red=" '(160 733))
(color-slider 101 green "Green" "Green=" '(421 733))
(color-slider 101 blue "Blue" "Blue=" '(680 733))
X
X
SHAR_EOF
chmod 0745 Teach/OVL/colors.lsp ||
echo 'restore of Teach/OVL/colors.lsp failed'
Wc_c="`wc -c < 'Teach/OVL/colors.lsp'`"
test 984 -eq "$Wc_c" ||
	echo 'Teach/OVL/colors.lsp: original size 984, current size' "$Wc_c"
fi
# ============= Teach/OVL/fun1.lsp ==============
if test -f 'Teach/OVL/fun1.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/OVL/fun1.lsp (File already exists)'
else
echo 'x - extracting Teach/OVL/fun1.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/OVL/fun1.lsp' &&
;
;  various miscellaneous functions 
;
X
(defun sweep (a margin f &rest args)
"Args: a margin  f (&rest args))
Equivalent to the sweep function in S.  Takes 2 two-dimensional
array A, and produces an array of the same size and shape with f
applied to each column of A (margin = 'cols) or each row of A
(margin = 'rows)."
(cond
X  ((eq margin 'cols)
X   (apply #'bind-columns (mapcar f (column-list a))))
X  ((eq margin 'rows)
X   (apply #'bind-rows (mapcar f (row-list a))))))
X
(defun rmel (elmts x)
"Args: (elmts x)
Returns a sublist of x with elements indexed in elmts deleted. elmts
may be a single number if only one element of x is to be removed,
otherwise elmts must be a list."
X  (let* ((z x) 
X        rs)
X    (cond ((numberp elmts) 
X          (setf z (select x (remove elmts (iseq 0 (- (length x) 1))))))
X      (t (setf rs (reverse (sort-data elmts)))
X       (dotimes (i (length elmts))
X         (setf z (select z (remove (nth i rs) (iseq 0 (- (length z) 1))))))))
X  z))
X
(defun substr (string start &optional (length (length string)))
"Args: (string start &optional (length (length string)))
Returns part of a string, starting at the start-th place, and extending
to length places."
X  (subseq string start (min (+ start length) (length string))))
X
X
;;;
;;; toggle-item-proto - creates toggle menu items that show title1 and 
;;;    give action1 if rule is t and title2 and action2 if rule is nil.
;;;
X
(defproto mytoggle-item-proto '(rule title1 action1 title2 action2) 
X  () menu-item-proto)
X
(defmeth mytoggle-item-proto :isnew (rule title1 action1 title2 action2) 
X  (setf (slot-value 'rule) rule)
X  (setf (slot-value 'title1) title1)
X  (setf (slot-value 'title2) title2)
X  (setf (slot-value 'action1) action1)
X  (setf (slot-value 'action2) action2)
X  (call-next-method title1))
X
(defmeth mytoggle-item-proto :update () 
X  (send self :title (if (funcall (slot-value 'rule))
X                        (slot-value 'title1) (slot-value 'title2)))
X  (call-next-method))
X
(defmeth mytoggle-item-proto :do-action () 
X  (if (funcall (slot-value 'rule))
X      (funcall (slot-value 'action1))
X      (funcall (slot-value 'action2))))
X
X
(defun select-list-dialog (items
X                           &key (title "Choose items")
X                           (left-title "Variables")
X                           (right-title "Subset")
X                           (right-length (length items)))
"Args: (items &key title left-title right-title)
Creates a dialog box with a left and right scrolling list.  All items start
in the left list.  Double clicking on an item moves it to the other list.
Returns a list of two lists.  Each list is an index of the items in the
scrolling list, in the order they appear on the screen."
X  (let* ((left-title  (send text-item-proto :new left-title))
X         (right-title (send text-item-proto :new right-title))
X         (left-items (iseq (length items)))
X         (right-items nil)
X         (left-list  (send list-item-proto :new items))
X         (right-list (send list-item-proto :new (repeat "" right-length)))
X         (cancel (send modal-button-proto :new "Cancel"))
X         (ok (send modal-button-proto :new "OK" :action 
X                   #'(lambda () (list left-items right-items) )))
X         (dialog (send modal-dialog-proto :new
X                       (list 
X                        (list title)
X                        (list 
X                         (list left-title left-list)
X                         (list right-title right-list))
X                        (list ok cancel)))))
X    (defmeth left-list :do-action (&optional double)
X      (when (and double (<= (send self :selection) (- (length left-items) 1)))
X       (let* ((sel (select left-items (send self :selection))))
X         (setf left-items (remove sel left-items))
X         (setf right-items (append right-items (list sel))) 
X         (when left-items
X               (mapcar #'(lambda (item j) (send self :set-text j item))
X                       (select items left-items) (iseq (length left-items))))
X         (when (< (length left-items) (length items))
X               (mapcar #'(lambda (j) (send self :set-text j ""))
X                       (iseq (length left-items) (1- (length items)))))
X         (when right-items
X               (mapcar #'(lambda (item j) (send right-list :set-text j item))
X                      (select items right-items) (iseq (length right-items))))
X         )))
X    (defmeth right-list :do-action (&optional double)
X      (when (and double (<= (send self :selection) 
X                            (- (length right-items) 1)))
X       (let* ((sel (select right-items (send self :selection))))
X         (setf right-items (remove sel right-items))
X         (setf left-items (append left-items (list sel))) 
X         (when right-items
X               (mapcar #'(lambda (item j) (send self :set-text j item))
X                       (select items right-items) 
X                       (iseq (length right-items))))
X         (when (< (length right-items) (length items))
X               (mapcar #'(lambda (j) (send self :set-text j ""))
X                       (iseq (length right-items) (1- (length items)))))
X         (when left-items
X               (mapcar #'(lambda (item j) (send left-list :set-text j item))
X                      (select items left-items) (iseq (length left-items))))
X         )))
X    (send dialog :modal-dialog)))
;;;
;;; a scrolling list select item dialog
;;;
(defun list-item-dialog (items &key (title "Select item"))
X  (let* ((chooser (send list-item-proto :new items))
X         (cancel (send modal-button-proto :new "Cancel"))
X         (ok (send modal-button-proto :new "OK" :action
X                   #'(lambda () (send chooser :selection))))
X         (dialog (send modal-dialog-proto :new
X                       (list
X                        (list title)
X                        (list chooser)
X                        (list ok cancel)))))
X        (send dialog :modal-dialog)))
X
(defun backsolve (x y)
"Args:  x  y
Solves the triangular system xb=y for b, where x is an upper triangular 
matrix."
X  (let* ((n (length y))
X         (d (diagonal x))
X         (x (row-list (- (sweep x 'cols #'(lambda (a) (/ a d))) 
X                         (identity-matrix n))))
X         (b (/ y d)))
X   (dotimes (j (1- n))
X            (let* ((nj2 (- n j 2)))
X              (setf (select b nj2) (- (select b nj2) 
X                   (inner-product (select x nj2) b)))))
X    b))
X
X
(defun range (x) (list (min x) (max x)))
X
(defun midrange (x) (* .5 (+ (min x) (max x))))
X
(defun cosangle (a B)
"Args:  (a B)
Returns the cosine of the angle between a vector a and a subspace
spanned by B."
X  (let* ((p (project b :intercept nil)))
X    (cosangle1 a (send p :project a))))
X
(defun cosangle1 (a b)
"Args:  (a b)
Returns the cosine of the angle between two lists or vectors a and b"
X  (/ (inner-product a b) (sqrt (* (inner-product a a) (inner-product b b)))))
X
(defun angle (a b)
"Returns the angle between vector a and subspace b in degrees"
X  (* 180 (acos (cosangle a b)) (/ pi)))
X
(defun hnorm-quant (p)
"Args: p
Returns the p-th quantile of the standard half normal distribution."
X  (normal-quant (+ .5 (* .5 p))))
X
(defmeth scatterplot-proto :add-boxplot (y &key (x 1.0) (width 1.0) (draw t)
X                                           (range 1.5))
"Modified version of the standard boxplot to put in outliers, points beyond 
range*iq-range above or below the median, explicitly."
X  (unless (= 2 (send self :num-variables)) (error "only works for 2D plots"))
X  (let* ((half-box (* 0.4 width))
X         (half-foot (* 0.1 width))
X         (fiv (fivnum+ y :range range))
X         (low (select fiv 0))
X         (q1 (select fiv 1))
X         (med (select fiv 2))
X         (q3 (select fiv 3))
X         (high (select fiv 4)))
X    (send self :plotline (- x half-foot) low  (+ x half-foot) low  nil)
X    (send self :plotline (- x half-foot) high (+ x half-foot) high nil)
X    (send self :plotline x low x q1   nil)
X    (send self :plotline x q3  x high nil)
X    (send self :plotline (- x half-box) q1  (+ x half-box) q1  nil)
X    (send self :plotline (- x half-box) med (+ x half-box) med nil)
X    (send self :plotline (- x half-box) q3  (+ x half-box) q3  nil)
X    (send self :plotline (- x half-box) q1  (- x half-box) q3  nil)
X    (send self :plotline (+ x half-box) q1  (+ x half-box) q3  nil)
X    ;; *** Here are two versions that allow linking to work properly.
X    ;; ***
X    ;; *** this version uses an undocumented feature called masking.
X    ;; *** It is like removing except it is local to a plot, not linked.
X    ;; *** I never could decide if it was worth using, so I did not
X    ;; *** document it. It MAY not work properly.
X    (let ((np (send self :num-points)))
X      (send self :add-points (repeat x (length y)) y :draw nil)
X      (send self :point-masked (+ np (iseq (length y))) (< low y high)))
X    ;; *** Here is an alternate version that just adds all the points
;    (send self :add-points (repeat x (length y)) y :draw draw)
X    (if draw (send self :redraw-content))))
X
(defun fivnum+ (x &key (range 1.5))
"Returns a list of six items as follows: low-fence q1 med q3 high-fence
outliers, where outliers is a list of values outside the fences.  Range
determines the fences; the usual value is 1.5*iq-range."
X  (flet ((quant (x p)
X                (let* ((n (length x))
X                       (np (* p (- n 1)))
X                       (low (floor np))
X                       (high (ceiling np)))
X                      (/ (+ (select x low) (select x high)) 2))))
X    (let* ((x (sort-data x))
X           (n (- (length x) 1))
X           (q1 (quant x .25))
X           (q3 (quant x .75))
X           (q2 (quant x .50))
X           (r (* range (- q3 q1)))
X           (low-ind (cond ((= range 0) 0)
X                            ((<= (- q1 r) (select x 0)) 0)
X                            (t (do ((j 0 (1+ j)))
X                                   ((and (< (select x j) (- q1 r))
X                                        (>= (select x (1+ j)) (- q1 r)))
X                                    (+ j 1))))))
X           (high-ind (cond ((= range 0) n)
X                           ((>= (+ q3 r) (select x n)) n)
X                           (t (do ((j n (- j 1)))
X                                  ((and (> (select x j) (+ q3 r))
X                                        (<= (select x (- j 1)) (+ q3 r)))
X                                   (- j 1)))))))
X          (list (select x low-ind) q1 q2 q3 (select x high-ind)
X                (cond ((and (= low-ind 0) (= high-ind n)) nil)
X                       ((= low-ind 0) (select x (iseq (1+ high-ind) n)))
X                       ((= high-ind n) (select x (iseq  low-ind)))
X                      (t (append (select x (iseq (1+ high-ind) n))
X                                 (select x (iseq low-ind)))))))))
X
X
(defun boxplot (data &key (title "Box Plot") (range 1.5)(show nil))
"Args: (data &key (title \"Box Plot\"))
DATA is a sequence, a list of sequences or a matrix. Makes a boxplot of the
sequence or a parallel box plot of the sequences in the list or the columns
of the matrix.  The range determines the location of the outer fences, and is
the same as in S." 
X  (let ((p (send scatterplot-proto :new 2 :title title :show nil)))
X    (setq data 
X          (cond ((matrixp data) (column-list data))
X                ((or (not (listp data)) (numberp (car data))) (list data))
X                (t data)))
X        (let ((range (get-nice-range (min data) (max data) 4)))
X          (send p :range 1 (nth 0 range) (nth 1 range))
X          (send p :y-axis t nil (nth 2 range)))
X    (send p :range 0 0 (1+ (length data)))
X    (dotimes (i (length data))
X          (send p :add-boxplot (nth i data) :x (1+ i)))
X    (when show (send p :show-window))
X    p))
X
X
;;; geometric mean
X
(defun geometric-mean (x) 
"Args:  (x)
Returns the geometric mean if the elements of x are strictly positive, and
returns nil otherwise."
X  (if (> (min x) 0) (exp (mean (log x))) nil))
X
X
;;;
;;; project prototype
;;;
X
(defproto project-proto 
X  '(x q r basis included weights intercept tol)
X  ()
X  *object*
X  "Orthogonal Projections")
X
(defun project (x  &key  
X                   (intercept t) (weights nil wset) (pweights nil pset)
X                   (included t iset)
X                   (tol 10e-7))
X
"Args:  (x  &key  
X            (intercept t) weights pweights
X            (included t iset)
X            (tol 10e-7))
Computes the projection on the column space of x (with a column of
1s appended if constant is t, usings weights for a weight vector, and
excluding rows according to the included vector.  The method of computing 
is the qr factorization by default."
X  (let* ((x (cond
X              ((matrixp x) x)
X              ((vectorp x) (bind-columns (coerce x 'list)))
X              ((and (consp x) (consp (first x))) (apply #'bind-columns x))
X              (t (bind-columns x)))) 
X         (n (array-dimension x 0))
X         (weights (cond
X                   ((and pset (= (length pweights) n)) pweights)
X                   ((and wset (= (length  weights) n)) weights)
X                   (t (repeat 1 n))))
X         (included (if iset included (repeat t n)))
X         (h (send project-proto :new x intercept weights included tol)))
X    h))
X
(defmeth project-proto :isnew (x  intercept weights included tol)
X  (setf (slot-value 'intercept) intercept)
X  (setf (slot-value 'weights) weights)
X  (setf (slot-value 'included) included)
X  (setf (slot-value 'tol) tol)
X  (send self :x x))
X
(defmeth project-proto :compute ()
X  (let* ((included (send self :included))
X         (inc (which included))
X         (not-inc (which (mapcar 'not included)))
X         (sqrt-wt (sqrt (send self :weights)))
X         (x (sweep (send self :x) 'cols #'(lambda (a) (* sqrt-wt a))))
X         (intercept (send self :intercept))
X         (size (array-dimensions x))
X         (basis (if intercept (combine 0 (1+ (iseq (select size 1))))
X                    (iseq (select size 1))))
X         qr) 
X    (when intercept (setf x (bind-columns sqrt-wt x)))
X    (setf qr (send self :get-projection x inc basis)) 
X    (setf (select x inc (first qr)) (second qr))
X    (when not-inc
X            (setf (select x not-inc (first qr)) 
X                  (matmult (select x not-inc (first qr)) 
X                           (inverse (third qr)))))
X    (setf (slot-value 'q) (select x (iseq 0 (1- (nth 0 size))) (first qr)))
X    (setf (slot-value 'r) (third qr))
X    (setf (slot-value 'basis) 
X          (if intercept (rest (- (first qr) 1)) (first qr)))
X    (slot-value 'basis)))
X
(defmeth project-proto :get-projection (x inc basis)
"This method checks for zero pivots, and, if any are found, deletes them and
recursively calls itself."
X  (let* ((qr (qr-decomp (select x inc basis)))
X         (tol (send self :tol))
X         (bad-pivot (position tol (abs (diagonal (second qr))) :test #'>)))
X    (cond ((null bad-pivot) (cons basis qr))
X          (t (send self :get-projection x inc 
X                        (select basis (remove bad-pivot 
X                                              (iseq (length basis))))))))) 
X
(defmeth project-proto :needs-computing (&optional set)
X  (if set (setf (slot-value 'q) nil))
X  (null (slot-value 'q)))
X
(defmeth project-proto :q (&optional firstp)
"Computes the matrix consisting of the firstp columns of Q."
X  (when (send self :needs-computing) (send self :compute))
X  (let* ((q (slot-value 'q))
X         (firstp (if firstp 
X                  (+ (length (which (< (send self :basis) firstp)))
X                     (if (send self :intercept) 1 0)) firstp)))
X    (if firstp
X        (select q (iseq 0 (1- (array-dimension q 0))) (iseq 0 (1- firstp)))
X        q)))
X
(defmeth project-proto :r (&optional firstp)
X  "Returns upper-triangular matrix for firstp columns."
X  (when (send self :needs-computing) (send self :compute))
X  (let* ((r (slot-value 'r))
X         (firstp (if firstp 
X                     (+ (length (which (< (send self :basis) firstp)))
X                        (if (send self :intercept) 1 0)) firstp)))
X      (if firstp (select r (iseq 0 (1- firstp)) (iseq 0 (1- firstp)))
X      r)))
X
(defmeth project-proto :project (y &optional firstp)
"Computes QQ'y.  Since QR is the factorization of W^{1/2}X, we want to compute
here W^{-1/2}QQ^TWY."
X  (let* ((w (sqrt (send self :weights)))
X         (q (send self :q firstp))
X         (y (* y (mapcar #'(lambda(i) (if i 1 0)) (send self :included)))))
X    (/ (matmult q (matmult (transpose q) (* w y))) w)))
X
(defmeth project-proto :rank (&optional firstp)
"Message args: ($optional firstp)
Returns the dimension of the space spanned by the firstp columns of X and by the constant column if intercept is t, or the dimension of R(1,X) by 
default."
X   (let ((basis (send self :basis))
X         (int (if (send self :intercept) 1 0)))
X        (if firstp (+ int (length (which (if-else (< basis firstp) t nil))))
X                   (+ int (length basis)))))
X
(defmeth project-proto :p2.1 (y firstp &optional secondp)
"Computes (Q2Q2' - Q1Q1')y."
X  (- (send self :project y secondp) (send self :project y firstp)))
X
(defmeth project-proto :residuals (y &optional (firstp nil))
"Computes (I - QQ')y"
X  (- y (send self :project y firstp)))
X
(defmeth project-proto :num-inc ()
X  (length (which (send self :included))))
X
(defmeth project-proto :residual-sum-of-squares (y &optional (firstp nil))
X  (sum (^ (select (send self :residuals y firstp) 
X                  (which (send self :included))) 2)))
X
(defmeth project-proto :sigma-hat (y &optional (firstp nil))
X  (sqrt (/ (send self :residual-sum-of-squares y firstp)
X           (- (send self :num-inc) (send self :rank firstp)))))
X
(defmeth project-proto :studentized-residuals (y &optional (firstp nil))
X  (let* ((res (send self :residuals y firstp))
X         (lev (send self :leverages firstp))
X         (sig (send self :sigma-hat y firstp))
X         (inc (send self :included)))
X        (if-else inc
X                 (/ res (* sig (sqrt (pmax .00001 (- 1 lev)))))
X                 (/ res (* sig (sqrt (+ 1 lev)))))))
X
(defmeth project-proto :externally-studentized-residuals (y &optional firstp)
X  (let* ((res (send self :studentized-residuals y firstp))
X			(np (- (send self :num-inc) (send self :rank firstp))))
X		(if-else (send self :included)
X					(* res (sqrt (/ (- np 1) (- np (^ res 2))))) res)))
X
(defmeth project-proto :qty (y &optional (firstp nil))
"Computes Q'y, properly weighted."
X  (let* ((w (sqrt (send self :weights)))
X         (q (send self :q firstp)))
X    (matmult (transpose q) (* w (* y (if-else (send self :included) 1 0))))))
X
(defmeth project-proto :coef-estimates (y &optional firstp)
"Computes coefficient estimates by backsolving."
X   (backsolve (send self :r firstp) (send self :qty y firstp)))
X
(defmeth project-proto :projection-matrix (&key firstp case-list)
X  (let* ((q (send self :q firstp)))
X    (when case-list (setf q (select q case-list 
X                                    (iseq 0 (1- (array-dimension q 1))))))
X    (matmult q (transpose q))))
X
(defmeth project-proto :leverages (&optional firstp)
X  (let* ((q (send self :q firstp)))
X    (mapcar #'(lambda (a) (sum (^ a 2))) (coerce q 'list))))
X
(defmeth project-proto :x (&optional new-x)
"Message args: (&optional new-x)
With no argument returns the x matrix as supplied to m. With an argument
NEW-X sets the x matrix to NEW-X and recomputes the estimates."
X  (when new-x
X        (setf (slot-value 'x)
X               (cond
X                 ((matrixp new-x) new-x)
X                 ((vectorp new-x) (apply #'bind-columns (coerce new-x 'list)))
X                 ((consp new-x) (apply #'bind-columns new-x))))
X        (send self :needs-computing t))
X   (slot-value 'x))
X
(defmeth project-proto :intercept (&rest args)
"Message args: (&optional new-intercept)
With no argument returns T if the model includes an intercept term, nil if
not. With an argument NEW-INTERCEPT the model is changed to include or exclude
an intercept, according to the value of NEW-INTERCEPT, and estimates are
recomputed."
X  (when args 
X        (setf (slot-value 'intercept) (car args))
X        (send self :needs-computing t))
X  (slot-value 'intercept))
X
(defmeth project-proto :tol (&optional tol)
"Message args: (&optional tol)
With no argument returns the tolerance."
X  (when tol (setf (slot-value 'tol) tol))
X  (slot-value 'tol))
X
(defmeth project-proto :weights (&optional new-w)
"Message args: (&optional new-w)
With no argument returns the weight sequence as supplied to m; NIL means
ans unweighted model. NEW-W sets the weights sequence to NEW-W and
recomputes the estimates."
X  (when new-w (setf (slot-value 'weights) new-w) (send self :needs-computing t))
X  (slot-value 'weights))
X
(defmeth project-proto :pweights (&optional (new nil set))
X  (if set (send self :weights new) (send self :weights)))
X
(defmeth project-proto :basis ()
"Message args: ()
Returns the indices of the linearly independeent columns of X."
X  (slot-value 'basis))
X
(defmeth project-proto :included (&optional new-included)
"Message args: (&optional new-included)
With no argument,  NIL means a case is not used in calculating
estimates, and non-nil means it is used.  NEW-INCLUDED is a sequence
of length of y of nil and t to select cases.  Estimates are recomputed."
X  (when (and new-included 
X             (= (length new-included) (length (slot-value 'included)))) 
X        (setf (slot-value 'included) new-included) 
X        (send self :needs-computing t))
X  (slot-value 'included))
X
(defmeth project-proto :toggle-cases (&optional (idnum nil))
"Message args: idnum, a list of case numbers
Deletes/restores specified cases.  If idnum is nil, all cases are restored."
(let* (included)
X  (cond
X    ((null idnum)
X     (setf included (mapcar 'not (iseq 0 (1- (send self :num-cases))))))
X    (t
X     (setf included (send self :included))
X     (dolist (i (coerce idnum 'list))
X             (setf (nth i included) (not (nth i included))))))
X  (send self :included included)))
X
(defmeth project-proto :num-cases ()
X  (array-dimension (send self :q) 0))
X
;;;
;;; copied from glim.lsp
;;;
X
(defun indicators (x &key (drop-first t) (test #'eql))
"Args: (x &key (drop-first t) (test #'eql))
Returns a list of indicators sequences for the levels of X. TEST is
used to check equality of levels. If DROP-FIRST is true, the indicator
for the first level is dropped."
X  (let ((levels (remove-duplicates (coerce x 'list) :test test)))
X    (mapcar #'(lambda (lev) (if-else (map-elements test lev x) 1 0))
X            (if drop-first (rest levels) levels))))
X
(defun rlevel-names (x &key (prefix "") (drop-first t) (test #'eql))
"Args: (x &key (prefix \"\") (drop-first t))
Constructs name strings using unique levels in X and PREFIX."
X  (let ((levels (remove-duplicates (coerce x 'list) :test test)))
X    (mapcar #'(lambda (x) (format nil "~a[~a]" prefix x))
X            (if drop-first (rest levels) levels))))
X
(defun make-lists (x names)
"Functions args:  x names
x is a list of lists of the same length as names.  Creates lists with names
given by the names keyword corresponding to the columns of x."
X  (mapcar #'(lambda (x n) (set (intern (string-upcase n)) (coerce x 'list))) 
X          x names))
X
;;;
;;;  Specialized transformation functions
;;;
X
(defun xlogx (x)
"Function args: (x)   
If x is strictly positive, this function returns xlog(x).  For use in power
transformations of predictors via Box-Tidwell method."
X  (when (<= (min x) 0)
X        (message-dialog "Values must all be positive")
X        (return-from xlogx))
X  (* x (log x)))
X
(defun box-cox-power (y p &key (included (iseq (length y))))
"Function args: (data power)   
If y is strictly positive, this function returns the modified power
transformation of data.  See Atkinson, 1985, Plots, Transformations and
Regression, page 87, eq. 6.2.6."
X  (when (<= (min y) 0)
X        (message-dialog "Values must all be positive")
X        (return-from box-cox-power))
X  (let ((gm (geometric-mean (select y included))))
X       (cond ((< (abs p) .0001) (* gm (log y))) 
X             (t (/ (- (^ y p) 1) (* p (^ gm (- p 1))))))))
X
(defun folded-power (y p &key (included (iseq (length y))))
"Function args: (data power)   
If y is strictly bounded in 0,1, this function returns the normalized
folded power transformation of data.  See Cook and Weisberg, 1982, 
Residuals and Influence in Regression, eq. 2.4.11."
X  (when (or (<= (min y) 0) (>= (max y) 1))
X        (message-dialog "Values must all be between 0 and 1")
X        (return-from folded-power))
X  (let ((1-y (- 1 y)))
X       (cond ((< (abs p) .001) 
X              (* (geometric-mean (* y 1-y)) (log (/ y 1-y))))
X             (t 
X              (/ (- (^ y p) (^ 1-y p)))))))
X
(defun modulus-transform (y p &key (included (iseq (length y))))
"Function args: (data power)   
This function returns the normalized modulus
transformation of data.  See Cook and Weisberg, 1982, Residuals and Influence
in Regression, eq. 2.4.10."
X  (let* ((sign (if-else (< y 0) -1 1))
X		   (ay1 (+ 1 (abs y)))
X		   (gm (geometric-mean ay1)))
X       (cond ((< (abs p) .001) 
X              (* sign gm (log ay1)))
X             (t 
X				  (/ (* sign (- (^ ay1 p) 1))
X					  (* p (^ gm (- p 1))))))))
X
(defun power-constructed-variable (y &key (power 1) (shift 0)
X                                     (included (iseq (length y))))
"Args:  (y &key (power 1) (shift 0) (included (iseq (length y))))
Returns the score vector for testing Lambda = p in Box-Cox power 
transformation of y.  Reference:  Atkinson (1985), Plots, Transformations and
Regression, page 99."
X  (when (<= (min (+ y shift)) 0)
X        (message-dialog "Values must all be positive")
X        (return-from power-constructed-variable))
X  (let ((y (+ y shift))
X        (gm (geometric-mean (select y (which included))))
X        (p power))
X       (cond ((< (abs p) .0001)
X              (* gm (log y) (- (* .5 (log y)) (log gm))))
X             (t (- (/ (* (^ y p) (log y)) (* p (^ gm (- p 1))))
X                   (/ (* (- (^ y p) 1) (+ (/ p) (log gm)))
X                      (* p (^ gm (- p 1)))))))))
X
(defun scale-constructed-variable (y &key (shift 0) (power 1) 
X                                     (included (iseq (length y))))
"Args:  (y &key (shift 0) (power 1) (included (iseq (length y))))
Returns the score vector for testing shift = c in Box-Cox power 
transformation of (y - shift).   Reference:  Atkinson (1985), 
Plots, Transformations and Regression, page 185, eq 9.1.3."
X  (when (<= (min (+ y shift)) 0)
X        (message-dialog "Values must all be positive")
X        (return-from scale-constructed-variable))
X  (let* ((ys (select y (which included)))
X         (gm (geometric-mean (+ ys shift)))
X         (hminv (/  (sum (/ 1 ys)) (length ys)))
X         (ws (box-cox-power (+ y shift) power :included included)))
X       (- (^ (/ (+ y shift) gm) (- power 1)) (* (- power 1) ws hminv))))
X
;;;
;;;  auxillary functions used by the methods in file reg3.lsp
;;;
X
(defun read-list-columns (data p)
"Function args:  data p
Equivalent to the read-data-columns function, except that data is a list of
numbers."
X   (transpose (split-list data p)))
X
;;;
;;;  two utilities to write a to a file, and then
;;;  retrieve it from the file
;;;  used by :ares-replay
X
(defun write-to-file (a &key file)
"Opens a file file, and writes a to it."
X  (let* ((file (cond ((stringp file) file)
X                     (t
#+macintosh (set-file-dialog "Save in file...")
#+msdos (set-file-dialog "Save in file...")
#+X11 (get-string-dialog "Save in file..."))))
X         f)
X        (when file
X              (setf f (open file :direction :output))
X              (prin1 a f)
X              (close f)
X              file)))
X
(defun read-from-file (&key file)
"Opens a file file, and writes a to it."
X  (let* ((file (cond ((stringp file) file) (t (open-file-dialog))))
X         f a)
X        (when file
X              (setf f (open file :direction :input))
X              (setf a (read f))
X              (close f)
X              a)))
X
(defun outlier-pvalue (t df n)
"Function args:  (t df n)
Uses the Bonferroni inequality to approximate the p-value of the t-test that
the largest externally studentized residual corresponds to an outlying case."
X  (min 1 (* n (* 2 (- 1 (t-cdf (abs t) df))))))
X
(defun t-pvalue (z &optional (df 10000) (what 'twotail))
X  (case what
X        (twotail (* 2 (- 1 (t-cdf (abs z) df))))
X        (uppertail (- 1 (t-cdf z df)))
X        (lowertail (t-cdf z df))))
X
;;;
;;;  Golden Section Search algorithm
;;;
(defun golden (g a b &key (epsilon .01) (min t))
"Function args: (g a b &key (epsilon .01) (min nil) (plot nil))
Golden section search.  Algorithm 4.5.1 from R. Thisted (1988), Elements of 
Statistical Computing, Chapman-Hall, p. 203.  Finds the maximum of a function g 
of a single parameter unless :min is t; then, it finds the minimum." 
X  (let* ((alpha (/ (- 3 (sqrt 5)) 2))
X         (f (if min #'(lambda (a) (- (funcall g a)))
X                    #'(lambda (a)    (funcall g a))))
X         (L a)
X         (U b)
X         (W (- U L))
X         (t1 (+ L (* 1 alpha W)))
X         (t2 (- U (* 1 alpha W)))
X         (f1 (funcall f t1))
X         (f2 (funcall f t2))
X         (vals (list t1 t2))
X         (crit (list f1 f2)))
X        (do () ((< (abs (- t1 t2)) epsilon))
X            (cond ((< f1 f2)
X                   (setf L t1)
X                   (setf t1 t2)
X                   (setf f1 f2)
X                   (setf W (- U L))
X                   (setf t2 (- U (* alpha W)))
X                   (setf f2 (funcall f t2))
X                   (setf vals (cons t2 vals))
X                   (setf crit (cons f2 crit)))
X                  (t
X                   (setf U t2)
X                   (setf t2 t1)
X                   (setf f2 f1)
X                   (setf W (- U L))
X                   (setf t1 (+ L (* alpha W)))
X                   (setf f1 (funcall f t1))
X                   (setf vals (cons t1 vals))
X                   (setf crit (cons f1 crit)))))
X        (when min (setf crit (- crit)))
X         (list (* .5 (+ t1 t2)) vals crit)))
SHAR_EOF
chmod 0745 Teach/OVL/fun1.lsp ||
echo 'restore of Teach/OVL/fun1.lsp failed'
Wc_c="`wc -c < 'Teach/OVL/fun1.lsp'`"
test 29859 -eq "$Wc_c" ||
	echo 'Teach/OVL/fun1.lsp: original size 29859, current size' "$Wc_c"
fi
# ============= Teach/OVL/reg1.lsp ==============
if test -f 'Teach/OVL/reg1.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/OVL/reg1.lsp (File already exists)'
else
echo 'x - extracting Teach/OVL/reg1.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/OVL/reg1.lsp' &&
;;;;
;;;; reg1.lsp XLISP-STAT regression model proto and methods
;;;; This code Copyright (c) 1992 by Sanford Weisberg and R. Dennis Cook
;;;; XLISP-STAT 2.1 Copyright (c) 1990, by Luke Tierney
;;;; Additions to Xlisp 2.1, Copyright (c) 1989 by David Michael Betz
;;;; You may give out copies of this software; for conditions see the file
;;;; COPYING included with this distribution.
;;;;
;;;;
X
;;;
;;;   Substitute for the original regression-model function.
;;;   This is identical to the original except that it adds three keywords:
;;;   :data (list of lists) gives additional columns of data, accessed for
;;;         plotting
;;;   :data-names (list of strings) gives the names for the lists in data
;;;   :menu (&optional "Graphics") puts a menu in the
;;;         menu bar if t or if a title is supplied.  Default is nil.
X
(defun regression-model (x y &rest args)
"Args: (x y &key (intercept T) (print T) weights 
X          included predictor-names response-name case-labels)
XX           - list of independent variables or X matrix
Y           - dependent variable.
INTERCEPT   - T to include (default), NIL for no intercept
PRINT       - if not NIL print summary information
WEIGHTS     - if supplied should be the same length as Y; error variances are
X               assumed to be inversely proportional to WEIGHTS
PREDICTOR-NAMES
RESPONSE-NAME
CASE-LABELS - sequences of strings or symbols.
INCLUDED    - if supplied should be the same length as Y, with elements nil
X              to skip a in computing estimates (but not in residual analysis). 
DATA        - additional list of data used in plotting
DATA-NAMES  - names for the data columns
MENU        - adds a menu to the menu bar if t or a string.
Returns a regression model object. To examine the model further assign the
result to a variable and send it messages."
X  (apply #'send regression-model-proto :new :x x :y y args))
X
;;;
;;;  overrides for standard methods:  initialization has been moved from
;;;  the calling function to the :isnew method, to make writing descendants
;;;  easier
;;;
X
(defmeth regression-model-proto :isnew (&key x y 
X                                          (intercept t)
X                                          weights
X                                          included
X                                          (print (and x y))
X                                          predictor-names
X                                          response-name
X                                          case-labels
X                                          pweights
X                                          data
X                                          graphics-menu
X                                          menu
X                                          data-names) 
"Override for the standard method to define slots in the method, not the
calling function.  This then inherits to derived methods."
X    (when x (send self :x x))
X    (when y (send self :y y))
X    (send self :intercept intercept)
X    (send self :weights weights)
X    (send self :pweights pweights)
X    (send self :included included)
X    (when x (send self :predictor-names predictor-names))
X    (send self :response-name response-name)
X    (when case-labels (send self :case-labels case-labels))
X    (send self :data data)
X    (send self :data-names data-names)
X    (when print (send self :display))
X    (send self :add-slot 'graphs)
X    (send self :add-slot 'function-list)
X    (send self :add-slot 'graphics-items)
X    (send self :add-slot 'added-variables)
X    (when menu (send self :menu (if (stringp menu) menu "Graphics")))
X    (when graphics-menu (send self :menu 
X                   (if (stringp graphics-menu) graphics-menu "Graphics"))))
X
;;;
;;;  :x method --- moves the checking for a matrix, etc. to the method.
;;;  allows :x to be nil for nonlinear regression compatability
;;;
(defmeth regression-model-proto :x (&optional (x nil set))
"Message args: (&optional (new-x nil set))
With no argument returns the x matrix as supplied to m. With an argument
NEW-X x to NEW-X and recomputes the estimates."
X  (when set 
X      (let ((x (cond
X                ((matrixp x) x)
X                ((vectorp x) (list x))
X                ((and (consp x) (numberp (car x))) (list x))
X                (t x))))
X           (setf (slot-value 'x) (cond ((matrixp x) x)
X                                       ((null x) nil)
X                                       (t (apply #'bind-columns x)))))
X      (send self :needs-computing t))
X  (slot-value 'x))
;;;
;;;  :case-labels this method is called only if labels are provides, else
;;;  sets the slot 'case-labels to nil.
;;;
(defmeth regression-model-proto :case-labels (&optional (labels nil set))
"Message args: (&optional labels)
With no argument returns the case-labels or nil if not set. 
LABELS sets the labels."
X  (if set (setf (slot-value 'case-labels) 
X                (if labels (mapcar #'string labels) labels)))
X  (slot-value 'case-labels))
X
;;;
;;;  :included method always computes a list of t, and puts it in a slot
;;;  rather than computing it on the fly.  
;;;
(defmeth regression-model-proto :included (&optional (new nil set))
"Message args: (&optional (new nil set))
With no argument,  NIL means a case is not used in calculating estimates, and non-nil means it is used.  NEW-INCLUDED is a sequence of length of y of nil and t to select cases.  Estimates are recomputed."
X  (when set (setf (slot-value 'included) 
X                (if new new (repeat t (send self :num-cases))))
X        (send self :needs-computing t))
X  (if (null (slot-value 'included)) (repeat t (send self :num-cases))
X      (slot-value 'included)))
X
;;;
;;; display method override:  added the response name, and labels columns
;;;
X
(defmeth regression-model-proto :display (&key (estimates t) (anova t))
X       (if estimates (send self :display-estimates))
X       (if anova (send self :display-anova)))
X
(defmeth regression-model-proto :display-estimates ()
"Message args: ()
Prints the least squares regression summary. Variables not used in the fit
are marked as aliased."
X  (let* ((coefs (coerce (send self :coef-estimates) 'list))
X         (se-s (send self :coef-standard-errors))
X         (x (send self :x))
X         (r-name (send self :response-name))
X         (p-names (send self :predictor-names)))
X       (if (send self :weights) 
X        (format t "~%Weighted Least Squares, Response is ~a:~2%" r-name)
X        (format t "~%Least Squares Estimates, Response is ~a:~2%" r-name))
X        (format t 
X          "Label                    Estimate   Std. Error      t-value~%")
X    (when (send self :intercept)
X          (format t "Constant               ~10g   ~10g   ~10g~%"
X                  (car coefs) (car se-s) 
X                  (if (>  (car se-s) 0)
X                      (/ (car coefs) (car se-s)) nil))
X          (setf coefs (cdr coefs))
X          (setf se-s (cdr se-s)))
X    (dotimes (i (array-dimension x 1)) 
X             (cond 
X               ((member i (send self :basis))
X                (format t "~22a ~10g   ~10g   ~10g~%"
X                        (select p-names i) (car coefs) (car se-s)
X                        (if (>  (car se-s) 0)
X                        (/ (car coefs) (car se-s)) nil))
X                (setf coefs (cdr coefs) se-s (cdr se-s)))
X               (t (format t "~22a    aliased~%" (select p-names i)))))
X    (format t "~%")
X    (when (send self :intercept)
X      (format t "R Squared:             ~10g~%" (send self :r-squared)))
X    (format t "Sigma hat:             ~10g~%" (send self :sigma-hat))
X    (format t "Number of cases:       ~10d~%" (send self :num-cases))
X    (if (/= (send self :num-cases) (send self :num-included))
X        (format t "Number of cases used:  ~10d~%" (send self :num-included)))
X    (format t "Degrees of freedom:    ~10d~%" (send self :df))))
X
X
(defmeth regression-model-proto :display-anova ()
"Message args: ()
Prints the least squares regression anova table."
X  (let* ((ssreg (- (send self :total-sum-of-squares)
X                  (send self :residual-sum-of-squares)))
X        (dfreg (length (send self :basis)))
X        (msreg (/ ssreg dfreg))
X        (rss (send self :residual-sum-of-squares))
X        (mse (/ rss (send self :df)))
X        (f (/ msreg mse))
X        (p-value (- 1 (f-cdf f dfreg (send self :df)))))
X    (format t "~%Summary Analysis of Variance Table~%")
X    (format t "Source         df          SS          MS         F   p-value~%")
X    (format t "Regression  ~5d ~11g ~11g ~9,2f ~9,4f~%"
X            dfreg ssreg msreg f p-value)
X    (format t "Residual    ~5d ~11g ~11g~%" (send self :df) rss mse)))
X
X
;; A variant of this method should work for any object whose slot values
;; have valid printed representations.  Override for standard method
X
(defmeth regression-model-proto :save ()
X  (let* ((proto (slot-value 'proto-name))
X         (slots (send self :own-slots))
X          values)
X        (setf slots (remove 'graphics-menu slots))
X        (setf slots (remove 'graphics-items slots))
X        (setf slots (remove 'graphs slots))
X        (setf slots (remove 'function-list slots))
X        (setf values (mapcar #'slot-value slots))
X    `(let ((object (make-object ,proto))
X      (slots ',slots)
X      (values ',values))
X       (flet ((add-slot (s v) (send object :add-slot s v)))
X    (mapcar #'add-slot slots values))
X       object)))
X
;;;
;;; override for total sum of squares method, so it works with :intercept nil
;;;
X
(defmeth regression-model-proto :total-sum-of-squares ()
X  (if (send self :needs-computing) (send self :compute))
X  (if (send self :intercept) (slot-value 'total-sum-of-squares)
X      (sum (* (if (send self :weights) (send self :weights) 1)
X              (^ (* (send self :y)
X                    (if-else (send self :included) 1 0)) 2)))))
X
;;;   New methods
X
;;;
;;;  This method writes a file that can be read by make-reg.
;;;
X
(defmeth regression-model-proto :save-reg ()
"Method args: ()
This method saves a data file that can be read in by make-reg."
X  (let* ((proto (slot-value 'proto-name))
X         (name (if (send self :menu) (send (send self :menu) :title) "reg"))
X         (data (append
X                  (mapcar #'(lambda (a) (coerce a 'list)) 
X                          (column-list (send self :x)))
X                  (list (send self :y))
X                  (send self :data)))
X         (data-names (send self :names :response t)))
X    `(let ((data ',data)
X           (data-names ',data-names)
X           (type ',proto)
X           (name ,name))
X          (make-reg :data data :data-names data-names :type type :menu name))))
X
(defmeth regression-model-proto :save-to-file (&optional file)
X  (write-to-file (send self :save-reg) :file file :suffix ".lsp"))
X
(defmeth regression-model-proto :data-names (&optional (new nil set))
"Message args: (&optional (names nil set))
With no argument returns the data names. NAMES sets the names."
X  (when (null (send self :has-slot 'data-names)) 
X        (send self :add-slot 'data-names))
X  (when set (send self :add-slot 'data-names (mapcar #'string new)))
X  (let* ((p (length (send self :data))))
X        (cond ((null p) nil)
X              ((= p (length (slot-value 'data-names))) 
X               (slot-value 'data-names))
X              (t (mapcar #'(lambda (j) (format nil "Data~a" j)) (iseq p))))))
X
(defmeth regression-model-proto :data (&optional (new nil set))
X  (when (null (send self :has-slot 'data)) (send self :add-slot 'data))
X  (when set (send self :add-slot 'data 
X                  (cond ((consp new) new)
X                        ((matrixp new) (column-list new)))))
X  (slot-value 'data))
X
(defmeth regression-model-proto :names (&key (response nil))
X  (append (send self :predictor-names) 
X           (if response (list (send self :response-name)))
X           (send self :data-names)))
X
(defmeth regression-model-proto :variables (&key (response nil))
X  (append (column-list (send self :x)) (if response (list (send self :yvar)))
X          (send self :data)))
X
;;;
;;;  additional methods to make compatible with glim-proto
;;;
(defmeth regression-model-proto :pweights (&optional (new nil set))
X  (when set (send self :weights new)) (slot-value 'weights))
X
(defmeth regression-model-proto :deviance ()
X  (send self :residual-sum-of-squares))
X
(defmeth regression-model-proto :verbose (&rest args ) ())
X
(defmeth regression-model-proto :fit-means () (send self :fit-values))
X
(defmeth regression-model-proto :recycle (&optional set) ())
X
(defmeth regression-model-proto :yvar (&optional new-y) (send self :y new-y))
X
(defmeth regression-model-proto :verbose (&optional new) ())
X
;;;
;;;  Compute a linear combination of estimates and its standard error
;;;
X
(defmeth regression-model-proto :lin-combination (&rest x)
"
Message args: (x)
Computes x'betahat and its standard-error."
X  (sum (* x (send self :coef-estimates))))
X
(defmeth regression-model-proto :sefit (&rest x &key (weight 1))
X  (* (send self :sigma-hat) (/ (sqrt weight))
X     (sqrt (matmult x (send self :xtxinv) x))))
X
(defmeth regression-model-proto :sepred (&rest x &key (weight 1))
X  (* (send self :sigma-hat) (/ (sqrt weight))
X     (sqrt (+ 1 (matmult x (send self :xtxinv) x)))))
X
;;;  
;;; squared residuals for use in heteroscedasticity score test
;;;
X
(defmeth regression-model-proto :residuals-squared ()
"Message args: ()
Returns n*res^2/sum(res^2)."
X  (/ (* (send self :num-included) (^ (send self :residuals) 2))
X     (send self :residual-sum-of-squares)))
X
;;
;;  quantiles with some points not included
;;
X
(defmeth regression-model-proto :quantiles (&key (x (send self :yvar))
X  (quantile-function #'normal-quant))
"
Message args: (&key (x (send self :yvar))
X                         (quantile-function #'normal-quant))
Returns the quantile-function quantiles of x, ordered according
to x, with cases with included nil set to a small value."
X  (let* ((ind (which (send self :included)))
X         (z (rank (select x ind)))
X         (z (funcall quantile-function
X                     (/ (1+ z) (+ (length z) 1))))
X         (plot-pos (repeat (funcall quantile-function 
X                                  (/ .625 (+ (length z) 5))) 
X                           (send self :num-cases))))
X    (setf (select plot-pos ind) z)
X    plot-pos))
X
;;
;; toggle cases method
;;
X
(defmeth regression-model-proto :toggle-cases (&rest args)
"
Message args: args, a list of case numbers
Deletes/restores specified cases.  If args is nil, all cases are restored."
(let* (included)
X  (cond
X    ((null args) (setf included (repeat t (send self :num-cases))))
X    (t
X     (setf included (send self :included))
X     (mapcar #'(lambda (j) (setf (select included j) 
X                                 (not (select included j)))) (combine args))))
X  (send self :included included)))
X
X
;;
;; methods for accessing graphs
;;
X
(defmeth regression-model-proto :delete-graph (graph)
X  (setf (slot-value 'graphs) (remove graph (slot-value 'graphs))))
X
(defmeth regression-model-proto :graphs (&optional graph)
X    (if graph (setf (slot-value 'graphs) 
X                   (cons graph (slot-value 'graphs))))
X    (slot-value 'graphs))
X
(defmeth regression-model-proto :last-graph () (first (send self :graphs)))
X
;;
;;  basic plotting methods
;;
X
(defmeth regression-model-proto :plot (&rest args) 
"
Message args: (data &key (plot-controls t))
Installs a plot of any dimension, histogram, 2-D, 3-D or more-D, in a 
regression model.  Data is a list giving instructions for creating the 
data to be plotted."
;;;NOTE:  The keyword, if present must be at the END of the Message
X  (when (null (slot-value 'graphs)) (send self :make-first-plot))
X  (let* ((n (length args))
X         (keyword (cond ((> n 1) (eq (nth (- n 2) args) ':plot-controls))
X                    (t nil)))
X         (plot-controls (if keyword (car (last args)) t))
X         (data (cond ((= n 0) (slot-value 'default-plot))
X                 ((= n 1) (if (listp (first args)) (first args) 
X                                     (list (first args))))
X                 (t (let* ((d (select args 
X                                      (iseq (- n (if keyword 2 0))))))
X                      (if (and (= (length d) 1)
X                               (listp (first d))) (first d) d)))))
X         (p (length data))
X         (axes (iseq 0 (1- p)))
X         (f (transpose (mapcar #'(lambda (data) 
X                                 (send self :return-function data)) data)))
X         (functions (second f))
X         (labels (if (> p 2)
X                     (mapcar #'(lambda (a) (substr a 0 6)) (first f))
X                     (first f)))
X         (title (cond
X                ((= p 1) (first labels))
X                ((= p 2)
X                 (format nil "~a vs ~a"
X                         (substr (first labels) 0 10)
X                         (substr (second labels) 0 10))) 
X                ((= p 3)
X                 (format nil "X:~a Y:~a Z:~a" (first labels) (second labels)
X                         (third labels)))
X                (t  (format nil "~a Dimensional Plot" p))))
X         (plot (send self :make-plot functions labels 
X                   :title title
X                   :matrix-plot nil
X                   :plot-controls plot-controls)))
X  plot))
X
X
(defmeth regression-model-proto :scatterplot-matrix (&rest args) 
"
Message args: (data &key (plot-controls t))
Installs a scatterplot matrix in a regression model.  Data is a list 
giving instructions for creating the data to be plotted."
;;;NOTE:  The keyword, if present must be at the END of the Message
X  (when (null (send self :has-slot 'graphs)) (send self :make-first-plot))
X  (let* ((n (length args))
X         (keyword (cond ((> n 1) (eq (nth (- n 2) args) ':plot-controls))
X                    (t nil)))
X         (plot-controls (if keyword (car (last args)) t))
X         (data (cond ((= n 0) 
X                      (cons 'y (iseq (array-dimension (send self :x) 1))))
X                 ((= n 1) (error "Need at least 2 quantities"))
X                 (t (let* ((d (select args 
X                                      (iseq (- n (if keyword 2 0))))))
X                      (if (and (= (length d) 1)
X                               (listp (first d))) (first d) d)))))
X         (p (length data))
X         (axes (iseq 0 (1- p)))
X         (f (transpose (mapcar #'(lambda (data) 
X                                 (send self :return-function data)) data)))
X         (functions (second f))
X         (labels (first f))
X         (title "Scatterplot Matrix")
X         (plot (send self :make-plot functions labels 
X                   :title title
X                   :matrix-plot t
X                   :plot-controls plot-controls)))
X  plot))
X
(defmeth regression-model-proto :make-plot 
X  (functions labels 
X             &key (title "Regression Plot") 
X             (matrix-plot nil)
X             (plot-updating t)
X             (plot-controls t))
"
Internal function to draw plots.  Generally not to be accessed by the user."
;;;data is either (1) a list of functions.  Evaluation of the j-th function
;;;                   gives the data for axis j; or
;;;               (2) a function that, when evaluated gives all axes.  
;;;  For a general plot, data is created by the call to the :plot method.
;;;  For other plots, e.g. :ares plots, it is created by a call to the :ares
;;;     method
;;;The keyword tell if the plot should use buffering, plot controls, and
;;;plot updating when the model is changed.
X  (when (null (send self :has-slot 'graphs)) (send self :make-first-plot))
X  (let* ((data (cond 
X                 ((equal (type-of functions) 'cons) 
X                  (mapcar 'funcall functions))
X                 ((equal (type-of functions) 'closure)
X                  (funcall functions))))
X         (ids (iseq (send self :num-cases)))
X         (num (length data))
X         (graph (cond
X                ((= num 1)
X                 (histogram data 
X                            :variable-labels labels :title title :show nil))
X                (matrix-plot
X                  (scatterplot-matrix data :variable-labels 
X                                      (mapcar #'(lambda (a) (substr a 0 7))
X                                                        labels)
X                                      :title title :show nil))
X                ((= num 2)
X                 (plot-points data
X                              :variable-labels labels :title title :show nil))
X                ((= num 3)
X                   (spin-plot data :variable-labels 
X                       (mapcar #'(lambda (c) (substr c 0 5)) labels)
X                            :title title  :show nil))
X                 (t
X                  (scatterplot-matrix data :variable-labels 
X                                      (mapcar #'(lambda (a) (substr a 0 7))
X                                                        labels)
X                                      :title title :show nil)))))
X    (send self :graphs graph)
;;;the next line selects points not 'included in the fit
X    (when (= (length (send self :graphs)) 1)
X          (send graph :point-selected (iseq (send self :num-cases))
X                (mapcar 'not (send self :included))))
X    (send graph :linked t)
X    (when (send self :case-labels)
X         (send graph :point-label ids (send self :case-labels)))
;;;The next when statement gives my linking strategy:  point symbol, state
;;;and color are inherited to later plots, except symbols are not inherited
;;;from a > 2D plot.
X    (when (> (length (send graph :links)) 1)
X          (let ((plot (select (send graph :links) 1)))
X            (send graph :point-color ids (send plot :point-color ids))
X            (send graph :point-state ids (send plot :point-state ids))
X            (when (and (< num 3) (= (send plot :num-point-variables) 2))
X                  (send graph :point-symbol ids 
X                        (send plot :point-symbol ids)))))
X    (send graph :add-slot 'owner self)
X    (send graph :add-slot 'functions functions)
X    (send graph :add-slot 'axes (iseq num))
X    (send graph :plot-updating plot-updating)
X    (if plot-controls (send graph :plot-controls))
X    (send graph :show-window)
X    (when plot-updating (send graph :menu-delete-points))
X    (defmeth graph :close ()
X      (send (slot-value 'owner) :delete-graph self)
X      (call-next-method))
X    graph))
X
(defmeth graph-proto :plot-updating (&optional (new nil set))
X  (when set (send self :add-slot 'plot-updating new))
X  (slot-value 'plot-updating))
X
;;
;; modify compute and needs-computing methods
;;
X
(defmeth regression-model-proto :make-first-plot ()
"Message args: ()
Creates two slots and override methods for compute and needs-computing to
automatically update graphs if present whenever :needs-computing is set to
t."
X  (send self :add-slot 'graphs)
;;;the next slot is for compatibility with glim-proto
X  (send self :add-slot 'now-computing nil)
X  (send self :add-slot 
X        'default-plot (list 'fit-values 'studentized-residuals))
X  (defmeth self :compute ()
X    (setf (slot-value 'now-computing) t)
X    (call-next-method)
X    (setf (slot-value 'now-computing) nil)
X    (when (send self :has-slot 'ir) (send self :ir-needs-computing t))
X    (send self :update-graphs))
X  (defmeth self :needs-computing (&optional (new nil set))
X    (cond ((and set (send self :graphs-need-updating)
X                (null (slot-value 'now-computing)))
X           (send self :compute))
X      (set (if (send self :has-slot 'needs-computing)
X               (setf (slot-value 'needs-computing) new)
X               (setf (slot-value 'sweep-matrix) nil))))
X   (if (send self :has-slot 'needs-computing)
X       (slot-value 'needs-computing)
X       (null (slot-value 'sweep-matrix)))))
X
(defmeth regression-model-proto :graphs-need-updating ()
"
Returns t if there are graphs to update, and nil otherwise."
X  (> (length (slot-value 'graphs)) 0))
X
(defmeth regression-model-proto :update-graphs ()
X  (when (send self :graphs-need-updating)
X        (dolist (graph (send self :graphs)) 
X                (send graph :update-graph (send self :included)))))
X
(defmeth graph-proto :update-graph (inc)
X (when (send self :plot-updating)
X       (let* ((fun (send self :slot-value 'functions))
X              (data (cond
X                     ((equal (type-of fun) 'cons) (mapcar 'funcall fun))
X                     ((equal (type-of fun) 'closure) (funcall fun)))))
X             (cond ((= (length inc) (send self :num-points))
X              (send self :point-showing (iseq (send self :num-points)) inc)
X              (send self :draw-next-frame (send self :slot-value 'axes) data))
X                   (t (send self :draw-next-frame nil data))))))
;;
;;  translate a function name into a variable label and 
;;  a function that when funcalled computes a vector---used in plotting
;;
X
(defmeth regression-model-proto :make-function-list ()
X  (send self :add-slot 'function-list
X       (list
X        (list 'response (list (send self :response-name)
X              #'(lambda () (send self :yvar))))
X        (list 'fit-values  (list "Fit-values"
X              #'(lambda () (send self :fit-values))))
X        (list 'residuals    (list 
X              (if (send self :pweights) 
X                  "Residuals weighted" "Residuals")
X              #'(lambda () (send self :residuals))))
X        (list 'studentized-residuals (list "Studentized residuals"
X              #'(lambda () (send self :studentized-residuals))))
X        (list 'externally-studentized-residuals 
X              (list "Ext. Stud. Residuals" #'(lambda ()
X              (send self :externally-studentized-residuals))))
X        (list 'leverages (list "Leverages" #'(lambda () 
X              (send self :leverages))))
X        (list 'cooks-distances (list "Cook's Distance"
X              #'(lambda () (send self :cooks-distances))))
X        (list 'case-numbers (list "Case numbers" #'(lambda () 
X           (iseq 0 (1- (send self :num-cases))))))
X        (list 'sqrt-cooks-distances (list "Sqrt Cook's Dist."
X              #'(lambda () (sqrt (send self :cooks-distances)))))
X        (list 'local-inf (list "Local inf. dir. cosine" #'(lambda ()
X           (second (send self :local-inf :absolute t)))))
X        (list 'signed-local-inf 
X              (list "Signed local inf. dir. cosine" #'(lambda ()
X           (second (send self :local-inf :absolute nil)))))
X        )))
X  
X
(defmeth regression-model-proto :return-function 
X  (&optional name &key add delete)
"
Message args: (name &key add delete)
This internal function sets up an association list mapping names
of functions to functions.  Used in plotting.  If the keyword add is true,
then name is added to the association list, if delete is t, it is deleted from
the association list.  It is assumed to be of the form
(list 'keyword (list quoted-label function)).  The 'keyword is used to name
the quantity to be plotted.  The quoted-label is the label used on the graph.
The function, when funcalled, computes the data."
X  (if (null (slot-value 'function-list)) (send self :make-function-list))
X  (cond 
X   ((null name) (slot-value 'function-list))
X   (add (setf (slot-value 'function-list) 
X              (cons name (slot-value 'function-list)))
X        name)
X   (delete
X    (let ((p (position name (mapcar #'first (slot-value 'function-list)))))
X         (when p (setf (slot-value 'function-list)
X                        (remove (select (slot-value 'function-list) p)
X                                (slot-value 'function-list))))))
X   (t
X	 (flet ((convert-name (x)
X             (let* ((names (send self :names :response t))
X                    (col (cond
X                          ((numberp x)
X                           (if (intersection (list x) (iseq (length names))) x
X                               (error "Not a variable number")))
X                          ((stringp x)
X                           (if (member x names :test 'equal)
X                               (position x names :test 'equal)
X                               (error "Not a predictor name")))
X                          (t (error "Input neither an integer nor a string")))))
X              (list (select names col) #'(lambda () 
X						 (select (send self :variables :response t) col))))))
X    (let* (col
X          (names (send self :names :response t))
X          (*function-list* (slot-value 'function-list))
X          (function (second (assoc name *function-list*))))
X    (cond
X      (function
X       (setf (select function 0) (format nil "~a" (select function 0))))
X      ((or (numberp name) (stringp name))
X		 (setf function (convert-name name)))
X      ((or (vectorp name) (listp name))
X       (setf function (list " " #'(lambda () name))))
X      ((equal (type-of name) 'closure)
X       (setf function (list "" name)))
X      ((equal ":" (substr (format nil "~a" name) 0 1))
X       (setf function (list (substr (format nil "~a" name) 1 100)
X                            #'(lambda () (send self name)))))
X      (t (error "Axis choice is not a list or a closure")))
X    function)))))
X
;;;
;;;  The following method returns a clone of the current model
;;;  For internal use in methods that must fit related models, like
;;;  sequential anovas, ares plots, and so on.
X
(defmeth regression-model-proto :make-clone (&key (verbose nil) (recycle t))
"Message args: (&key (verbose nil) (recycle t))
This message creates a clone of the current instance of the regression model,
and returns it.  This is useful in methods that would alter the model, such as
added variable plots,  subset selection, choosing transformations, and so on.
By default, verbose is set to nil and recycle to t,  regardless of their
status in the current model.  Graphs are not passed to the clone."
X   (let* ((r (make-object self)))
X         (mapcar #'(lambda (s v) (send r :add-slot s v))
X                       (send self :own-slots) 
X                       (mapcar #'slot-value (send self :own-slots)))
X         (mapcar #'(lambda (a) (send r :add-slot a nil))
X                 (list 'graphs 'function-list 'graphics-items))
X         (send r :verbose verbose)
X         (send r :recycle recycle)
X         r))
X
X
;;;
;;; This is new method to create a slot containing
;;; an instance of the project-proto, so that it's
;;; methods could be used. Adds a few new methods.
;;;
(defmeth regression-model-proto :make-q ()
X  (let* ((p (project (send self :x)
X		     :intercept (send self :intercept)
X		     :included (send self :included)
X		     :weights (send self :weights))))
X    (send self :add-slot 'qr p)
X    p)))
X
(defmeth regression-model-proto :col-of-q (j)
X  (let* ((qr (slot-value 'qr))
X	 (q (send qr :q))
X	 (jvec (repeat 0 (array-dimension q 1))))
X    (setf (select jvec j) 1)
X    (matmult q (diagonal jvec))))
SHAR_EOF
chmod 0745 Teach/OVL/reg1.lsp ||
echo 'restore of Teach/OVL/reg1.lsp failed'
Wc_c="`wc -c < 'Teach/OVL/reg1.lsp'`"
test 30551 -eq "$Wc_c" ||
	echo 'Teach/OVL/reg1.lsp: original size 30551, current size' "$Wc_c"
fi
# ============= Teach/OVL/rgraph1.lsp ==============
if test -f 'Teach/OVL/rgraph1.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/OVL/rgraph1.lsp (File already exists)'
else
echo 'x - extracting Teach/OVL/rgraph1.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/OVL/rgraph1.lsp' &&
;:
;; redraw a frame -- for dynamic plots
;:
X
(defmeth graph-proto :draw-next-frame (axis-list data 
X    &optional (id-num (iseq (length (select data 0)))))
"
Message args: axis-list data &optional (id-num (iseq (length (select data 0))))
For use in animation.  The list axis-list contains the indices of the axes 
to be updated, and data, a list of lists, gives the corresponding data.  For
2-D plots, axis-list will typically be '(0 1) and data will have two lists.
Before updating, the functions in start-next-frame are executed; after
updating, the functions in finish-next-frame are executed."
X  (mapcar #'funcall (send self :start-next-frame))
X  (send self :point-coordinate axis-list 
X        (repeat (list id-num) (length axis-list)) data)
X  (send self :redraw-content)
X  (mapcar #'funcall (send self :finish-next-frame)))
X
(defmeth graph-proto :start-next-frame (&optional function)
X  (when (not (send self :has-slot 'start-next-frame)) 
X        (send self :add-slot 'start-next-frame (list #'(lambda()))))
X  (when function (setf (slot-value 'start-next-frame) 
X         (append (slot-value 'start-next-frame) (list function) )))
X  (slot-value 'start-next-frame))
X
(defmeth graph-proto :finish-next-frame (&optional function)
X  (when (not (send self :has-slot 'finish-next-frame)) 
X        (send self :add-slot 'finish-next-frame (list #'(lambda()))))
X  (when function (setf (slot-value 'finish-next-frame) 
X         (append (list function) (slot-value 'finish-next-frame))))
X  (slot-value 'finish-next-frame))
X
X
;;;
;;;  Methods to restore/delete points from a model via a graph
;;;
X
(defmeth graph-proto :menu-delete-points ()
"Message args: ()
Adds menu items to a graphics menu if the object has a slot
owner."
(cond ((send self :has-slot 'owner)
X  (let* ((graph self)
X			(title (send menu-item-proto :new "Regression Model:"))
X			(updating (send menu-item-proto :new "  Plot updating"
X								 :action #'(lambda () (send self :menu-plot-update))))
X			(delete-selection (send mytoggle-item-proto :new 
X                                 #'(lambda () (send self :selection)) 
X                                 "  Delete Selection" 
X                                ;"  Delete Selection from reg model" 
X                                 #'(lambda ()(send self :delete-selection))
X                                 "  Select Deletions" 
X                                 #'(lambda() (send self :select-deletions))))
X         (restore-selection (send mytoggle-item-proto :new 
X                 #'(lambda () (send self :selection))
X                                 "  Restore Selection"
X                                ;"  Restore Selection to reg model"
X                                 #'(lambda ()(send self :restore-selection))
X                                 "  Restore All"
X                                 #'(lambda() (send self :restore-all)))))
X    (defmeth updating :update ()
X				 (let* ((mark (send graph :plot-updating)))
X				       (send self :mark mark)
X						 (send delete-selection :enabled mark)
X						 (send restore-selection :enabled mark)))
X    (send (send self :menu) :append-items title updating delete-selection 
X          restore-selection)))))
X
(defmeth graph-proto :menu-plot-update ()
X  (send self :plot-updating (null (send self :plot-updating))))
X
(defmeth graph-proto :delete-selection ()
"Message args: ()
Deletes selected points (cases) from a model unless they are already deleted."
X  (send (slot-value 'owner) :included
X          (mapcar #'(lambda (a b) (and a b)) 
X               (send (slot-value 'owner) :included) 
X               (mapcar 'not (send self :point-selected 
X                   (iseq 0 (1- (send (slot-value 'owner) :num-cases))))))))
X
(defmeth graph-proto :restore-all ()
"Message args: ()
Restores all deleted cases to a model."
X  (send (slot-value 'owner) :toggle-cases))
X
(defmeth graph-proto :restore-selection ()
"Message args: ()
Restores selected deleted cases to a model."
(send (slot-value 'owner) :included
X          (mapcar #'(lambda (a b) (if (and (not a) (not b)) nil t)) 
X                (send (slot-value 'owner) :included) 
X                (send self :point-selected 
X                  (iseq 0 (1- (send (slot-value 'owner) :num-cases)))))))
X
(defmeth graph-proto :select-deletions ()
"Message args: ()
Highlights deleted cases."
X  (send self :point-selected 
X            (iseq 0 (1- (send (slot-value 'owner) :num-cases))) 
X            (mapcar 'not (send (slot-value 'owner) :included))))
X
(defmeth spin-proto :use-color (&optional (toggle nil set))
"
This override method makes sure that color points are visible on a 
black spinning plot."
X  (cond
X    ((not set) (call-next-method))
X    ((screen-has-color) (call-next-method toggle))
X    ((eq (send self :back-color) 'white) (call-next-method toggle))
X    (t (call-next-method nil))))
X
(defmeth graph-proto :get-color (color)
"Message args: (j)
Returns a color, depending on the :back-color."
X  (let* ((j (position color *colors*))
X         (black-colors '(0 0 2 7 5 5 6 7))
X         (white-colors '(1 1 2 3 4 4 6 3)))
X    (select *colors* (if (eq (send self :back-color) 'white)
X                         (select white-colors j)
X                         (select black-colors j)))))
;;;
;;;  num-point-variables returns num-variables for everything but histograms
;;;
X
(defmeth graph-proto :num-point-variables ()
"Message args: ()
Returns the number of axes."
X  (send self :num-variables))
X
(defmeth histogram-proto :num-point-variables ()
"Message args: ()
Returns the number of axes is a histogram."
X  (- (send self :num-variables) 1))
X
(defmeth graph-proto :tile (&optional where )
"Message args: ()
This message moves a plot to one of four locations.  Sending this message to
four different plots will fill a workstation computer screen."
X  (when (null (send self :has-slot 'tile-loc))
X        (send self :add-slot 'tile-loc 2))
X  (if where
X      (setf (slot-value 'tile-loc) where)
X      (setf (slot-value 'tile-loc) (rem (+ 1 (slot-value 'tile-loc)) 4)))
X  (case (slot-value 'tile-loc)
X       (0 (send self :location 1 40))
X       (1 (send self :location 515 40))
X       (2 (send self :location 1 480))
X       (3 (send self :location 515 480)))
X  (slot-value 'tile-loc))
X
;;;
;;;  use nice tick marks
;;;
X
(defmeth graph-proto :nice-range (axis xmin xmax)
"Args:  (axis xmin xmax)
For axis 0 or 1, rescales the axes to have nice tick marks."
X  (let* ((ans (get-nice-range xmin xmax 4))
X			(ticks (case axis
X							 (0 (send self :x-axis))
X							 (1 (send self :y-axis)))))
X		  (apply #'send self :range axis (select ans '(0 1)))
X		  (case axis
X				  (0 (apply #'send self :x-axis 
X								(combine (select ticks '(0 1))(select ans 2))))
X				  (1 (apply #'send self :y-axis 
X								(combine (select ticks '(0 1))(select ans 2)))))))
X
X
X
;;;
;;;  An additoinal mouse mode for 2-D graphs
;;;
X
(defmeth graph-proto :save-identify (&optional new)
"Message args:  (new)
New is a point-coordinate.  Puts it in a list to be
redrawn when the :redraw message is sent."
X  (when (null (send self :has-slot 'identified)) 
X        (send self :add-slot 'identified nil)
X        (defmeth self :redraw ()
X                 (call-next-method)
X                 (mapcar #'(lambda (p)
X                                   (send self :label-with-coordinates p))
X                         (slot-value 'identified))))
X  (when new 
X        (cond ((position new (slot-value 'identified))
X               (setf (slot-value 'identified) 
X                     (remove new (slot-value 'identified)))
X					(send self :label-with-coordinates new :mode 'remove))
X              (t (setf (slot-value 'identified) 
X                       (cons new (slot-value 'identified))))))
X  (slot-value 'identified))
X
(defmeth graph-proto :label-with-coordinates (p &key (mode 'normal))
X  (let* ((old-mode (send self :draw-mode))
X         (axes (iseq (send self :num-variables)))
X         (val (send self :point-coordinate (iseq (send self :num-variables)) p))
X         (edge (select (send self :view-rect) 2))
X         (label (format nil "~a:~s" (send self :point-label p) val))
X         (loc (apply #'send self :real-to-canvas val)))
X		  (case mode
X				  (normal
X                (send self :draw-mode mode)
X                (send self :draw-string label 
X                      (min (first loc) (- edge 1 (send self :text-width label)))
X                      (second loc)))
X				  (xor
X                (send self :draw-mode mode)
X                (send self :draw-string label 
X                      (min (first loc) (- edge 1 (send self :text-width label)))
X                      (second loc))
X                (send self :while-button-down #'(lambda (x y)))
X                (send self :draw-string label 
X                      (min (first loc) (- edge 1 (send self :text-width label)))
X                      (second loc))
X                (send self :draw-mode old-mode))
X				  (remove
X					 (send self :draw-mode 'xor)
X                (send self :draw-string label 
X                      (min (first loc) (- edge 1 (send self :text-width label)))
X                      (second loc))
X                (send self :draw-mode old-mode)))))
X
(defmeth graph-proto :do-identify-coordinates (x y m1 m2)
X  (let* ((cr (send self :click-range))
X         (p (first (send self :points-in-rect 
X                         (- x (round (/ (first cr) 2)))
X                         (- y (round (/ (second cr) 2)))
X                         (first cr)
X                         (second cr)))))
X    (when p
X        (send self :label-with-coordinates p :mode (if m1 'normal 'xor))
X        (if m1 (send self :save-identify p)))))
X
(send scatterplot-proto :add-mouse-mode 'show-coordinates 
X  :title "Show Coordinates"
X  :cursor 'finger :click :do-identify-coordinates)
X
(defmeth graph-proto :r-adjust-to-data ()
X  (send self :adjust-to-data))
X
;;;
;;; scale both axes the same in the plot
;;;
X
(defmeth scatterplot-proto :aa-scaling ()
"Message args: ()
Rescales plot so both if aspect ratio is fixed, the units are the same on each
axis."
X  (send self :adjust-to-data :draw nil)
X  (let* ((r (mapcar #'(lambda (j) (send self :range j)) '(0 1)))
X			(m (mapcar #'(lambda (r) (* .5 (apply #'+ r))) r))
X			(d (mapcar #'(lambda (r) (apply #'- (reverse r))) r))
X			(j (if (> (first d) (second d)) 0 1))
X			(k (if (= j 1) 0 1))
X			(gnr1 (apply #'get-nice-range (combine (select r j) 6)))
X			(gnr2 (list 
X					 (- (select m k) (* .5 (- (select gnr1 1) (select gnr1 0))))
X					 (+ (select m k) (* .5 (- (select gnr1 1) (select gnr1 0))))
X					 (select gnr1 2))))
X		  (apply #'send self :x-axis (if (= j 0) gnr1 gnr2))
X		  (apply #'send self :y-axis (if (= j 1) gnr2 gnr1))
X		  (apply #'send self :range j (select gnr1 '(0 1)))
X		  (apply #'send self :range k (select gnr2 '(0 1)))))
SHAR_EOF
chmod 0745 Teach/OVL/rgraph1.lsp ||
echo 'restore of Teach/OVL/rgraph1.lsp failed'
Wc_c="`wc -c < 'Teach/OVL/rgraph1.lsp'`"
test 10725 -eq "$Wc_c" ||
	echo 'Teach/OVL/rgraph1.lsp: original size 10725, current size' "$Wc_c"
fi
# ============= Teach/OVL/boxplot.lsp ==============
if test -f 'Teach/OVL/boxplot.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/OVL/boxplot.lsp (File already exists)'
else
echo 'x - extracting Teach/OVL/boxplot.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/OVL/boxplot.lsp' &&
(defmeth scatterplot-proto :add-boxplot (y &key (x 1.0) (width 1.0) 
X					   (draw t)(range 1.5))
X "Modified version of the standard boxplot to put in outliers, points 
X   beyond range*iq-range above or below the median, explicitly."
X (unless (= 2 (send self :num-variables)) 
X	  (error "only works for 2D plots"))
X (let* ((half-box (* 0.4 width))
X	(half-foot (* 0.1 width))
X	(fiv (fivnum+ y :range range))
X	(low (select fiv 0))
X	(q1 (select fiv 1))
X	(med (select fiv 2))
X	(q3 (select fiv 3))
X	(high (select fiv 4))
X	(fivpts (select fiv (iseq 5)))) 
X   (send self :plotline (- x half-foot) low  (+ x half-foot) low  nil)
X   (send self :plotline (- x half-foot) high (+ x half-foot) high nil)
X   (send self :plotline x low x q1   nil)
X   (send self :plotline x q3  x high nil)
X   (send self :plotline (- x half-box) q1  (+ x half-box) q1  nil)
X   (send self :plotline (- x half-box) med (+ x half-box) med nil)
X   (send self :plotline (- x half-box) q3  (+ x half-box) q3  nil)
X   (send self :plotline (- x half-box) q1  (- x half-box) q3  nil)
X   (send self :plotline (+ x half-box) q1  (+ x half-box) q3  nil)
X   ;; *** Here are two versions that allow linking to work properly.
X   ;; ***
X   ;; *** this version uses an undocumented feature called masking.
X   ;; *** It is like removing except it is local to a plot, not linked.
X   ;; *** I never could decide if it was worth using, so I did not
X   ;; *** document it. It MAY not work properly.
X   (let* ((np (send self :num-points))
X	   (ny (length y)))
X     (send self :add-points (repeat x ny) y 
X	    :point-labels (mapcar #'(lambda (x) (format nil "~,5g" x)) y)
X	    :draw nil)
X     (send self :point-masked (+ np (iseq ny)) (<= low y high))
X     (send self :add-points (repeat x 5) fivpts
X	   :point-labels (mapcar #'(lambda (x) (format nil "~,5g" x)) 
X				 fivpts) 
X	   :draw nil)
X     (send self :point-symbol (iseq (+ np ny) (+ np ny 5)) 'dot))
X   ;; *** Here is an alternate version that just adds all the points
X   ;;    (send self :add-points (repeat x (length y)) y :draw draw)
X   (if draw (send self :redraw-content))))
X
(defun fivnum+ (x &key (range 1.5))
X  "Returns a list of six items as follows: low-fence q1 med q3 high-fence
X   outliers, where outliers is a list of values outside the fences.  Range
X   determines the fences; the usual value is 1.5*iq-range."
X  (flet ((quant (x p)
X                (let* ((n (length x))
X                       (np (* p (- n 1)))
X                       (low (floor np))
X                       (high (ceiling np)))
X                      (/ (+ (select x low) (select x high)) 2))))
X    (let* ((x (sort-data x))
X           (n (- (length x) 1))
X           (q1 (quant x .25))
X           (q3 (quant x .75))
X           (q2 (quant x .50))
X           (r (* range (- q3 q1)))
X           (low-ind (cond ((= range 0) 0)
X                            ((<= (- q1 r) (select x 0)) 0)
X                            (t (do ((j 0 (1+ j)))
X                                   ((and (< (select x j) (- q1 r))
X                                        (>= (select x (1+ j)) (- q1 r)))
X                                    (+ j 1))))))
X           (high-ind (cond ((= range 0) n)
X                           ((>= (+ q3 r) (select x n)) n)
X                           (t (do ((j n (- j 1)))
X                                  ((and (> (select x j) (+ q3 r))
X                                        (<= (select x (- j 1)) (+ q3 r)))
X                                   (- j 1)))))))
X          (list (select x low-ind) q1 q2 q3 (select x high-ind)
X                (cond ((and (= low-ind 0) (= high-ind n)) nil)
X                       ((= low-ind 0) (select x (iseq (1+ high-ind) n)))
X                       ((= high-ind n) (select x (iseq  low-ind)))
X                      (t (append (select x (iseq (1+ high-ind) n))
X                                 (select x (iseq low-ind)))))))))
X
(defun boxplot (data &key (title "Box Plot") (range 1.5)(show nil))
X  "Args: (data &key (title \"Box Plot\"))
X         DATA is a sequence, a list of sequences or a matrix. 
X         Makes a boxplot of the sequence or a parallel box plot of the 
X         sequences in the list or the column of the matrix.  The range 
X         determines the location of the outer fences, and is
X         the same as in S." 
X  (let ((p (send scatterplot-proto :new 2 :title title :show nil)))
X    (setq data 
X          (cond ((matrixp data) (column-list data))
X                ((or (not (listp data)) (numberp (car data))) (list data))
X                (t data)))
X        (let ((range (get-nice-range (min data) (max data) 4)))
X          (send p :range 1 (nth 0 range) (nth 1 range))
X          (send p :y-axis t nil (nth 2 range)))
X    (send p :range 0 0 (1+ (length data)))
X    (dotimes (i (length data))
X          (send p :add-boxplot (nth i data) :x (1+ i)))
X    (when show (send  p :show-window))
X    p))
SHAR_EOF
chmod 0745 Teach/OVL/boxplot.lsp ||
echo 'restore of Teach/OVL/boxplot.lsp failed'
Wc_c="`wc -c < 'Teach/OVL/boxplot.lsp'`"
test 4840 -eq "$Wc_c" ||
	echo 'Teach/OVL/boxplot.lsp: original size 4840, current size' "$Wc_c"
fi
# ============= Teach/PP/pp-dataf.lsp ==============
if test ! -d 'Teach/PP'; then
    echo 'x - creating directory Teach/PP'
    mkdir 'Teach/PP'
fi
if test -f 'Teach/PP/pp-dataf.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/PP/pp-dataf.lsp (File already exists)'
else
echo 'x - extracting Teach/PP/pp-dataf.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/PP/pp-dataf.lsp' &&
(def precipitation (list (list 0.77 1.74 0.81 1.2 1.95 1.2 0.47 1.43 3.37 
2.2 3 3.09 1.51 2.1 0.52 1.62 1.31 0.32 0.59 0.81 2.81 1.87 1.18 
1.35 4.75 2.48 0.96 1.89 0.9 2.05) "Precipitation"))
X
(def urban (list (list 206 170 155 155 134 239 234 228 330 284 201 241 
179 244 200 205 279 227 197 242 234) "Urban"))
X
(def rural (list (list  108 152 129 146 174 194 152 223 231 131 142 173
155 220 172 148 143 158 108 136) "Rural"))
X
(def hc (list (list  0.5 0.65 0.46 0.41 0.41 0.39 0.44 0.55 0.72 0.64 0.83 
0.38 0.38 0.5 0.6 0.73 0.83 0.57 0.34 0.41 0.37 1.02 0.87 1.1 0.65 
0.43 0.48 0.41 0.51 0.41 0.47 0.52 0.56 0.7 0.51 0.52 0.57 0.51 0.36 
0.48 0.52 0.61 0.58 0.46 0.47 0.55) "HC"))
X
(def co (list (list  5.01 14.67 8.6 4.42 4.95 7.24 7.51 12.3 14.59 7.98 
11.53 4.1 5.21 12.1 9.62 14.97 15.13 5.04 3.95 3.38 4.12 23.53 19 
22.92 11.2 3.81 3.45 1.85 4.1 2.26 4.74 4.29 5.36 14.83 5.69 6.35 
6.02 5.79 2.03 4.62 6.78 8.43 6.02 3.99 5.22 7.47) "CO"))
X
(def tensile-strength (list (list  162 233 232 231 231 237 224 219 203 189 
210 210 196 180 200 173 188 161 119 161 151 165 151 128 161 146 148 
144 134 127) "Tensil-Strength"))
X
(def hardness (list (list  45 55 61 66 71 71 81 86 53 60 64 68 79 81 56 68 75 
83 88 59 71 80 82 89 51 59 65 74 81 86) "Hardness"))
X
(def abrasion-loss (list (list  372 206 175 154 136 112 55 45 221 166 164 113 
82 32 228 196 128 97 64 249 219 186 155 114 341 340 283 267 215 148)
"Abrasion-Loss"))
X
(def flow (list (list  5 4.81 4.46 4.84 4.46 3.85 3.21 3.25 4.55 4.85 4 3.62 
5.15 3.76 4.9 4.13 5.1 5.05 4.27 4.9 4.55 4.39 4.85 4.59 5 3.82 3.68 
5.15 2.94 5 4.1 1.15 1.72 4.2 5) "Flow"))
X
(def moist (list (list  21 20 16 18 16 18 12 12 13 13 17 24 11 10 17 14 14 
14 20 12 11 10 16 17 17 17 15 17 21 21 21 26 21 17 11) "Moist"))
X
(def ratio (list (list  2.4 2.4 2.4 2.5 3.2 3.1 3.2 2.7 2.7 2.7 2.7 2.8 
2.5 2.6 2 2 2 1.9 2.1 1.9 2 2 2 2.2 2.4 2.4 2.4 2.2 2.2 1.9 2.4 
3.5 3 3.5 3.2) "Ratio"))
X
(def travel-space (list (list  12.8 12.9 12.9 13.6 14.5 14.6 15.1 17.5 19.5 20.8) "Travel-Space")) 
X
(def separation (list (list  5.5 6.2 6.3 7 7.8 8.3 7.1 10 10.8 11)
X "Separation"))
(def ethanol (list (list  0.59 0.3 0.25 0.03 0.44 0.18 0.13 0.02 0.22 0.23 
0.07 0 0.12 0.13 0 0.01) "Ethanol"))
X
(def air (list (list  80 80 75 62 62 62 62 62 58 58 58 58 58 58 50 50 50 
50 50 56 70) "Air")) 
SHAR_EOF
chmod 0745 Teach/PP/pp-dataf.lsp ||
echo 'restore of Teach/PP/pp-dataf.lsp failed'
Wc_c="`wc -c < 'Teach/PP/pp-dataf.lsp'`"
test 2325 -eq "$Wc_c" ||
	echo 'Teach/PP/pp-dataf.lsp: original size 2325, current size' "$Wc_c"
fi
# ============= Teach/PP/pp6.lsp ==============
if test -f 'Teach/PP/pp6.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/PP/pp6.lsp (File already exists)'
else
echo 'x - extracting Teach/PP/pp6.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/PP/pp6.lsp' &&
;; pp-PLOT-PROTO written by Tae-Sung Shin
;;
(defproto pp-plot-proto 
X  '(xdata ydata xlabel ylabel index graph1 parms parmn ctl ctl-loc ctl-loc1) 
X  () scatterplot-proto)
;;
;;;;;;;;;;;;;;;;;;;; set-up some slots and accessor methods
;;
(defmeth pp-plot-proto :ctl-loc (&optional (ctl-loc nil set))
X  (if set (setf (slot-value 'ctl-loc) ctl-loc))
X  (slot-value 'ctl-loc))
X
(defmeth pp-plot-proto :ctl-loc1 (&optional (ctl-loc1 nil set))
X  (if set (setf (slot-value 'ctl-loc1) ctl-loc1))
X  (slot-value 'ctl-loc1))
X
(defmeth pp-plot-proto :xdata (&optional (xdata nil set))
X  (if set (setf (slot-value 'xdata) (sort-data xdata)))
X  (slot-value 'xdata))
X
(defmeth pp-plot-proto :ydata (&optional (ydata nil set))
X  (if set (setf (slot-value 'ydata) ydata))
X  (slot-value 'ydata))
X
(defmeth pp-plot-proto :parms (&optional (parms nil set))
X  (if set (setf (slot-value 'parms) parms))
X  (slot-value 'parms))
X
(defmeth pp-plot-proto :parmn (&optional (parmn nil set))
X  (if set (setf (slot-value 'parmn) parmn))
X  (slot-value 'parmn))
X
(defmeth pp-plot-proto :index (&optional (index nil set))
X  (if set (setf (slot-value 'index) index))
X  (slot-value 'index))
X
(defmeth pp-plot-proto :xlabel (&optional (xlabel nil set))
X  (if set (setf (slot-value 'xlabel) xlabel))
X  (slot-value 'xlabel))
X
(defmeth pp-plot-proto :graph1 (&optional (graph1 nil set))
X  (if set (setf (slot-value 'graph1) graph1))
X  (slot-value 'graph1))
X
(defmeth pp-plot-proto :ylabel (&optional (ylabel nil set))
X  (if set (setf (slot-value 'ylabel) ylabel))
X  (slot-value 'ylabel))
X  
(defmeth pp-plot-proto :ctl (&optional (ctl nil set))
X  (if set (setf (slot-value 'ctl) ctl))
X  (slot-value 'ctl))
X
(defmeth pp-plot-proto :close ()
X  (when (send self :graph1)
X	(mapcar #'(lambda (a) (send a :graph nil)) (send self :graph1))
X	(mapcar #'(lambda (a) (send a :close)) (send self :graph1)))
X  (call-next-method)
X  (exit)
)
X
#+msdos (defmeth popup-menu-control-proto :do-click (x y a b)
X	  (let* ((graph (send self :graph))
X		 (loc (send self :location))
X		 (loc-x (first loc))
X		 (loc-y (+ 5 (second loc))))
X	    (when (and (< loc-x x (+ loc-x 10)) (< loc-y y (+ loc-y 10)))
X		  (send graph :paint-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X		  (send self :do-action (list a b))
X		  (send graph :erase-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X		  t)))
X
;;; distribution selection control set up
X
(defproto simulate-menu-proto '(menu) () popup-menu-control-proto)
X
(defmeth simulate-menu-proto :isnew (loc)
X  (call-next-method loc :title "Distributions"))
X
(defmeth simulate-menu-proto :menu ()
X  (let ((graph (send self :graph)))
X    (when (null (slot-value 'menu))
X	  (let* ((menu (send menu-proto :new "Menu"))
X		 (normal (send menu-item-proto :new "Normal" 
X		  :action  #'(lambda () (send graph :generate-data 0 t))))
X		 (chisq (send menu-item-proto :new "Chi-square" 
X		  :action #'(lambda () (send graph :generate-data 1 t))))
X		 (t (send menu-item-proto :new "T" 
X		  :action #'(lambda () (send graph :generate-data 2 t))))
X		 (unif (send menu-item-proto :new "Uniform" 
X		  :action #'(lambda () (send graph :generate-data 3 t))))
X		 (expon (send menu-item-proto :new "Exponential" 
X		  :action #'(lambda () (send graph :generate-data 4 t))))
X		 (cauchy (send menu-item-proto :new "Cauchy" 
X		  :action #'(lambda () (send graph :generate-data 5 t))))
X		 (binom (send menu-item-proto :new "Binomial" 
X		  :action #'(lambda () (send graph :generate-data 6 t))))
X		 (pois (send menu-item-proto :new "Poisson" 
X		  :action #'(lambda () (send graph :generate-data 7 t)))))
X	    
X	    (send menu :append-items 
X		  normal chisq t unif expon cauchy binom pois)
X	    (setf (slot-value 'menu) menu)))
X   (slot-value 'menu)))
X
;;;;;; data selection control set up
X
(defproto data-menu-proto '(menu) () popup-menu-control-proto)
X
(defmeth data-menu-proto :isnew (loc)
X  (call-next-method loc :title "Select Data"))
X
(defmeth data-menu-proto :menu ()
X  (let ((graph (send self :graph))
X	(datalist (variables)))
X    (defmeth graph :data-redraw (item1)
X      (send self :clear nil)
X      (let* ((data (eval item1))
X	     (x (first data))
X	     (n (length x))
X	     (xttl (second data)))
X	(format t "~%")
X	(format t "X variable ~20a ~%" xttl) 
X	(prin1 x)(terpri)
X	(send self :parms nil)
X	(send self :delete-ctl)
X	(send self :x-axis nil)
X	(send self :xdata x)
X	(send self :xlabel xttl)
X	(send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X	(send self :draw-plots)
X	
X	))
X    (flet ((mk-item (item)
X		    (send menu-item-proto :new (string item) 
X			  :action  
X			  #'(lambda () (send graph :data-redraw item)))))
X	  (when (null (slot-value 'menu))
X		(let* ((menu (send menu-proto :new "Menu"))
X		       (items (mapcar #'mk-item datalist)))
X		  (flet ((append-item (item)
X				      (send menu :append-items item)))
X			(mapcar #'append-item items))
X		  (setf (slot-value 'menu) menu)))
X	  (slot-value 'menu))))
X
;;;;; draw normal probability plot, boxplot, and histogram  with values of xdata
X
(defmeth pp-plot-proto :draw-plots ()
X  (send self :draw-data	(send self :xdata)))
X
;;;;; actions for choosing new sample selection
X
(defmeth pp-plot-proto :new-sample ()
X  
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select data or Distribution!" 170 20 0 0)
X    (let* ((distributions (transpose (send self :return-distributions)))
X	   (sim-funs (select distributions 4))
X	   (function (select sim-funs (send self :index)))
X	   (plot (send self :graph1))
X	   (plot1 (first plot))
X	   (plot2 (second plot))
X	   (plot3 (third plot))
X	   (y (send self :xdata (funcall function))))
X      (send self :draw-data y))))
X
(defun round100 (x)
X  (/ (round (* 100 x)) 100))
X
;;;;; draw normal probability plot, boxplot, and histogram  with y
X
(defmeth pp-plot-proto :draw-data (y)
X  (let* ((y (standardize y))
X	 (plot (send self :graph1))
X	 (plot1 (first plot))
X	 (plot2 (second plot))
X	 (plot3 (third plot)))
X     (when (< 0 (send plot1 :num-points)) 
X	  (send plot1 :clear-points nil)
X	  (send plot2 :clear nil)
X	  (send plot3 :clear nil))
X    (send plot1 :add-points (send self :ydata) y) 	 
X    (send plot2 :add-boxplot y :x 1)
X    (send plot3 :add-points y)
X    ))       
X
;;;;; new sample control setup
X
(defmeth pp-plot-proto :new-control ()
X  (let* ((location (send self :locate-next-control))
X	 (owner self)
X	 (control (send graph-control-proto :new
X			:location location :title "New sample")))    
X    (defmeth control :do-action (&rest args) 
X      (send owner :new-sample))
X    (send self :add-control control)
X    (send self :redraw)))
X
;;
;;;;;;;;;;;;;;;;;;;;;; methods to select  "Distribution" 
;; 
X
(defmeth pp-plot-proto :return-distributions ()
X  "Accessor method for slot :distribution-list."
X  (cond ((null (send self :has-slot 'distribution-list))
X	 (send self :make-distribution-list))
X	((null (slot-value 'distribution-list))
X	 (send self :make-distribution-list))
X	(t (slot-value 'distribution-list))))
X
(defmeth pp-plot-proto :make-distribution-list ()
X  "Creates slot containing the list of lists of distribution
X   names and corresponding activating functions."
X  (send self :add-slot 'distribution-list
X	(list
X	 (list "Normal" #'(lambda () (send self :draw-normal )) 
X	       (list "Mean:" "S.D.:" "Sample Size:")
X	       (list 0 1 4) #'(lambda () (send self :simulate-normal ))
X	       (list (iseq 0 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70) )) 
X	 (list "Chi-square"  #'(lambda () (send self :draw-chisquare ))
X	       (list "DF:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda () (send self :simulate-chisquare ))
X	       (list (iseq 1 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70) ))
X	 (list "t"  #'(lambda () (send self :draw-t  ))
X	       (list "DF:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda () (send self :simulate-t ))
X	       (list (iseq 1 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70)  ))
X	 (list "Uniform" #'(lambda () (send self :draw-uniform ))
X	       (list "a:" "b:" "Sample Size:")
X	       (list 0 1 4) #'(lambda () (send self :simulate-uniform ))
X	       (list (iseq 0 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70)  ))
X	 (list "Exponential" #'(lambda () (send self :draw-expon ))
X	       (list "Theta:" nil "Sample Size:")
X	       (list 1 1 4) #'(lambda () (send self :simulate-expon ))
X	       (list (iseq 1 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70)   ))
X	 (list "Cauchy" #'(lambda () (send self :draw-cauchy ))
X	       (list "Mean:" nil "Sample Size:")
X	       (list 0 0 4) #'(lambda () (send self :simulate-cauchy ))
X	       (list (iseq 0 20) (iseq 1 20)  (* 5 (iseq 2 20)) (iseq 50 70) ))
X	 (list "Binomial" #'(lambda () (send self :draw-binomial ))
X	       (list "n:" "p:" "Sample Size:")
X	       (list 10 0.05 4) #'(lambda () (send self :simulate-binomial ))
X	       (list (iseq 4 30) (* .05 (iseq 2 19)) (* 5 (iseq 2 20)) (iseq 50 70)))
X	 (list "Poisson" #'(lambda () (send self :draw-poisson ))
X	       (list "Lambda:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda () (send self :simulate-poisson ))
X	       (list (iseq 1 20) (iseq 0 20) (* 5 (iseq 2 20)) (iseq 50 70)  )))))
X
;;;;; display information of the distribution selected
X 
(defmeth pp-plot-proto :describe-dist ()
X  (let ((parms (send self :parms)))
X    (when parms
X	  (let* ((dist (send self :xlabel))
X		 (parmn (send self :parmn))
X		 (a (first parmn))
X		 (b (second parmn))
X		 (n (third parmn))
X		 (real-co (send self :real-to-canvas 
X				(first (send self :range 0)) 20))
X		 (x-co (first real-co))
X		 (y-co 30))
X	    (send self :draw-text 
X		  (concatenate 'string 
X			       "Distribution : " dist) x-co y-co 0 0)
X	    (send self :draw-text 
X		  (concatenate 'string 
X				a " " (num-to-string (first parms)))
X		  x-co (+ y-co 20) 0 0)
X	    (if b (send self :draw-text 
X			(concatenate 'string 
X				     b " " (num-to-string (second parms)))
X			x-co (+ 40 y-co) 0 0))
X	    (send self :erase-rect x-co (+ 40 y-co) 200 30)
X	    (send self :draw-text 
X		  (concatenate 'string 
X				n " " (num-to-string (third parms)))
X		  x-co (+ 60 y-co) 0 0)))))
X
;;;;; delete the controls related to simulation
X
(defmeth pp-plot-proto :delete-ctl ()
X  (let ((ctl (send self :ctl)))
X    (send self :ctl-loc 
X        (list (send (first ctl) :location)
X	      (if (second ctl) (send (second ctl) :location) 
X		(send self :ctl-loc1))
X	      (send (third ctl) :location)
X	      (send (fourth ctl) :location))))
X  (mapcar #'(lambda (a) (send self :delete-control a)) (send self :ctl))
X  (send self :ctl nil))
X
;;;; add the controls related to simulation
X 
(defmeth pp-plot-proto :add-ctl ()
X (let* ((loc (send self :ctl-loc))
X	(a (send pp-parm1-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (first loc)
X		 :title "parm1" :length (send self :slider-width)
X		 :index 0))    
X	(b (send pp-parm2-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (second loc)
X		 :title "parm2" :length (send self :slider-width)
X		 :index 0))
X	(n (send pp-n-control-proto :new 
X		  (* 4 (iseq 1 20))
X		  :location (third loc)
X		  :title "Sample Size 1" :length (send self :slider-width)
X		  :index 0))
X	(sam (send pp-sample-control-proto :new 
X		   :location (fourth loc)
X		   :title "New Sample"))
X	)
X   (send self :add-control a)
X   (send self :add-control b)
X   (send self :add-control n)
X   (send self :add-control sam)
X   (send self :ctl (list a b n sam))))
X
;;;;; delete the second parameter control
X  
(defmeth pp-plot-proto :delete-parm2-ctl ()
X  (send self :ctl-loc1 (send (select (send self :ctl) 1) :location))
X  (send self :delete-control (select (send self :ctl) 1))
X  (setf (select (send self :ctl) 1) nil))
X
;;;;; add the second parameter control
X
(defmeth pp-plot-proto :add-parm2-ctl ()
X  (let* ((ctl (send self :ctl))
X	 (a (select ctl 0))
X	 (b (send pp-parm2-control-proto :new 
X		   (* 4 (iseq 1 20))
X		   :location (send self :ctl-loc1)
X		   :title "parm2" :length (send self :slider-width)
X		   :index 0))
X	 (n1 (select ctl 2))
X	 (ns (select ctl 3)))
X      (send self :ctl (list a b n1 ns))
X      (send self :add-control b)
X      b))
X
;;;;; method for actions after selection of distribution
X
(defmeth pp-plot-proto :generate-data (ind getparms)
X  (if getparms
X      (let* ((distributions (transpose (send self :return-distributions)))
X	     (name (first distributions))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (parmvalu (fourth distributions))
X	     (function2 (select distributions 4))
X	     (dist1 (select distributions 4))
X	     (plot (send self :graph1))
X	     (plot1 (select plot 0))
X	     (plot2 (select plot 1))
X	     (plot3 (select plot 2))
X	     (seqs (select distributions 5))
X	     (seq (select seqs ind))
X	     (parmn (select parmname ind))
X	     (ctl (if (send self :ctl) (send self :ctl) (send self :add-ctl)))
X	     (n1 (select ctl 2))
X	     (a (select ctl 0))
X	     (b (if (select ctl 1) (select ctl 1) (send self :add-parm2-ctl))))
X	(if (< 0 (send plot1 :num-points))
X	    (mapcar #'(lambda (a) (send a :clear)) plot))
X	(send self :xlabel (select name ind))
X	(send self :parmn parmn)
X	(send n1 :title "Sample size")
X	(send a :title (select parmn 0))
X	(if (select parmn 1) (send b :title (select parmn 1))
X	  (send self :delete-parm2-ctl))
X	(send self :index ind)
X	(send self :parms (list (select (select seq 0) 0)
X				(select (select seq 1) 0) 
X				(select (select seq 2) 0)))
X	(send n1 :sequence (select seq 2))
X	(send a :sequence (select seq 0))
X	(if (select parmn 1) (send b :sequence (select seq 1)))
X	(send n1 :index 0)
X	(send a :index 0)
X	(if (select parmn 1) (send b :index 0))
X	(send self :index ind)
X	(funcall (select function ind))
X	(funcall (select function2 ind))
X	(send self :draw-plots)
X	(send self :describe-dist))))
X
(defmeth pp-plot-proto :redraw ()
X  (call-next-method)
X  (send self :describe-dist)) 
X
;;;;; methods for draw distribution density
X
(defmeth pp-plot-proto :draw-normal (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((mu (first parms))
X		      (sigma (second parms))
X		      (xmin (+ mu (* sigma (normal-quant .01))))
X		      (xmax (+ mu (* sigma (normal-quant .99))))
X		      (x (rseq xmin xmax 50)) 
X		      (y (mapcar #'normal-dens (/ (- x mu) sigma))))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth pp-plot-proto :add-lines2 (x y)
"draw line vertically from (x,0) to (x,y)"
X  (mapcar #'(lambda (a b) (send self :add-lines 
X				(list (list a a) (list 0 b)))) x y))
X
(defmeth pp-plot-proto :draw-fun (xmin xmax x y) 
X  (let ((parms (send self :parms)))
X    (when parms 
X	  (let* ((mu (first parms))
X		 (sigma (sqrt (second parms)))
X		 (maxy (max y))
X		 (nice-range (get-nice-range xmin xmax 7))
X		 (y (* (/ 1 maxy) y))
X		 (n1 (first nice-range))
X		 (n2 (second nice-range))
X		 (n3 (third nice-range))
X		 (graph1 (send self :graph1))
X		 (plot1 (first graph1))
X		 (plot1 (second graph1))
X		 (plot1 (third graph1)))
X	    (send self :clear nil)
X	    (send self :range 0 n1 n2)
X	    (send self :x-axis t t 5)
X	    (if (> (length x) 49) (send self :add-lines (list x y))
X	      (send self :add-lines2 x y))
X	    (if (< 0 (send (select (send self :graph1) 0) :num-points))
X		(mapcar #'(lambda (a) (send a :clear)) 
X			(send self :graph1)))))))
X
(defmeth pp-plot-proto :draw-chisquare (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms))
X		       (xmax (chisq-quant .99 df))
X		       (xmin 0)
X		       (x (rseq xmin xmax 50)) 
X		      
X		       (y (mapcar #'(lambda (i) (chisq-dens i df)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth pp-plot-proto :draw-t (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms))
X		       (xmax (t-quant .99 df))
X		       (xmin (t-quant .01 df))
X		       (x (rseq xmin xmax 50)) 
X		    
X		       (y (mapcar #'(lambda (i) (t-dens i df)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defun unif-dens (a b x)
X  (let* ((dis (- b a))
X	 (dens (/ 1 dis))
X	 (ans (if (and (< a x) (> b x)) dens 0)))
X    ans))
X
(defmeth pp-plot-proto :draw-uniform (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((a (first parms))
X		       (b (second parms))
X		       (n (third parms))
X		       (xmax (+ b .5))
X		       (xmin (- a .5))
X		       (den (/ 1 (- b a)))
X		       (x (list xmin a a b b xmax))  
X		       (y (list 0 0 den den 0 0))
X		       (nice-range (get-nice-range xmin xmax 7))
X		       (y (* (/ 1 den) y))
X		       (n1 (first nice-range))
X		       (n2 (second nice-range))
X		       (n3 (third nice-range)))
X		  (send self :clear nil)
X		  (send self :range 0 n1 n2)
X		  (send self :x-axis t t 5)
X		  (send self :add-lines (list x y))))))
X
X
(defmeth pp-plot-proto :draw-expon (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((theta (first parms))
X		       (n (third parms))
X		       (xmax (* theta (gamma-quant .99 1)))
X		       (xmin (* theta (gamma-quant .01 1)))
X		       (x (rseq xmin xmax 50)) 
X		   
X		       (y (mapcar 
X			   #'(lambda (i) 
X			       (* theta (gamma-dens i 1))) 
X			   (/ x theta))))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth pp-plot-proto :draw-cauchy (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((mu (first parms))
X		       (n (third parms))
X		       (xmax (+ mu (cauchy-quant .99)))
X		       (xmin (+ mu (cauchy-quant .01)))
X		       (x (rseq xmin xmax 50)) 
X		       
X		       (y (mapcar #' (lambda (i) 
X				       (cauchy-dens i)) (- x mu))))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth pp-plot-proto :draw-binomial (&optional set)
X (let ((parms (send self :parms)))
X    (when parms (let* ((m (first parms))
X		       (p (second parms))
X		       (n (third parms))
X		       (xmax m)
X		       (xmin 0)
X		       (x (iseq 0 m)) 
X		     
X		       (y (mapcar #' (lambda (i) 
X				       (binomial-pmf i m p)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth pp-plot-proto :draw-poisson (&optional set)
X (let ((parms (send self :parms)))
X    (when parms (let* ((lamda (first parms))
X		       (n (third parms))
X		       (xmax (round (poisson-quant .9999 lamda)))
X		       (xmin 0)
X		       (x (iseq xmin xmax)) 
X		       
X		       (y (mapcar #' (lambda (i) 
X				       (poisson-pmf i lamda)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
;;;;; methods for generating simulation data
X
(defmeth pp-plot-proto :simulate-normal ()
X  (let ((parms (send self :parms)))
X    (when parms (let* (
X		       (mu (first parms))
X		       (sigma (second parms))
X		       (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (+ mu (* sigma (normal-rand n))))
X		  
))))
X
(defmeth pp-plot-proto :simulate-chisquare ()
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (chisq-rand n df))
X		  ))))                  
X
(defmeth pp-plot-proto :simulate-t ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((df (first parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (t-rand n df))
X		  ))))
X
(defmeth pp-plot-proto :simulate-uniform ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((a (first parms))
X		      (b (second parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (+ a (* (- b a) (uniform-rand n))))
X		  ))))
X
(defmeth pp-plot-proto :simulate-expon ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((theta (first parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata 
X			(send self :xdata (* theta (gamma-rand n 1))))
X		  ))))
X
(defmeth pp-plot-proto :simulate-cauchy ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((mu (first parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (+ mu (cauchy-rand n)))
X		  ))))
X
(defmeth pp-plot-proto :simulate-binomial ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((n (first parms))
X		      (p (second parms))
X		      (m (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq m) 1) (+ m 1))))
X		  (send self :xdata (binomial-rand m n p))
X		  ))))
X
(defmeth pp-plot-proto :simulate-poisson ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((lamda (first parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (poisson-rand n lamda))))))
X
;;;; install the plot controls
X
(defmeth graph-proto :plot-controls () 
X  (let* ((margin (send self :margin))
X	 (left (send self :plot-control-left-margin))
X	 (top 12)
X	 (n (+ margin (list left top 0 0))))
X    (apply #'send self :margin n)
X    (send self :add-slot 'overlay-loc '(10 10))
X    (apply #'send self :size (+ (send self :size) (list left top)))
X    #+X11 (send self :size 490 320); fits 1/4 of a 14" Sony color monitor
X    (send self :resize)))
X
(defmeth pp-plot-proto :plot-controls ()
X  (call-method graph-proto :plot-controls)
X  (send self :add-control (send  simulate-menu-proto :new 
X				 (send self :locate-next-control)))
X  (send self :add-control (send  data-menu-proto :new 
X				 (send self :locate-next-control)))
X  (let ((a (send pp-parm1-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (send self :locate-next-control :height 2)
X		 :title "parm1" :length (send self :slider-width)
X		 :index 0))    
X	(b (send pp-parm2-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (send self :locate-next-control :height 2)
X		 :title "parm2" :length (send self :slider-width)
X		 :index 0))
X	(n (send pp-n-control-proto :new 
X		  (* 4 (iseq 1 20))
X		  :location (send self :locate-next-control :height 2)
X		  :title "Sample Size 1" :length (send self :slider-width)
X		  :index 0))
X	(sam (send pp-sample-control-proto :new 
X		   :location (send self :locate-next-control)
X		   :title "New Sample"))
)
X    (send self :ctl (list a b n sam))
X    (send self :add-control a)
X    (send self :add-control b)
X    (send self :add-control n)
X    (send self :add-control sam)))
X
(defmeth histogram-proto :plot-controls () 
X  (call-next-method) 
X  (send self :add-control 
X	(send self :ctl 
X	      (send hist-control-proto :new (iseq 2 20)
X		    :location (send self :locate-next-control :height 2)
X		    :title "NumBins" :length (send self :slider-width)
X		    :index)))
X  (send self :install-kernel-density))
X
(defun pp ()
"generate 4 plots for probability plot simulation"
X  (let* ((plot (send pp-plot-proto :new 5 :show nil))
X	 (graph1 
X	  (send plot :graph1 
X		(list (send scatterplot-proto :new 2 :show nil)
X		      (send scatterplot-proto :new 2 :show nil)
X		      (send histogram-proto :new 1 :show nil))))
X
;first is prob plot, second boxplot, third is histogram
X
X	 (plot1 (first graph1))
X	 (plot2 (second graph1))
X	 (plot3 (third graph1))
X	 (owner plot))
X    (mapcar #'(lambda (a) (send a :size 490 320)) graph1)
#+(or macintosh msdos)    (mapcar #'(lambda (a) (send a :margin 0 0 0 0)) graph1)
X    (send plot :margin 0 110 0 0) 
X    (send plot :menu nil)
X    (send plot1 :menu nil)
X    (send plot2 :menu nil)
X    (send plot3 :menu nil)
X    (send plot :size 490 320)
X    (send plot :tile 4)
X    (send plot1 :tile 1)
X    (send plot2 :tile 2)
X    (send plot3 :tile 3)
X    (send plot1 :variable-label 0 "Standardized Normal Quantile")
X    (send plot1 :variable-label 1 "Standardized Data Quantile")
X    (send plot :location 7 58)
X    (send plot :title "Univariate Data Plot Simulation")
X    (send plot1 :title "Normal Probability Plot")
X    (send plot2 :title "Box Plot")
X    (send plot1 :range 1 -3 3)
X    (send plot1 :range 0 -3 3)
X    (send plot2 :range 1 -3 3)
X    (send plot2 :range 0 0 2)
X    (send plot3 :range 0 -3 3)
X    (send plot1 :x-axis t t)
X    (send plot2 :x-axis nil)
X    (send plot3 :x-axis t t)
X    (send plot1 :y-axis t t)
X    (send plot2 :y-axis t)
X    (send plot3 :y-axis nil)
#+msdos (defmeth plot1 :do-click (x y m1 m2)
X	  (send plot1 :redraw))
X    (mapcar #'(lambda (a) (send a :add-slot 'graph)) graph1)
X    (mapcar 
X     #'(lambda (a)
X	 (defmeth a :graph (&optional (graph nil set))
X	   (if set (setf (slot-value 'graph) graph))
X	   (slot-value 'graph))) 
X     graph1)
X    (send plot3 :add-slot 'ctl)
X    (defmeth plot3 :ctl (&optional (ctl nil set))
X      (if set (setf (slot-value 'ctl) ctl))
X      (slot-value 'ctl))
X    (mapcar #'(lambda (a) (send a :graph plot)) graph1)
X    (mapcar 
X     #'(lambda (a)
X	 (defmeth a :close ()
X	   (when (send self :graph)
X		 (send (send self :graph) :graph1 
X		       (set-difference 
X			(send (send self :graph) :graph1) (list self)))
X		 (send (send self :graph) :close))
X	   (call-next-method))) 
X     graph1)
X    (defmeth plot2 :show-stats ()
X      (call-method graph-proto :showing-labels t)
X      (let ((n (+ (send self :num-points) 5)))
X	(send self :point-state (iseq n) 'selected)))
X
X    (defmeth plot2 :adjust-to-data ()
X       (let* ((iy (iseq 0 (- (send self :num-points) 1)))
X	      (y (send self :point-coordinate 1 iy))
X	      (range (get-nice-range (min y) (max y) 5)))
X	 (send self :range 1 (first range) (second range))))
X		  
X    (defmeth plot2 :show-stats-control ()
X      (call-method graph-proto :plot-controls)
X      #+(or macintosh msdos) (send self :margin 0 30 0 0)
X      (let* ((location (send self :locate-next-control))
X	     (control (send graph-control-proto :new
X			    :location location :title "Show Statistics")))
X	(defmeth control :do-action (&rest args) 
X	  (send plot2 :show-stats))
X	(send self :add-control control)))
X    #+unix (defmeth plot1 :plot-controls ()
X      (call-method graph-proto :plot-controls))
X    #+unix (send plot1 :plot-controls)
X    (send plot2 :show-stats-control)
X    (send plot3 :plot-controls)
X    (send plot :plot-controls)
X    (send plot3 :num-bins 11)
X    (send (send plot3 :ctl) :index 11)
X    (mapcar #'(lambda (a) (send a :show-window)) graph1)
X    (send plot :show-window)
#+(or msdos macintosh)    (send plot :size 400 200)
#+(or msdos macintosh)    (send plot1 :size 320 200)
#+(or msdos macintosh)    (send plot2 :size 320 200)
#+(or msdos macintosh)    (send plot3 :size 320 200)
#+(or msdos macintosh)    (send plot :location 10 28)
#+(or msdos macintosh)    (send plot1 :location 333 28)
#+(or msdos macintosh)    (send plot2 :location 10 250)
#+(or msdos macintosh)    (send plot3 :location 333 250)
X    plot))
X
#+msdos (defmeth graph-proto :overlay-click (x y m1 m2)
X		(if (not (dolist (ov (slot-value 'overlays))
X				(if (send ov :do-click x y m1 m2) 
X					(return t)))) (send self :redraw))
X					t)
;;;;; methods for actions after selecting parameter controls
X
(defmeth pp-plot-proto :n-chg (ind)
X  (if (< 0 (send (first (send self :graph1)) :num-points))
X      (let* ((nctl (select (send self :ctl) 2))
X	     (distributions (transpose (send self :return-distributions)))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (function1 (select distributions 4))
X	     (index (send self :index))
X	     (parms (send self :parms)))
X	(setf (select parms 2) (select (send nctl :sequence) ind))
X	(send self :parms parms)
X	(funcall (select function1 index))
X	(send self :draw-plots)
X	(send self :describe-dist)))
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select data or Distribution!" 170 20 0 0)))
X
(defmeth pp-plot-proto :parm1-chg (ind)
X  (if (< 0 (send (first (send self :graph1)) :num-points))
X      (let* ((p1ctl (select (send self :ctl) 0))
X	     (distributions (transpose (send self :return-distributions)))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (function1 (select distributions 4))
X	     (index (send self :index))
X	     (parms (send self :parms)))
X	(setf (select parms 0) (select (send p1ctl :sequence) ind))
X	(send self :parms parms)
X	(funcall (select function index))
X	(funcall (select function1 index))
X	(send self :draw-plots)
X	(send self :describe-dist)))
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select data or Distribution!" 170 20 0 0)))
X
(defmeth pp-plot-proto :parm2-chg (ind)
X  (if (< 0 (send (first (send self :graph1)) :num-points))
X      (let* ((p2ctl (select (send self :ctl) 1))
X	     (distributions (transpose (send self :return-distributions)))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (function1 (select distributions 4))
X	     (index (send self :index))
X	     (parms (send self :parms)))
X	(setf (select parms 1) (select (send p2ctl :sequence) ind))
X	(send self :parms parms)
X	(funcall (select function index))
X	(funcall (select function1 index))
X	(send self :draw-plots)
X	(send self :describe-dist)))
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select data or Distribution!" 170 20 0 0)))
X
(defun standardize (x)
X  (let* ((mu (mean x))
X	 (s (standard-deviation x)))
X    (/ (- x mu) s)))
X
;;;;; definitions of plot controls
X
(defproto pp-n-control-proto '() () slider-control-proto)
(defmeth pp-n-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :n-chg new))))  
X  (slot-value 'index))
X
(defproto pp-parm1-control-proto '() () slider-control-proto)
(defmeth pp-parm1-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :parm1-chg new))
X	))  
X  (slot-value 'index))
X
(defproto pp-parm2-control-proto '() () slider-control-proto)
(defmeth pp-parm2-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :parm2-chg new))))  
X  (slot-value 'index))
X
(defproto pp-sample-control-proto '() () graph-control-proto)
(defmeth pp-sample-control-proto :do-action (&rest args) 
X      (send (send self :graph) :new-sample))
X
X
SHAR_EOF
chmod 0745 Teach/PP/pp6.lsp ||
echo 'restore of Teach/PP/pp6.lsp failed'
Wc_c="`wc -c < 'Teach/PP/pp6.lsp'`"
test 30343 -eq "$Wc_c" ||
	echo 'Teach/PP/pp6.lsp: original size 30343, current size' "$Wc_c"
fi
# ============= Teach/PP/pp6.lsp~ ==============
if test -f 'Teach/PP/pp6.lsp~' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/PP/pp6.lsp~ (File already exists)'
else
echo 'x - extracting Teach/PP/pp6.lsp~ (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/PP/pp6.lsp~' &&
;; pp-PLOT-PROTO
;;
(defproto pp-plot-proto 
X  '(xdata ydata xlabel ylabel index graph1 parms parmn ctl ctl-loc ctl-loc1) 
X  () scatterplot-proto)
;;
;;;;;;;;;;;;;;;;;;;; set-up some slots and accessor methods
;;
(defmeth pp-plot-proto :ctl-loc (&optional (ctl-loc nil set))
X  (if set (setf (slot-value 'ctl-loc) ctl-loc))
X  (slot-value 'ctl-loc))
X
(defmeth pp-plot-proto :ctl-loc1 (&optional (ctl-loc1 nil set))
X  (if set (setf (slot-value 'ctl-loc1) ctl-loc1))
X  (slot-value 'ctl-loc1))
X
(defmeth pp-plot-proto :xdata (&optional (xdata nil set))
X  (if set (setf (slot-value 'xdata) (sort-data xdata)))
X  (slot-value 'xdata))
X
(defmeth pp-plot-proto :ydata (&optional (ydata nil set))
X  (if set (setf (slot-value 'ydata) ydata))
X  (slot-value 'ydata))
X
(defmeth pp-plot-proto :parms (&optional (parms nil set))
X  (if set (setf (slot-value 'parms) parms))
X  (slot-value 'parms))
X
(defmeth pp-plot-proto :parmn (&optional (parmn nil set))
X  (if set (setf (slot-value 'parmn) parmn))
X  (slot-value 'parmn))
X
(defmeth pp-plot-proto :index (&optional (index nil set))
X  (if set (setf (slot-value 'index) index))
X  (slot-value 'index))
X
(defmeth pp-plot-proto :xlabel (&optional (xlabel nil set))
X  (if set (setf (slot-value 'xlabel) xlabel))
X  (slot-value 'xlabel))
X
(defmeth pp-plot-proto :graph1 (&optional (graph1 nil set))
X  (if set (setf (slot-value 'graph1) graph1))
X  (slot-value 'graph1))
X
(defmeth pp-plot-proto :ylabel (&optional (ylabel nil set))
X  (if set (setf (slot-value 'ylabel) ylabel))
X  (slot-value 'ylabel))
X  
(defmeth pp-plot-proto :ctl (&optional (ctl nil set))
X  (if set (setf (slot-value 'ctl) ctl))
X  (slot-value 'ctl))
X
(defmeth pp-plot-proto :close ()
X  (when (send self :graph1)
X	(mapcar #'(lambda (a) (send a :graph nil)) (send self :graph1))
X	(mapcar #'(lambda (a) (send a :close)) (send self :graph1)))
X  (call-next-method)
X  (exit)
)
#+msdos (defmeth popup-menu-control-proto :do-click (x y a b)
X	  (let* ((graph (send self :graph))
X		 (loc (send self :location))
X		 (loc-x (first loc))
X		 (loc-y (+ 5 (second loc))))
X	    (when (and (< loc-x x (+ loc-x 10)) (< loc-y y (+ loc-y 10)))
X		  (send graph :paint-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X		  (send self :do-action (list a b))
;                 (send graph :while-button-down
;                       #'(lambda (x y) (send self :do-action nil)) nil)
X		  (send graph :erase-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X		  t)))
(defproto simulate-menu-proto '(menu) () popup-menu-control-proto)
X
(defmeth simulate-menu-proto :isnew (loc)
X  (call-next-method loc :title "Distributions"))
X
(defmeth simulate-menu-proto :menu ()
X  (let ((graph (send self :graph)))
X    (when (null (slot-value 'menu))
X	  (let* ((menu (send menu-proto :new "Menu"))
X		 (normal (send menu-item-proto :new "Normal" 
X		  :action  #'(lambda () (send graph :generate-data 0 t))))
X		 (chisq (send menu-item-proto :new "Chi-square" 
X		  :action #'(lambda () (send graph :generate-data 1 t))))
X		 (t (send menu-item-proto :new "T" 
X		  :action #'(lambda () (send graph :generate-data 2 t))))
X		 (unif (send menu-item-proto :new "Uniform" 
X		  :action #'(lambda () (send graph :generate-data 3 t))))
X		 (expon (send menu-item-proto :new "Exponential" 
X		  :action #'(lambda () (send graph :generate-data 4 t))))
X		 (cauchy (send menu-item-proto :new "Cauchy" 
X		  :action #'(lambda () (send graph :generate-data 5 t))))
X		 (binom (send menu-item-proto :new "Binomial" 
X		  :action #'(lambda () (send graph :generate-data 6 t))))
X		 (pois (send menu-item-proto :new "Poisson" 
X		  :action #'(lambda () (send graph :generate-data 7 t)))))
X	    
X	    (send menu :append-items 
X		  normal chisq t unif expon cauchy binom pois)
X	    (setf (slot-value 'menu) menu)))
X   (slot-value 'menu)))
X
(defproto data-menu-proto '(menu) () popup-menu-control-proto)
X
(defmeth data-menu-proto :isnew (loc)
X  (call-next-method loc :title "Select Data"))
X
(defmeth data-menu-proto :menu ()
X  (let ((graph (send self :graph))
X	(datalist (variables)))
X    (defmeth graph :data-redraw (item1)
X      (send self :clear nil)
X      (let* ((data (eval item1))
X	     (x (first data))
X	     (n (length x))
X	     (xttl (second data)))
X	(format t "~%")
X	(format t "X variable ~20a ~%" xttl) 
X	(prin1 x)(terpri)
X	(send self :parms nil)
X	(send self :delete-ctl)
X	(send self :x-axis nil)
X	(send self :xdata x)
X	(send self :xlabel xttl)
X	(send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X	(send self :draw-plots)
X	
X	))
X    (flet ((mk-item (item)
X		    (send menu-item-proto :new (string item) 
X			  :action  
X			  #'(lambda () (send graph :data-redraw item)))))
X	  (when (null (slot-value 'menu))
X		(let* ((menu (send menu-proto :new "Menu"))
X		       (items (mapcar #'mk-item datalist)))
X		  (flet ((append-item (item)
X				      (send menu :append-items item)))
X			(mapcar #'append-item items))
X		  (setf (slot-value 'menu) menu)))
X	  (slot-value 'menu))))
X
(defmeth pp-plot-proto :draw-plots (&optional set t)
X  (let* ((y (standardize (send self :xdata)))
X	 (plot (send self :graph1))
X	 (plot1 (first plot))
X	 (plot2 (second plot))
X	 (plot3 (third plot)))
X    (when (< 0 (send plot1 :num-points)) 
X	  (send plot1 :clear-points nil)
X	  (send plot2 :clear nil)
X	  (send plot3 :clear nil))
X    (send plot1 :add-points (send self :ydata) y)
X    (send plot2 :add-boxplot y :x 1)
X    (send plot3 :add-points y)
X    ))
X
(defmeth pp-plot-proto :new-sample ()
X  
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select data or Distribution!" 170 20 0 0)
X    (let* ((distributions (transpose (send self :return-distributions)))
X	   (sim-funs (select distributions 4))
X	   (function (select sim-funs (send self :index)))
X	   (plot (send self :graph1))
X	   (plot1 (first plot))
X	   (plot2 (second plot))
X	   (plot3 (third plot))
X	   (y (send self :xdata (funcall function))))
X      (send self :draw-data y))))
X
(defun round100 (x)
X  (/ (round (* 100 x)) 100))
X
(defmeth pp-plot-proto :draw-data (y)
X  (let* ((y (standardize y))
X	 (plot (send self :graph1))
X	 (plot1 (first plot))
X	 (plot2 (second plot))
X	 (plot3 (third plot)))
X     (when (< 0 (send plot1 :num-points)) 
X	  (send plot1 :clear-points nil)
X	  (send plot2 :clear nil)
X	  (send plot3 :clear nil))
X    (send plot1 :add-points (send self :ydata) y) 
X	 
X    (send plot2 :add-boxplot y :x 1)
X    (send plot3 :add-points y)
X    ))       
X
(defmeth pp-plot-proto :org-sample ()
X  (send self :draw-data (send self :xdata)))
X
(defmeth pp-plot-proto :new-control ()
X  (let* ((location (send self :locate-next-control))
X	 (owner self)
X	 (control (send graph-control-proto :new
X			:location location :title "New sample")))    
X    (defmeth control :do-action (&rest args) 
X      (send owner :new-sample))
X    (send self :add-control control)
X    (send self :redraw)))
X
;;
;;;;;;;;;;;;;;;;;;;;;; methods to select  "Parent Distribution" 
;; 
X
(defmeth pp-plot-proto :return-distributions ()
X  "Accessor method for slot :distribution-list."
X  (cond ((null (send self :has-slot 'distribution-list))
X	 (send self :make-distribution-list))
X	((null (slot-value 'distribution-list))
X	 (send self :make-distribution-list))
X	(t (slot-value 'distribution-list))))
X
(defmeth pp-plot-proto :make-distribution-list ()
X  "Creates slot containing the list of lists of distribution
X   names and corresponding activating functions."
X  (send self :add-slot 'distribution-list
X	(list
X	 (list "Normal" #'(lambda () (send self :draw-normal )) 
X	       (list "Mean:" "S.D.:" "Sample Size:")
X	       (list 0 1 4) #'(lambda () (send self :simulate-normal ))
X	       (list (iseq 0 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70) )) 
X	 (list "Chi-square"  #'(lambda () (send self :draw-chisquare ))
X	       (list "DF:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda () (send self :simulate-chisquare ))
X	       (list (iseq 1 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70) ))
X	 (list "t"  #'(lambda () (send self :draw-t  ))
X	       (list "DF:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda () (send self :simulate-t ))
X	       (list (iseq 1 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70)  ))
X	 (list "Uniform" #'(lambda () (send self :draw-uniform ))
X	       (list "a:" "b:" "Sample Size:")
X	       (list 0 1 4) #'(lambda () (send self :simulate-uniform ))
X	       (list (iseq 0 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70)  ))
X	 (list "Exponential" #'(lambda () (send self :draw-expon ))
X	       (list "Theta:" nil "Sample Size:")
X	       (list 1 1 4) #'(lambda () (send self :simulate-expon ))
X	       (list (iseq 1 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70)   ))
X	 (list "Cauchy" #'(lambda () (send self :draw-cauchy ))
X	       (list "Mean:" nil "Sample Size:")
X	       (list 0 0 4) #'(lambda () (send self :simulate-cauchy ))
X	       (list (iseq 0 20) (iseq 1 20)  (* 5 (iseq 2 20)) (iseq 50 70) ))
X	 (list "Binomial" #'(lambda () (send self :draw-binomial ))
X	       (list "n:" "p:" "Sample Size:")
X	       (list 10 0.05 4) #'(lambda () (send self :simulate-binomial ))
X	       (list (iseq 4 30) (* .05 (iseq 2 19)) (* 5 (iseq 2 20)) (iseq 50 70)))
X	 (list "Poisson" #'(lambda () (send self :draw-poisson ))
X	       (list "Lambda:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda () (send self :simulate-poisson ))
X	       (list (iseq 1 20) (iseq 0 20) (* 5 (iseq 2 20)) (iseq 50 70)  )))))
X
(defmeth pp-plot-proto :describe-dist ()
X  (let ((parms (send self :parms)))
X    (when parms
X	  (let* ((dist (send self :xlabel))
X		 (parmn (send self :parmn))
X		 (a (first parmn))
X		 (b (second parmn))
X		 (n (third parmn))
X		 (real-co (send self :real-to-canvas 
X				(first (send self :range 0)) 20))
X		 (x-co (first real-co))
X		 (y-co 30))
X	    (send self :draw-text 
X		  (concatenate 'string 
X			       "Distribution : " dist) x-co y-co 0 0)
X	    (send self :draw-text 
X		  (concatenate 'string 
X				a " " (num-to-string (first parms)))
X		  x-co (+ y-co 20) 0 0)
X	    (if b (send self :draw-text 
X			(concatenate 'string 
X				     b " " (num-to-string (second parms)))
X			x-co (+ 40 y-co) 0 0))
X	    (send self :erase-rect x-co (+ 40 y-co) 200 30)
X	    (send self :draw-text 
X		  (concatenate 'string 
X				n " " (num-to-string (third parms)))
X		  x-co (+ 60 y-co) 0 0)))))
X
(defmeth pp-plot-proto :delete-ctl ()
X  (send self :ctl-loc 
X        (mapcar #'(lambda (a) (send a :location)) (send self :ctl)))
X  (mapcar #'(lambda (a) (send self :delete-control a)) (send self :ctl))
X  (send self :ctl nil))
X
(defmeth pp-plot-proto :add-ctl ()
X (let* ((loc (send self :ctl-loc))
X	(a (send pp-parm1-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (first loc)
X		 :title "parm1" :length (send self :slider-width)
X		 :index 0))    
X	(b (send pp-parm2-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (second loc)
X		 :title "parm2" :length (send self :slider-width)
X		 :index 0))
X	(n (send pp-n-control-proto :new 
X		  (* 4 (iseq 1 20))
X		  :location (third loc)
X		  :title "Sample Size 1" :length (send self :slider-width)
X		  :index 0))
X	(sam (send pp-sample-control-proto :new 
X		   :location (fourth loc)
X		   :title "New Sample"))
X	)
X   (send self :add-control a)
X   (send self :add-control b)
X   (send self :add-control n)
X   (send self :add-control sam)
X   (send self :ctl (list a b n sam))))
X
X  
(defmeth pp-plot-proto :delete-parm2-ctl ()
X  (send self :ctl-loc1 (send (select (send self :ctl) 1) :location))
X  (send self :delete-control (select (send self :ctl) 1))
X  (setf (select (send self :ctl) 1) nil))
X
(defmeth pp-plot-proto :add-parm2-ctl ()
X  (let* ((ctl (send self :ctl))
X	 (a (select ctl 0))
X	 (b (send pp-parm2-control-proto :new 
X		   (* 4 (iseq 1 20))
X		   :location (send self :ctl-loc1)
X		   :title "parm2" :length (send self :slider-width)
X		   :index 0))
X	 (n1 (select ctl 2))
X	 (ns (select ctl 3)))
X      (send self :ctl (list a b n1 ns))
X      (send self :add-control b)
X      b))
X
(defmeth pp-plot-proto :generate-data (ind getparms)
X  (if getparms
X      (let* ((distributions (transpose (send self :return-distributions)))
X	     (name (first distributions))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (parmvalu (fourth distributions))
X	     (function2 (select distributions 4))
X	     (dist1 (select distributions 4))
X	     (plot (send self :graph1))
X	     (plot1 (select plot 0))
X	     (plot2 (select plot 1))
X	     (plot3 (select plot 2))
X	     (seqs (select distributions 5))
X	     (seq (select seqs ind))
X	     (parmn (select parmname ind))
X	     (ctl (if (send self :ctl) (send self :ctl) (send self :add-ctl)))
X	     (n1 (select ctl 2))
X	     (a (select ctl 0))
X	     (b (if (select ctl 1) (select ctl 1) (send self :add-parm2-ctl))))
X	(if (< 0 (send plot1 :num-points))
X	    (mapcar #'(lambda (a) (send a :clear)) plot))
X	(send self :xlabel (select name ind))
X	(send self :parmn parmn)
X	(send n1 :title "Sample size")
X	(send a :title (select parmn 0))
X	(if (select parmn 1) (send b :title (select parmn 1))
X	  (send self :delete-parm2-ctl))
X	(send self :index ind)
X	(send self :parms (list (select (select seq 0) 0)
X				(select (select seq 1) 0) 
X				(select (select seq 2) 0)))
X	(send n1 :sequence (select seq 2))
X	(send a :sequence (select seq 0))
X	(if (select parmn 1) (send b :sequence (select seq 1)))
X	(send n1 :index 0)
X	(send a :index 0)
X	(if (select parmn 1) (send b :index 0))
X	(send self :index ind)
X	(funcall (select function ind))
X	(funcall (select function2 ind))
X	(send self :draw-plots)
X	(send self :describe-dist)
X
;       (send self :la-draw)
)))
X
(defmeth pp-plot-proto :redraw ()
X  (call-next-method)
X  (send self :describe-dist)) 
X
(defmeth pp-plot-proto :draw-normal (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((mu (first parms))
X		      (sigma (second parms))
X		      (xmin (+ mu (* sigma (normal-quant .01))))
X		      (xmax (+ mu (* sigma (normal-quant .99))))
X		      (x (rseq xmin xmax 50)) 
X		      (y (mapcar #'normal-dens (/ (- x mu) sigma))))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth pp-plot-proto :add-lines2 (x y)
X  (mapcar #'(lambda (a b) (send self :add-lines 
X				(list (list a a) (list 0 b)))) x y))
X
(defmeth pp-plot-proto :draw-fun (xmin xmax x y) 
X  (let ((parms (send self :parms)))
X    (when parms 
X	  (let* ((mu (first parms))
X		 (sigma (sqrt (second parms)))
X		 (maxy (max y))
X		 (nice-range (get-nice-range xmin xmax 7))
X		 (y (* (/ 1 maxy) y))
X		 (n1 (first nice-range))
X		 (n2 (second nice-range))
X		 (n3 (third nice-range))
X		 (graph1 (send self :graph1))
X		 (plot1 (first graph1))
X		 (plot1 (second graph1))
X		 (plot1 (third graph1))
)
X	    (send self :clear nil)
X	    (send self :range 0 n1 n2)
X	    (send self :x-axis t t 5)
X
X	    (if (> (length x) 49) (send self :add-lines (list x y))
X	      (send self :add-lines2 x y))
X	    (if (< 0 (send (select (send self :graph1) 0) :num-points))
X		(mapcar #'(lambda (a) (send a :clear)) 
X			(send self :graph1)))))))
X
(defmeth pp-plot-proto :draw-chisquare (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms))
X		       (xmax (chisq-quant .99 df))
X		       (xmin 0)
X		       (x (rseq xmin xmax 50)) 
X		      
X		       (y (mapcar #'(lambda (i) (chisq-dens i df)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth pp-plot-proto :draw-t (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms))
X		       (xmax (t-quant .99 df))
X		       (xmin (t-quant .01 df))
X		       (x (rseq xmin xmax 50)) 
X		    
X		       (y (mapcar #'(lambda (i) (t-dens i df)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defun unif-dens (a b x)
X  (let* ((dis (- b a))
X	 (dens (/ 1 dis))
X	 (ans (if (and (< a x) (> b x)) dens 0)))
X    ans))
X
(defmeth pp-plot-proto :draw-uniform (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((a (first parms))
X		       (b (second parms))
X		       (n (third parms))
X		       (xmax (+ b .5))
X		       (xmin (- a .5))
X		       (den (/ 1 (- b a)))
X		       (x (list xmin a a b b xmax))  
X		       (y (list 0 0 den den 0 0))
X		       (nice-range (get-nice-range xmin xmax 7))
X		       (y (* (/ 1 den) y))
X		       (n1 (first nice-range))
X		       (n2 (second nice-range))
X		       (n3 (third nice-range)))
X		  (send self :clear nil)
X		  (send self :range 0 n1 n2)
X		  (send self :x-axis t t 5)
X		  (send self :add-lines (list x y))))))
X
X
(defmeth pp-plot-proto :draw-expon (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((theta (first parms))
X		       (n (third parms))
X		       (xmax (* theta (gamma-quant .99 1)))
X		       (xmin (* theta (gamma-quant .01 1)))
X		       (x (rseq xmin xmax 50)) 
X		   
X		       (y (mapcar 
X			   #'(lambda (i) 
X			       (* theta (gamma-dens i 1))) 
X			   (/ x theta))))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth pp-plot-proto :draw-cauchy (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((mu (first parms))
X		       (n (third parms))
X		       (xmax (+ mu (cauchy-quant .99)))
X		       (xmin (+ mu (cauchy-quant .01)))
X		       (x (rseq xmin xmax 50)) 
X		       
X		       (y (mapcar #' (lambda (i) 
X				       (cauchy-dens i)) (- x mu))))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth pp-plot-proto :draw-binomial (&optional set)
X (let ((parms (send self :parms)))
X    (when parms (let* ((m (first parms))
X		       (p (second parms))
X		       (n (third parms))
X		       (xmax m)
X		       (xmin 0)
X		       (x (iseq 0 m)) 
X		     
X		       (y (mapcar #' (lambda (i) 
X				       (binomial-pmf i m p)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth pp-plot-proto :draw-poisson (&optional set)
X (let ((parms (send self :parms)))
X    (when parms (let* ((lamda (first parms))
X		       (n (third parms))
X		       (xmax (round (poisson-quant .9999 lamda)))
X		       (xmin 0)
X		       (x (iseq xmin xmax)) 
X		       
X		       (y (mapcar #' (lambda (i) 
X				       (poisson-pmf i lamda)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
X
(defmeth pp-plot-proto :simulate-normal ()
X  (let ((parms (send self :parms)))
X    (when parms (let* (
X		       (mu (first parms))
X		       (sigma (second parms))
X		       (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (+ mu (* sigma (normal-rand n))))
X		  
))))
X
(defmeth pp-plot-proto :simulate-chisquare ()
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (chisq-rand n df))
X		  ))))                  
X
(defmeth pp-plot-proto :simulate-t ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((df (first parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (t-rand n df))
X		  ))))
X
(defmeth pp-plot-proto :simulate-uniform ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((a (first parms))
X		      (b (second parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (+ a (* (- b a) (uniform-rand n))))
X		  ))))
X
(defmeth pp-plot-proto :simulate-expon ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((theta (first parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata 
X			(send self :xdata (* theta (gamma-rand n 1))))
X		  ))))
X
(defmeth pp-plot-proto :simulate-cauchy ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((mu (first parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (+ mu (cauchy-rand n)))
X		  ))))
X
(defmeth pp-plot-proto :simulate-binomial ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((n (first parms))
X		      (p (second parms))
X		      (m (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq m) 1) (+ m 1))))
X		  (send self :xdata (binomial-rand m n p))
X		  ))))
X
(defmeth pp-plot-proto :simulate-poisson ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((lamda (first parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (poisson-rand n lamda))
X		  ))))
X
(defmeth graph-proto :plot-controls () 
X  (let* ((margin (send self :margin))
X	 (left (send self :plot-control-left-margin))
X	 (top 12)
X	 (n (+ margin (list left top 0 0))))
X    (apply #'send self :margin n)
X    (send self :add-slot 'overlay-loc '(10 10))
X    (apply #'send self :size (+ (send self :size) (list left top)))
X    #+X11 (send self :size 490 320); fits 1/4 of a 14" Sony color monitor
X    (send self :resize)))
X
(defmeth pp-plot-proto :plot-controls ()
X  (call-method graph-proto :plot-controls)
X  (send self :add-control (send  simulate-menu-proto :new 
X				 (send self :locate-next-control)))
X  (send self :add-control (send  data-menu-proto :new 
X				 (send self :locate-next-control)))
X  (let ((a (send pp-parm1-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (send self :locate-next-control :height 2)
X		 :title "parm1" :length (send self :slider-width)
X		 :index 0))    
X	(b (send pp-parm2-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (send self :locate-next-control :height 2)
X		 :title "parm2" :length (send self :slider-width)
X		 :index 0))
X	(n (send pp-n-control-proto :new 
X		  (* 4 (iseq 1 20))
X		  :location (send self :locate-next-control :height 2)
X		  :title "Sample Size 1" :length (send self :slider-width)
X		  :index 0))
X	(sam (send pp-sample-control-proto :new 
X		   :location (send self :locate-next-control)
X		   :title "New Sample"))
)
X    (send self :ctl (list a b n sam))
X    (send self :add-control a)
X    (send self :add-control b)
X    (send self :add-control n)
X    (send self :add-control sam)))
X
(defun pp ()
X  (let* ((plot (send pp-plot-proto :new 5 :show nil))
X	 (graph1 
X	  (send plot :graph1 
X		(list (send scatterplot-proto :new 2 :show nil)
X		      (send scatterplot-proto :new 2 :show nil)
X		      (send histogram-proto :new 1 :show nil))))
X
;first is prob plot, second boxplot, third is histogram
X
X	 (plot1 (first graph1))
X	 (plot2 (second graph1))
X	 (plot3 (third graph1))
X	 (owner plot))
;    (mapcar #'(lambda (a) (send a :size 490 320)) graph1)
#+(or macintosh msdos)    (mapcar #'(lambda (a) (send a :margin 0 0 0 0)) graph1)
X    (send plot :margin 0 110 0 0) 
X    (send plot :menu nil)
X    (send plot1 :menu nil)
X    (send plot2 :menu nil)
X    (send plot3 :menu nil)
;    (send plot :size 490 320)
X    (send plot :tile 4)
X    (send plot1 :tile 1)
X    (send plot2 :tile 2)
X    (send plot3 :tile 3)
X    (send plot1 :variable-label 0 "Standardized Normal Quantile")
X    (send plot1 :variable-label 1 "Standardized Data Quantile")
X    (send plot :location 7 58)
X    (send plot :title "Univariate Data Plot Simulation")
X    (send plot1 :title "Normal Probability Plot")
X    (send plot2 :title "Box Plot")
X    (send plot1 :range 1 -3 3)
X    (send plot1 :range 0 -3 3)
X    (send plot2 :range 1 -3 3)
X    (send plot2 :range 0 0 2)
X    (send plot3 :range 0 -3 3)
X    (send plot1 :x-axis t t)
X    (send plot2 :x-axis nil)
X    (send plot3 :x-axis t t)
X    (send plot1 :y-axis t t)
X    (send plot2 :y-axis t)
X    (send plot3 :y-axis nil)
X    (defmeth plot1 :do-click (x y m1 m2)
X	(send plot1 :redraw))
X    (mapcar #'(lambda (a) (send a :add-slot 'graph)) graph1)
X    (mapcar 
X     #'(lambda (a)
X	 (defmeth a :graph (&optional (graph nil set))
X	   (if set (setf (slot-value 'graph) graph))
X	   (slot-value 'graph))) 
X     graph1)
X    (send plot3 :add-slot 'ctl)
X    (defmeth plot3 :ctl (&optional (ctl nil set))
X      (if set (setf (slot-value 'ctl) ctl))
X      (slot-value 'ctl))
X    (mapcar #'(lambda (a) (send a :graph plot)) graph1)
X    (mapcar 
X     #'(lambda (a)
X	 (defmeth a :close ()
X	   (when (send self :graph)
X		 (send (send self :graph) :graph1 
X		       (set-difference 
X			(send (send self :graph) :graph1) (list self)))
X		 (send (send self :graph) :close))
X	   (call-next-method))) 
X     graph1)
;    (mapcar 
;     #'(lambda (a) 
;        (defmeth a :adjust-control ()
;          (let* ((location (send self :locate-next-control))
;                 (owner self)
;                 (control (send graph-control-proto :new
;                       :location location :title "Adjust to Data")))    
;            (defmeth control :do-action (&rest args) 
;              (send owner :adjust-to-data))
;            (send self :add-control control))))
;     graph1)    
X    (defmeth plot2 :show-stats ()
X      (call-method graph-proto :showing-labels t)
X      (let ((n (+ (send self :num-points) 5)))
X	(send self :point-state (iseq n) 'selected)))
X
X    (defmeth plot2 :adjust-to-data ()
X       (let* ((iy (iseq 0 (- (send self :num-points) 1)))
X	      (y (send self :point-coordinate 1 iy))
X	      (range (get-nice-range (min y) (max y) 5)))
X	 (send self :range 1 (first range) (second range))))
X		  
X    (defmeth plot2 :show-stats-control ()
X      (call-method graph-proto :plot-controls)
X      #+(or macintosh msdos) (send self :margin 0 30 0 0)
X      (let* ((location (send self :locate-next-control))
X	     (control (send graph-control-proto :new
X			    :location location :title "Show Statistics")))
X	(defmeth control :do-action (&rest args) 
X	  (send plot2 :show-stats))
X	(send self :add-control control)))
X    #+unix (defmeth plot1 :plot-controls ()
X      (call-method graph-proto :plot-controls))
X    #+unix (send plot1 :plot-controls)
X    (send plot2 :show-stats-control)
X    (send plot3 :plot-controls)
X    (send plot :plot-controls)
;    (defmeth plot :adjust-control ()
;      (let* ((location (send self :locate-next-control))
;            (owner self)
;            (control (send graph-control-proto :new
;                           :location location :title "Adjust to Data")))    
;       (defmeth control :do-action (&rest args)
;         (mapcar #'(lambda (a) (send a :adjust-to-data)) (send owner :graph1)))
;       (send self :add-control control)))
;    (mapcar #'(lambda (a) (send a :adjust-control)) graph1)
;    (send plot :adjust-control)
X    (send plot3 :num-bins 11)
X    (send (send plot3 :ctl) :index 11)
X    (mapcar #'(lambda (a) (send a :show-window)) graph1)
X    (send plot :show-window)
#+(or msdos macintosh)    (send plot :size 400 200)
#+(or msdos macintosh)    (send plot1 :size 320 200)
#+(or msdos macintosh)    (send plot2 :size 320 200)
#+(or msdos macintosh)    (send plot3 :size 320 200)
#+(or msdos macintosh)    (send plot :location 10 28)
#+(or msdos macintosh)    (send plot1 :location 333 28)
#+(or msdos macintosh)    (send plot2 :location 10 250)
#+(or msdos macintosh)    (send plot3 :location 333 250)
X
X    plot))
X
#+msdos (defmeth graph-proto :overlay-click (x y m1 m2)
X		(if (not (dolist (ov (slot-value 'overlays))
X				(if (send ov :do-click x y m1 m2) 
X					(return t)))) (send self :redraw))
X					t)
X
(defmeth histogram-proto :plot-controls () 
X  (call-next-method) 
X  (send self :add-control 
X	(send self :ctl 
X	      (send hist-control-proto :new (iseq 2 20)
X		    :location (send self :locate-next-control :height 2)
X		    :title "NumBins" :length (send self :slider-width)
X		    :index)))
X  (send self :install-kernel-density))
X
(defmeth pp-plot-proto :n-chg (ind)
X  (if (< 0 (send (first (send self :graph1)) :num-points))
X      (let* ((nctl (select (send self :ctl) 2))
X	     (distributions (transpose (send self :return-distributions)))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (function1 (select distributions 4))
X	     (index (send self :index))
X	     (parms (send self :parms)))
X	(setf (select parms 2) (select (send nctl :sequence) ind))
X	(send self :parms parms)
X	(funcall (select function1 index))
X	(send self :draw-plots)
X	(send self :describe-dist)
X	))
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select data or Distribution!" 170 20 0 0)))
X
X
X
(defmeth pp-plot-proto :parm1-chg (ind)
X  (if (< 0 (send (first (send self :graph1)) :num-points))
X      (let* ((p1ctl (select (send self :ctl) 0))
X	     (distributions (transpose (send self :return-distributions)))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (function1 (select distributions 4))
X	     (index (send self :index))
X	     (parms (send self :parms)))
X	(setf (select parms 0) (select (send p1ctl :sequence) ind))
X	(send self :parms parms)
X	(funcall (select function index))
X	(funcall (select function1 index))
X	(send self :draw-plots)
X	(send self :describe-dist)
X	))
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select data or Distribution!" 170 20 0 0)))
X
(defmeth pp-plot-proto :parm2-chg (ind)
X  (if (< 0 (send (first (send self :graph1)) :num-points))
X      (let* ((p2ctl (select (send self :ctl) 1))
X	     (distributions (transpose (send self :return-distributions)))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (function1 (select distributions 4))
X	     (index (send self :index))
X	     (parms (send self :parms)))
X	(setf (select parms 1) (select (send p2ctl :sequence) ind))
X	(send self :parms parms)
X	(funcall (select function index))
X	(funcall (select function1 index))
X	(send self :draw-plots)
X	(send self :describe-dist)
X	))
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select data or Distribution!" 170 20 0 0)))
X
(defun standardize (x)
X  (let* ((mu (mean x))
X	 (s (standard-deviation x)))
X    (/ (- x mu) s)))
X
(defproto pp-n-control-proto '() () slider-control-proto)
(defmeth pp-n-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :n-chg new))))  
X  (slot-value 'index))
X
(defproto pp-parm1-control-proto '() () slider-control-proto)
(defmeth pp-parm1-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :parm1-chg new))
X	))  
X  (slot-value 'index))
X
(defproto pp-parm2-control-proto '() () slider-control-proto)
(defmeth pp-parm2-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :parm2-chg new))))  
X  (slot-value 'index))
X
(defproto pp-sample-control-proto '() () graph-control-proto)
(defmeth pp-sample-control-proto :do-action (&rest args) 
X      (send (send self :graph) :new-sample))
X
SHAR_EOF
chmod 0745 Teach/PP/pp6.lsp~ ||
echo 'restore of Teach/PP/pp6.lsp~ failed'
Wc_c="`wc -c < 'Teach/PP/pp6.lsp~'`"
test 30922 -eq "$Wc_c" ||
	echo 'Teach/PP/pp6.lsp~: original size 30922, current size' "$Wc_c"
fi
# ============= Teach/README ==============
if test -f 'Teach/README' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/README (File already exists)'
else
echo 'x - extracting Teach/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/README' &&
Teach modules are instructional tools for basic statistics. 
They consist of the following modules: 
X
Title				Command to run
------------------------------------------------
Confidence Interval		teach_ci
Central Limit Theorem		teach_clt
Least Square			teach_ls
Univariate Data Plot		teach_pp
Sampling Distribution		teach_sd
Transformation			teach_tr
-------------------------------------------------
X
As an example, to run the Confidence Interval module enter 'teach_ci'
at the unix prompt, i.e. enter
X
X                       % teach_ci
X
You may copy and distribute these modules for educational or research
purposes, as long as you distribute the copyright notice, the file
COPYRIGHT, along with the program.  If you copy the program, you must
copy the file COPYRIGHT.  Other uses are allowed under the GNU library
general public license (see file GNU.COPYING for details).
X
If  any bugs are detected or if you have any suggestions for
improving these modules, send email to mervyn@iastate.edu, or 
sts@iastate.edu.  We'll seriously consider these for incorporation 
into future versions of Teach.
X
-- Mervyn Marasinghe, William Q Meeker, Dianne Cook, and Tae-Sung Shin.
X
X
X
X
X
X
X
SHAR_EOF
chmod 0660 Teach/README ||
echo 'restore of Teach/README failed'
Wc_c="`wc -c < 'Teach/README'`"
test 1180 -eq "$Wc_c" ||
	echo 'Teach/README: original size 1180, current size' "$Wc_c"
fi
# ============= Teach/SD/sd3.lsp ==============
if test ! -d 'Teach/SD'; then
    echo 'x - creating directory Teach/SD'
    mkdir 'Teach/SD'
fi
if test -f 'Teach/SD/sd3.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/SD/sd3.lsp (File already exists)'
else
echo 'x - extracting Teach/SD/sd3.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/SD/sd3.lsp' &&
;; sd-module written by Tae-Sung Shin
;;
(defproto sd-plot-proto '(dist stat statn index graph1 parms ctl xlabel ctl-loc)
() scatterplot-proto)
;;
;;;;;;;;;;;;;;;;;;;; set-up some slots and accessor methods
;;
(defmeth sd-plot-proto :ctl-loc (&optional (ctl-loc nil set))
X  (if set (setf (slot-value 'ctl-loc) ctl-loc))
X  (slot-value 'ctl-loc))
X
(defmeth sd-plot-proto :dist (&optional (dist nil set))
X  (if set (setf (slot-value 'dist) dist))
X  (slot-value 'dist))
X
(defmeth sd-plot-proto :stat (&optional (stat nil set))
X  (if set (setf (slot-value 'stat) stat))
X  (slot-value 'stat))
X
(defmeth sd-plot-proto :parms (&optional (parms nil set))
X  (if set (setf (slot-value 'parms) parms))
X  (slot-value 'parms))
X
(defmeth sd-plot-proto :index (&optional (index nil set))
X  (if set (setf (slot-value 'index) index))
X  (slot-value 'index))
X
(defmeth sd-plot-proto :statn (&optional (statn nil set))
X  (if set (setf (slot-value 'statn) statn))
X  (slot-value 'statn))
X
(defmeth sd-plot-proto :graph1 (&optional (graph1 nil set))
X  (if set (setf (slot-value 'graph1) graph1))
X  (slot-value 'graph1))
X 
(defmeth sd-plot-proto :ctl (&optional (ctl nil set))
X  (if set (setf (slot-value 'ctl) ctl))
X  (slot-value 'ctl))
X
(defmeth sd-plot-proto :xlabel (&optional (xlabel nil set))
X  (if set (setf (slot-value 'xlabel) xlabel))
X  (slot-value 'xlabel))
X
(defmeth sd-plot-proto :close ()
X  (when (send self :graph1)
X	(mapcar #'(lambda (a) (send a :graph nil)) (send self :graph1))
X	(mapcar #'(lambda (a) (send a :close)) (send self :graph1)))
X  (call-next-method)
X  (exit))
X
#+msdos (defmeth popup-menu-control-proto :do-click (x y a b)
X	  (let* ((graph (send self :graph))
X		 (loc (send self :location))
X		 (loc-x (first loc))
X		 (loc-y (+ 5 (second loc))))
X	    (when (and (< loc-x x (+ loc-x 10)) (< loc-y y (+ loc-y 10)))
X		  (send graph :paint-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X		  (send self :do-action (list a b))
X		  (send graph :erase-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X		  t)))
X
;;;;; def of histogram 1 proto
X
(defproto hist1-proto '(num graph ctl) () histogram-proto)
(defmeth hist1-proto :ctl (&optional (ctl nil set))
X  (if set (setf (slot-value 'ctl) ctl))
X  (slot-value 'ctl))
(defmeth hist1-proto :num (&optional (num nil set))
X  (if set (setf (slot-value 'num) num))
X  (slot-value 'num))
(defmeth hist1-proto :graph (&optional (graph nil set))
X  (if set (setf (slot-value 'graph) graph))
X  (slot-value 'graph))
(defmeth hist1-proto :close ()
X  (when (send self :graph)
X	(send (send self :graph) :graph1 
X	      (set-difference (send (send self :graph) :graph1) (list self)))
X	(send (send self :graph) :close))
X  (call-next-method))   
(defmeth hist1-proto :redraw ()
X  (call-next-method)
X  (if (send self :num) 
X      (send self :draw-text 
X	    (concatenate 'string "Sample Size : "
X			 (num-to-string (send self :num))) 200 20 0 0))
)
X
X
(defmeth sd-plot-proto :start-sim-control ()
X    (let* ((location (send self :locate-next-control))
X	   (control (send graph-control-proto :new
X			  :location location :title "Start Simulation"))
X	   (owner self))
X      (defmeth control :do-action (&rest args)
X	(send owner :draw-text "Computing.." 200 60 0 0)
X	(send owner :start-sim))
X      (send self :add-control control)))
X
;;;;; distribution selection control set up
X
(defproto simulate-menu-proto '(menu) () popup-menu-control-proto)
X
(defmeth simulate-menu-proto :isnew (loc)
X  (call-next-method loc :title "Distributions"))
X
(defmeth simulate-menu-proto :menu ()
X  (let ((graph (send self :graph)))
X    (when (null (slot-value 'menu))
X	  (let* ((menu (send menu-proto :new "Menu"))
X		 (normal (send menu-item-proto :new "Normal" 
X		  :action  #'(lambda () (send graph :generate-data 0 t))))
X		 (chisq (send menu-item-proto :new "Chi-square" 
X		  :action #'(lambda () (send graph :generate-data 1 t))))
X		 (t (send menu-item-proto :new "T" 
X		  :action #'(lambda () (send graph :generate-data 2 t))))
X		 (unif (send menu-item-proto :new "Uniform" 
X		  :action #'(lambda () (send graph :generate-data 3 t))))
X		 (expon (send menu-item-proto :new "Exponential" 
X		  :action #'(lambda () (send graph :generate-data 4 t))))
X		 (cauchy (send menu-item-proto :new "Cauchy" 
X		  :action #'(lambda () (send graph :generate-data 5 t))))
X		 (binom (send menu-item-proto :new "Binomial" 
X		  :action #'(lambda () (send graph :generate-data 6 t))))
X		 (pois (send menu-item-proto :new "Poisson" 
X		  :action #'(lambda () (send graph :generate-data 7 t)))))
X	    
X	    (send menu :append-items 
X		  normal chisq t unif expon cauchy binom pois)
X	    (setf (slot-value 'menu) menu)))
X   (slot-value 'menu)))
X
;;; statistic selection control set up
X
(defproto stat-menu-proto '(menu) () popup-menu-control-proto)
(defmeth stat-menu-proto :isnew (loc)
X  (call-next-method loc :title "Statistic"))
(defmeth stat-menu-proto :menu ()
X  (let ((graph (send self :graph)))
X    (when (null (slot-value 'menu))
X	  (let* ((menu (send menu-proto :new "Menu"))
X		 (sm (send menu-item-proto :new "Sum" 
X			   :action  #'(lambda () (send graph :start-p 1))))
X		 (m (send menu-item-proto :new "Mean" 
X			  :action #'(lambda () (send graph :start-p 2))))
X		 (me (send menu-item-proto :new "Median" 
X			   :action #'(lambda () (send graph :start-p 3))))
X		 (sd (send menu-item-proto :new "SD" 
X			   :action #'(lambda () (send graph :start-p 4))))
X		 (rng (send menu-item-proto :new "Range" 
X			    :action #'(lambda () (send graph :start-p 5))))
X		 (sd2 (send menu-item-proto :new "S^2" 
X			    :action #'(lambda () (send graph :start-p 6))))
X		 (t (send menu-item-proto :new "T" 
X			  :action #'(lambda () (send graph :start-p 7)))))
X	    (send menu :append-items 
X		  sm m me sd rng sd2 t)
X	    (setf (slot-value 'menu) menu)))
X    (slot-value 'menu)))
X
(defun var (x)
X  (^ (standard-deviation x) 2))
X
;;;;; method for actions after selecting statistic
X
(defmeth sd-plot-proto :start-p (id)
X  (send self :stat 
X	(case id
X	      (1 #'sum)
X	      (2 #'mean)
X	      (3 #'median)
X	      (4 #'standard-deviation)
X	      (5 #'interquartile-range)
X	      (6 #'var)
X	      (7 #'t-stat)))
X  (send self :statn 
X	(case id
X	      (1 "Sum")
X	      (2 "Mean")
X	      (3 "Median")
X	      (4 "Standard deviation")
X	      (5 "Interquartile-range")
X	      (6 "Sample Variance")
X	      (7 "T Statistic")))
X  (send self :erase-rect 300 10 200 20) 
X  (send self :draw-text 
X	(concatenate 'string "Statistic : " (send self :statn))
X	200 20 0 0)
X  (send self :erase-rect 300 30 200 20)
X  (send self :draw-text 
X	(concatenate 'string "Distribution : " (send self :xlabel))
X	200 40 0 0)
X  (let ((graph1 (send self :graph1)))
X    (send (first graph1) :title 
X	  (concatenate 'string "Histogram 1 of Sample " 
X		       (send self :statn)))
X    (send (second graph1) :title 
X	  (concatenate 'string "Histogram 2 of Sample " 
X		       (send self :statn)))
X    (send (third graph1) :title 
X	  (concatenate 'string "Histogram 3 of Sample " 
X		       (send self :statn))))    
X  (if (< 0 (send (select (send self :graph1) 0) :num-points))
X      (mapcar #'(lambda (a) (send a :clear)) (send self :graph1))))
X
X
(defmeth sd-plot-proto :redraw ()
X  (call-next-method)
X  (send self :draw-text 
X	(concatenate 'string "Statistic : " (send self :statn))
X	200 20 0 0)
X  (send self :draw-text 
X	(concatenate 'string "Distribution : " (send self :xlabel))
X	200 40 0 0))
X
;;;;; start simulation
X
(defmeth sd-plot-proto :start-sim ()
X  (send self :draw-text "Computing.." 200 60 0 0)
X  (if (not (send self :dist)) (send self :draw-text 
X				    "First, Select Distribution!" 170 80 0 0)
X    (let* ((stat (send self :stat))
X	   (hist (send self :graph1))
X	   (hist1 (select hist 0))
X	   (hist2 (select hist 1))
X	   (hist3 (select hist 2))
X	   (nsize (send self :parms))
X	   (n1 (third nsize))
X	   (n2 (fourth nsize))
X	   (n3 (round (sqrt (* n1 n2))))
X	   (ctl (mapcar #'(lambda (a) (send a :ctl)) hist))
X	   (dist (send self :dist))
X	   (da (funcall dist n2)))
X      (send hist1 :num n1)
X      (send hist2 :num n2)
X      (send hist3 :num n3)
X      (if (< 0 (send hist1 :num-points))
X	(mapcar #'(lambda (a) (send a :clear)) hist))
X    (mapcar #'(lambda (a b) (send a :add-points b)) hist da)
X    (mapcar #'(lambda (a) (send a :adjust-to-data)) hist)
X    (mapcar #'(lambda (a b) (send b :index (send a :num-bins))) hist ctl)
X    (send self :erase-rect 200 50 140 20))))
X
(defun choose (x n) (member (select x (- (length x) n)) x))
X
(defun t-stat (x)
X  (/ (mean x) (standard-deviation x)))
X
;;
;;;;;;;;;;;;;;;;;;;;;; methods to select  Distribution 
;; 
X
(defmeth sd-plot-proto :return-distributions ()
X  "Accessor method for slot :distribution-list."
X  (cond ((null (send self :has-slot 'distribution-list))
X	 (send self :make-distribution-list))
X	((null (slot-value 'distribution-list))
X	 (send self :make-distribution-list))
X	(t (slot-value 'distribution-list))))
X
(defmeth sd-plot-proto :make-distribution-list ()
X  "Creates slot containing the list of lists of distribution
X   names and corresponding activating functions."
X  (send self :add-slot 'distribution-list
X	(list
X	 (list "Normal" #'(lambda (a) (send self :draw-normal a)) 
X	       (list "Mean:" "S.D.:" "Sample Size:")
X	       (list 0 1 4) #'(lambda (a) (send self :simulate-normal a))
X	       (list (iseq 0 20) (iseq 1 20) (iseq 4 20)  '(50 51 52 53 54 55 56 57 58 59 60 65 70 75 80 85 90 95 100 110 120 130 140 150 160 170 180 190 200) )) 
X	 (list "Chi-square"  #'(lambda (a) (send self :draw-chisquare a))
X	       (list "DF:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda (a) (send self :simulate-chisquare a))
X	       (list (iseq 1 20) (iseq 1 20) (iseq 4 20) '(50 51 52 53 54 55 56 57 58 59 60 65 70 75 80 85 90 95 100 110 120 130 140 150 160 170 180 190 200) ))
X	 (list "t"  #'(lambda (a) (send self :draw-t a ))
X	       (list "DF:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda (a) (send self :simulate-t a))
X	       (list (iseq 1 20) (iseq 1 20) (iseq 4 20) '(50 51 52 53 54 55 56 57 58 59 60 65 70 75 80 85 90 95 100 110 120 130 140 150 160 170 180 190 200)  ))
X	 (list "Uniform" #'(lambda (a) (send self :draw-uniform a))
X	       (list "a:" "b:" "Sample Size:")
X	       (list 0 1 4) #'(lambda (a) (send self :simulate-uniform a))
X	       (list (iseq 0 20) (iseq 1 20) (iseq 4 20) '(50 51 52 53 54 55 56 57 58 59 60 65 70 75 80 85 90 95 100 110 120 130 140 150 160 170 180 190 200)  ))
X	 (list "Exponential" #'(lambda (a) (send self :draw-expon a))
X	       (list "Theta:" nil "Sample Size:")
X	       (list 1 1 4) #'(lambda (a) (send self :simulate-expon a))
X	       (list (iseq 1 20) (iseq 1 20) (iseq 4 20) '(50 51 52 53 54 55 56 57 58 59 60 65 70 75 80 85 90 95 100 110 120 130 140 150 160 170 180 190 200)   ))
X	 (list "Cauchy" #'(lambda (a) (send self :draw-cauchy a))
X	       (list "Mean:" nil "Sample Size:")
X	       (list 0 0 4) #'(lambda (a) (send self :simulate-cauchy a))
X	       (list (iseq 0 20) (iseq 1 20)  (iseq 4 20) '(50 51 52 53 54 55 56 57 58 59 60 65 70 75 80 85 90 95 100 110 120 130 140 150 160 170 180 190 200) ))
X	 (list "Binomial" #'(lambda (a) (send self :draw-binomial a))
X	       (list "n:" "p:" "Sample Size:")
X	       (list 10 0.05 4) #'(lambda (a) (send self :simulate-binomial a))
X	       (list (iseq 1 20) (* .05 (iseq 1 19)) (iseq 4 20) '(50 51 52 53 54 55 56 57 58 59 60 65 70 75 80 85 90 95 100 110 120 130 140 150 160 170 180 190 200)))
X	 (list "Poisson" #'(lambda (a) (send self :draw-poisson a))
X	       (list "Lambda:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda (a) (send self :simulate-poisson a))
X	       (list (iseq 1 20) (iseq 0 20) (iseq 4 20) '(50 51 52 53 54 55 56 57 58 59 60 65 70 75 80 85 90 95 100 110 120 130 140 150 160 170 180 190 200)  )))))
X
;;;;; delete the second parameter control
X
(defmeth sd-plot-proto :delete-parm2-ctl ()
X  (send self :ctl-loc (send (select (send self :ctl) 1) :location))
X  (send self :delete-control (select (send self :ctl) 1))
X  (setf (select (send self :ctl) 1) nil))
X
;;;;; add the second parameter control
X
(defmeth sd-plot-proto :add-parm2-ctl ()
X  (let* ((ctl (send self :ctl))
X	 (a (select ctl 0))
X	 (b (send clt-parm2-control-proto :new 
X		   (* 4 (iseq 1 20))
X		   :location (send self :ctl-loc)
X		   :title "parm2" :length (send self :slider-width)
X		   :index 0))
X	 (n1 (select ctl 2))
X	 (n2 (select ctl 3)))
X      (send self :ctl (list a b n1 n2))
X      (send self :add-control b)
X      b))
X
;;;;; method for actions after selection of distribution
X
(defmeth sd-plot-proto :generate-data (ind getparms)
X  (if getparms 
X      (let* ((distributions (transpose (send self :return-distributions)))
X	     (name (first distributions))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (parmvalu (fourth distributions))
X	     (dist1 (select distributions 4))
X	     (hist (send self :graph1))
X	     (hist1 (select hist 0))
X	     (hist2 (select hist 1))
X	     (hist3 (select hist 2))
X	     (seqs (select distributions 5))
X	     (seq (select seqs ind))
X	     (parmn (select parmname ind))
X	     (ctl (send self :ctl))
X	     (n1 (select ctl 2))
X	     (n2 (select ctl 3))
X	     (a (select ctl 0))
X	     (b (if (select ctl 1) (select ctl 1) (send self :add-parm2-ctl))))
X	(send n1 :title "Sample size 1")
X	(send n2 :title "Sample size 2")
X	(send a :title (select parmn 0))
X	(if (select parmn 1) (send b :title (select parmn 1))
X	  (send self :delete-parm2-ctl))
X	(send self :index ind)
X	(send self :parms (list (select (select seq 0) 0)
X				(select (select seq 1) 0) 
X				(select (select seq 2) 0)
X				(select (select seq 3) 0)))
X	(send n1 :sequence (select seq 2))
X	(send n2 :sequence (select seq 3))
X	(send a :sequence (select seq 0))
X	(if (select parmn 1) (send b :sequence (select seq 1)))
X	(send n1 :index 0)
X	(send n2 :index 0)
X	(send a :index 0)
X	(if (select parmn 1) (send b :index 0)) 
X	(if (< 0 (send hist1 :num-points))
X	    (mapcar #'(lambda (a) (send a :clear)) hist))
X	(send self :xlabel (select name ind))
X	(send self :index ind)
X	(send self :dist (select dist1 ind))
X	(funcall (select function ind) nil)
X	(send hist1 :num (select (select seq 2) 0))
X	(send hist2 :num (select (select seq 3) 0))
X	(send hist3 :num 
X	      (round (sqrt (* (select (select seq 2) 0)
X			      (select (select seq 3) 0)))))
X	(mapcar #'(lambda (a) (send a :redraw)) hist))))
X
;;;;; methods for draw distribution density
X
(defmeth sd-plot-proto :draw-normal (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((mu (first parms))
X		      (sigma (second parms))
X		      (xmin (+ mu (* sigma (normal-quant .01))))
X		      (xmax (+ mu (* sigma (normal-quant .99))))
X		      (x (rseq xmin xmax 50)) 
X		      (y (mapcar #'normal-dens (/ (- x mu) sigma))))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth sd-plot-proto :add-lines2 (x y)
X  (mapcar #'(lambda (a b) (send self :add-lines 
X				(list (list a a) (list 0 b)))) x y))
X
(defmeth sd-plot-proto :draw-fun (xmin xmax x y) 
X  (let ((parms (send self :parms)))
X    (when parms 
X	  (let* ((mu (first parms))
X		 (sigma (sqrt (second parms)))
X		 (maxy (max y))
X		 (nice-range (get-nice-range xmin xmax 7))
X		 (n1 (first nice-range))
X		 (n2 (second nice-range))
X		 (n3 (third nice-range)))
X	    (send self :clear nil)
X	    (send self :range 1 0 (* 2.0 maxy))
X	    (send self :range 0 n1 n2)
X	    (send self :x-axis t t 5)
X	    (if (= (length x) 50) (send self :add-lines (list x y))
X	      (send self :add-lines2 x y))
X	    (if (< 0 (send (select (send self :graph1) 0) :num-points))
X		(mapcar #'(lambda (a) (send a :clear)) 
X			(send self :graph1)))))))
X
(defmeth sd-plot-proto :draw-chisquare (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms))
X		       (xmax (chisq-quant .99 df))
X		       (xmin 0)
X		       (x (rseq xmin xmax 50)) 
X		      
X		       (y (mapcar #'(lambda (i) (chisq-dens i df)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth sd-plot-proto :draw-t (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms))
X		       (xmax (t-quant .99 df))
X		       (xmin (t-quant .01 df))
X		       (x (rseq xmin xmax 50)) 
X		    
X		       (y (mapcar #'(lambda (i) (t-dens i df)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defun unif-dens (a b x)
X  (let* ((dis (- b a))
X	 (dens (/ 1 dis))
X	 (ans (if (and (< a x) (> b x)) dens 0)))
X    ans))
X
(defmeth sd-plot-proto :draw-uniform (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((a (first parms))
X		       (b (second parms))
X		       (n (third parms))
X		       (xmax (+ b .5))
X		       (xmin (- a .5))
X		       (x (rseq xmin xmax 50)) 
X	 
X		       (y (mapcar #'(lambda (i) (unif-dens a b i)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth sd-plot-proto :draw-expon (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((theta (first parms))
X		       (n (third parms))
X		       (xmax (* theta (gamma-quant .99 1)))
X		       (xmin (* theta (gamma-quant .01 1)))
X		       (x (rseq xmin xmax 50)) 
X		   
X		       (y (mapcar #' (lambda (i) 
X				       (* theta (gamma-dens i 1)))
X				     (/ x theta))))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth sd-plot-proto :draw-cauchy (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((mu (first parms))
X		       (n (third parms))
X		       (xmax (+ mu (cauchy-quant .99)))
X		       (xmin (+ mu (cauchy-quant .01)))
X		       (x (rseq xmin xmax 50)) 
X		       
X		       (y (mapcar #' (lambda (i) 
X				       (cauchy-dens i)) (- x mu))))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth sd-plot-proto :draw-binomial (&optional set)
X (let ((parms (send self :parms)))
X    (when parms (let* ((m (first parms))
X		       (p (second parms))
X		       (n (third parms))
X		       (xmax m)
X		       (xmin 0)
X		       (x (iseq 0 m)) 
X		     
X		       (y (mapcar #' (lambda (i) 
X				       (binomial-pmf i m p)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth sd-plot-proto :draw-poisson (&optional set)
X (let ((parms (send self :parms)))
X    (when parms (let* ((lamda (first parms))
X		       (n (third parms))
X		       (xmax (round (poisson-quant .9999 lamda)))
X		       (xmin 0)
X		       (x (iseq xmin xmax)) 
X		       
X		       (y (mapcar #' (lambda (i) 
X				       (poisson-pmf i lamda)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
;;;;; methods for generating simulation data
X
(defmeth sd-plot-proto :simulate-normal (aa)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((mu (first parms))
X		       (sigma (second parms))
X		       (n1 (third parms))
X		       (n2 (fourth parms))
X		       (n3 (round (sqrt (* n1 n2))))
X		       (stat (send self :stat)))
X		  (defun sim1 (i) 
X		    (let ((da2 (+ mu (* sigma (normal-rand n2)))))
X			    (send self :erase-rect 300 50 70 20)
X			    (send self :draw-text (concatenate 'string (num-to-string (round (/ i 3))) "%") 300 60 0 0)
X		      (mapcar #'(lambda (a) (funcall stat a)) 
X			      (list (choose da2 n1) da2 (choose da2 n3)))))
X		  (send self :draw-text "Computing" 200 60 0 0)
X		  (transpose (mapcar #'sim1 (iseq 1 300)))))))
X
X
(defmeth sd-plot-proto :simulate-chisquare (aa)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n1 (third parms))
X		       (n2 (fourth parms))
X		       (n3 (round (sqrt (* n1 n2))))
X		       (stat (send self :stat)))                   
X		  (defun sim1 (i) 
X		    (let ((da2 (chisq-rand n2 df)))
X
X		      (send self :erase-rect 300 50 60 20)
X		      (send self :draw-text (concatenate 'string (num-to-string (round (/ i 3))) "%") 300 60 0 0)
X
X		      (mapcar #'(lambda (a) (funcall stat a)) 
X			      (list (choose da2 n1) da2 (choose da2 n3)))))
X		  (send self :draw-text "Computing" 200 60 0 0)
X		  (transpose (mapcar #'sim1 (iseq 1 300)))))))
X
X
X     
(defmeth sd-plot-proto :simulate-t (aa)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		      (n1 (third parms))
X		      (n2 (fourth parms))
X		      (n3 (round (sqrt (* n1 n2))))
X
X		      (stat (send self :stat)))
X		  (defun sim1 (i) 
X		    (let ((da2 (t-rand n2 df)))
X
X		      (send self :erase-rect 300 50 60 20)
X		      (send self :draw-text (concatenate 'string (num-to-string (round (/ i 3))) "%") 300 60 0 0)
X
X		      (mapcar #'(lambda (a) (funcall stat a)) 
X			      (list (choose da2 n1) da2 (choose da2 n3)))))
X		  (send self :draw-text "Computing" 200 60 0 0)
X		  (transpose (mapcar #'sim1 (iseq 1 300)))))))
X
X
(defmeth sd-plot-proto :simulate-uniform (aa)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((a (first parms))
X		      (b (second parms))
X		      (n1 (third parms))
X		      (n2 (fourth parms))
X		      (n3 (round (sqrt (* n1 n2))))
X
X		      (stat (send self :stat)))
X		  (defun sim1 (i) 
X		    (let ((da2 (+ a (* (- b a) (uniform-rand n2)))))
X		      (send self :erase-rect 300 50 60 20)
X		      (send self :draw-text (concatenate 'string (num-to-string (round (/ i 3))) "%") 300 60 0 0)
X
X		      (mapcar #'(lambda (a) (funcall stat a)) 
X			      (list (choose da2 n1) da2 (choose da2 n3)))))
X		  (send self :draw-text "Computing" 200 60 0 0)
X		  (transpose (mapcar #'sim1 (iseq 1 300)))))))
X
X
(defmeth sd-plot-proto :simulate-expon (aa)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((theta (first parms))
X		      (n1 (third parms))
X		      (n2 (fourth parms))
X		      (n3 (round (sqrt (* n1 n2))))
X		      (stat (send self :stat)))
X		  (defun sim1 (i) 
X		    (let ((da2 (* theta (gamma-rand n2 1))))
X
X		      (send self :erase-rect 300 50 60 20)
X		      (send self :draw-text (concatenate 'string (num-to-string (round (/ i 3))) "%") 300 60 0 0)
X
X		      (mapcar #'(lambda (a) (funcall stat a)) 
X			      (list (choose da2 n1) da2 (choose da2 n3)))))
X		  (send self :draw-text "Computing" 200 60 0 0)
X		  (transpose (mapcar #'sim1 (iseq 1 300)))))))
X
X
(defmeth sd-plot-proto :simulate-cauchy (aa)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((mu (first parms))
X		      (n1 (third parms))
X		      (n2 (fourth parms))
X		      (n3 (round (sqrt (* n1 n2))))
X
X		      (stat (send self :stat)))
X		  (defun sim1 (i) 
X		    (let ((da2 (+ mu (cauchy-rand n2))))
X		      (send self :erase-rect 300 50 60 20)
X		      (send self :draw-text (concatenate 'string (num-to-string (round (/ i 3))) "%") 300 60 0 0)
X		      (mapcar #'(lambda (a) (funcall stat a)) 
X			      (list (choose da2 n1) da2 (choose da2 n3)))))
X		  (send self :draw-text "Computing" 200 60 0 0)
X		  (transpose (mapcar #'sim1 (iseq 1 300)))))))
X
X
(defmeth sd-plot-proto :simulate-binomial (aa)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((n (first parms))
X		      (p (second parms))
X		      (n1 (third parms))
X		      (n2 (fourth parms))
X		      (n3 (round (sqrt (* n1 n2))))
X		      (stat (send self :stat)))
X		  (defun sim1 (i) 
X		    (let ((da2 (binomial-rand n2 n p)))
X		      (send self :erase-rect 300 50 60 20)
X		      (send self :draw-text 
X			    (concatenate 'string (num-to-string (round (/ i 3))) "%") 300 60 0 0)
X		      (mapcar #'(lambda (a) (funcall stat a)) 
X			      (list (choose da2 n1) da2 (choose da2 n3)))))
X		  (send self :draw-text "Computing" 200 60 0 0)
X		  (transpose (mapcar #'sim1 (iseq 1 300)))))))
X
X
X
(defmeth sd-plot-proto :simulate-poisson (aa)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((lamda (first parms))
X		      (n1 (third parms))
X		      (n2 (fourth parms))
X		      (n3 (round (sqrt (* n1 n2))))
X		      (stat (send self :stat)))
X		  (defun sim1 (i) 
X		    (let ((da2 (poisson-rand n2 lamda)))
X		      (send self :erase-rect 280 50 60 20)
X		      (send self :draw-text (concatenate 'string (num-to-string (round (/ i 3))) "%") 300 60 0 0)
X		      (mapcar #'(lambda (a) (funcall stat a)) 
X			      (list (choose da2 n1) da2 (choose da2 n3)))))
X		  (send self :draw-text "Computing" 200 60 0 0)
X		  (transpose (mapcar #'sim1 (iseq 1 300)))))))
X
;;;;; plot controls
X
(defmeth graph-proto :plot-controls () 
X  (let* ((margin (send self :margin))
X	 (left (send self :plot-control-left-margin))
X	 (top 12)
X	 (n (+ margin (list left top 0 0))))
X    (apply #'send self :margin n)
X    (send self :add-slot 'overlay-loc '(10 10))
X    (apply #'send self :size (+ (send self :size) (list left top)))
X    #+X11 (send self :size 490 320); fits 1/4 of a 14" Sony color monitor
X    (send self :resize)))
X
(defmeth sd-plot-proto :plot-controls ()
X  (call-method graph-proto :plot-controls)
X  (send self :add-control (send  simulate-menu-proto :new 
X				 (send self :locate-next-control)))
X  (send self :add-control (send  stat-menu-proto :new 
X				 (send self :locate-next-control)))
X  (let ((a (send clt-parm1-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (send self :locate-next-control :height 2)
X		 :title "parm1" :length (send self :slider-width)
X		 :index 0))    
X	(b (send clt-parm2-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (send self :locate-next-control :height 2)
X		 :title "parm2" :length (send self :slider-width)
X		 :index 0))
X	(n1 (send clt-n1-control-proto :new 
X		  (* 4 (iseq 1 20))
X		  :location (send self :locate-next-control :height 2)
X		  :title "Sample Size 1" :length (send self :slider-width)
X		  :index 0))
X	(n2 (send clt-n2-control-proto :new 
X		  '(50 51 52 53 54 55 56 57 58 59 60 65 70 75 80 85 90 95 
X		      100 110 120 130 140 150 160 170 180 190 200)
X		  :location (send self :locate-next-control :height 2)
X		  :title "Sample Size 2" :length (send self :slider-width)
X		  :index 0)))   
X    (send self :ctl (list a b n1 n2))
X    (send self :add-control a)
X    (send self :add-control b)
X    (send self :add-control n1)
X    (send self :add-control n2)
X    (send self :start-sim-control)
X    ))
X
(defun sd ()
"generates 4 plots for sampling distribution simulation"
X  (let* ((plotobj (send sd-plot-proto :new 5 :show nil))
X	 (hist (send plotobj :graph1 
X		     (list (send hist1-proto :new 1 :show nil)
X			   (send hist1-proto :new 1 :show nil)
X			   (send hist1-proto :new 1 :show nil))))
X	 (hist1 (first hist))
X	 (hist2 (second hist))
X	 (hist3 (third hist)))
X    (send plotobj :size 490 320)
X    (send plotobj :margin 0 40 0 0)
X    (send plotobj :menu nil)
X    (send hist1 :menu nil)
X    (send hist2 :menu nil)
X    (send hist3 :menu nil)
X    (send plotobj :tile 4)
X    (send hist1 :title "Histogram 1 of Sample Mean")
X    (send hist2 :title "Histogram 2 of Sample Mean")                   
X    (send hist3 :title "Histogram 3 of Sample Mean")               
X    (send hist1 :tile 1)
X    (send hist2 :tile 2)
X    (send hist3 :tile 3)
X    (send hist1 :num 0)
X    (send hist3 :num 0)
X    (send hist2 :num 0)
X    (send plotobj :location 7 48)
X    (send plotobj :title "Sampling Distribution Simulation")
X    (mapcar #'(lambda (a) (send a :graph plotobj)) hist)
X    (mapcar #'(lambda (a) (send a :size 490 320)) hist)
X    (mapcar #'(lambda (a) (send a :margin 0 30 0 0)) hist)
X    (mapcar #'(lambda (a) (send a :plot-controls)) hist)
X    (mapcar #'(lambda (a) (send a :show-window)) hist)
X    (send plotobj :graph1 hist)
X    (send plotobj :stat #'mean)
X    (send plotobj :statn "Mean")
X    (send plotobj :plot-controls)
X    (send plotobj :show-window)
X    #+(or macintosh msdos)    (send plotobj :location 10 28)
X    #+(or macintosh msdos)    (send plotobj :size 400 200)
X    #+(or macintosh msdos)    (mapcar #'(lambda (a) (send a :size 340 200)) hist)
X    #+(or macintosh msdos)    (send hist1 :location 321 10)
X    #+(or macintosh msdos)    (send hist2 :location 10 250)
X    #+(or macintosh msdos)    (send hist3 :location 321 250)
X    plotobj))
X
#+msdos (defmeth graph-proto :overlay-click (x y m1 m2)
X		(if (not (dolist (ov (slot-value 'overlays))
X				(if (send ov :do-click x y m1 m2) 
X					(return t)))) (send self :redraw))
X					t)
X
(defmeth histogram-proto :plot-controls () (call-next-method))
(defmeth hist1-proto :plot-controls ()
X  (call-next-method) 
X  (send self :add-control 
X	(send self :ctl 
X	      (send hist-control-proto :new (iseq 2 20)
X		    :location (send self :locate-next-control :height 2)
X		    :title "NumBins" :length (send self :slider-width)
X		    :index)))
X  (send self :install-kernel-density))
X
(defmeth sd-plot-proto :n1-chg (ind)
X  (if (not (= (send (select (send self :graph1) 0) :num) 0))
X      (let* ((nctl (select (send self :ctl) 2))
X	     (distributions (transpose (send self :return-distributions)))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (index (send self :index))
X	     (parms (send self :parms)))
X	(setf (select parms 2) (select (send nctl :sequence) ind))
X	(send self :parms parms)
X	(let* ((n1 (third parms))
X	       (n2 (fourth parms))
X	       (n3 (round (sqrt (* n1 n2))))
X	       (nn (list n1 n2 n3))
X	       (hist (send self :graph1)))
X	  (mapcar #'(lambda (a b) (send a :num b)) hist nn)
X	  (if (< 0 (send (first hist) :num-points))
X	      (mapcar #'(lambda (a) (send a :clear nil)) hist))
X	  (mapcar #'(lambda (a) (send a :redraw)) hist) 
X	  )))
X  (if (not (send self :dist)) (send self :draw-text 
X			"First, Select Distribution!" 170 80 0 0))
X  ) 
X
(defmeth sd-plot-proto :n2-chg (ind)
X  (if (not (= (send (select (send self :graph1) 0) :num) 0))
X      (let* ((nctl (select (send self :ctl) 3))
X	     (distributions (transpose (send self :return-distributions)))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (index (send self :index))
X	     (parms (send self :parms)))
X	(setf (select parms 3) (select (send nctl :sequence) ind))
X	(send self :parms parms)
X	(let* ((n1 (third parms))
X	       (n2 (fourth parms))
X	       (n3 (round (sqrt (* n1 n2))))
X	       (nn (list n1 n2 n3))
X	       (hist (send self :graph1)))
X	  (mapcar #'(lambda (a b) (send a :num b)) hist nn)
X	  (if (< 0 (send (first hist) :num-points))
X	      (mapcar #'(lambda (a) (send a :clear nil)) hist))
X	  (mapcar #'(lambda (a) (send a :redraw)) hist)
X	  )))
X  (if (not (send self :dist)) (send self :draw-text 
X				    "First, Select Distribution!" 170 80 0 0)))
X
X
(defmeth sd-plot-proto :parm1-chg (ind)
(if (not (= (send (select (send self :graph1) 0) :num) 0))
X  (let* ((p1ctl (select (send self :ctl) 0))
X	 (distributions (transpose (send self :return-distributions)))
X	 (function (second distributions))
X	 (parmname (third distributions))
X	 (index (send self :index))
X	 (parms (send self :parms)))
X    (setf (select parms 0) (select (send p1ctl :sequence) ind))
X    (send self :parms parms)
X    (funcall (select function index) t)))
(if (not (send self :dist)) (send self :draw-text 
X			"First, Select Distribution!" 170 80 0 0)))
X
(defmeth sd-plot-proto :parm2-chg (ind)
X  (if (not (= (send (select (send self :graph1) 0) :num) 0))
X   (let* ((p2ctl (select (send self :ctl) 1))
X	 (distributions (transpose (send self :return-distributions)))
X	 (function (second distributions))
X	 (parmname (third distributions))
X	 (index (send self :index))
X	 (parms (send self :parms)))
X    (setf (select parms 1) (select (send p2ctl :sequence) ind))
X    (send self :parms parms)
X    (funcall (select function index) t)))
X  (if (not (send self :dist)) (send self :draw-text 
X			"First, Select Distribution!" 170 80 0 0)))
X
X
(defproto clt-n1-control-proto '() () slider-control-proto)
(defmeth clt-n1-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :n1-chg new))))  
X  (slot-value 'index))
X
(defproto clt-n2-control-proto '() () slider-control-proto)
(defmeth clt-n2-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :n2-chg new))))  
X  (slot-value 'index))
X
(defproto clt-parm1-control-proto '() () slider-control-proto)
(defmeth clt-parm1-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :parm1-chg new))))  
X  (slot-value 'index))
X
(defproto clt-parm2-control-proto '() () slider-control-proto)
(defmeth clt-parm2-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :parm2-chg new))))  
X  (slot-value 'index))
X
X
SHAR_EOF
chmod 0745 Teach/SD/sd3.lsp ||
echo 'restore of Teach/SD/sd3.lsp failed'
Wc_c="`wc -c < 'Teach/SD/sd3.lsp'`"
test 32707 -eq "$Wc_c" ||
	echo 'Teach/SD/sd3.lsp: original size 32707, current size' "$Wc_c"
fi
# ============= Teach/TR/tr4.lsp ==============
if test ! -d 'Teach/TR'; then
    echo 'x - creating directory Teach/TR'
    mkdir 'Teach/TR'
fi
if test -f 'Teach/TR/tr4.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/TR/tr4.lsp (File already exists)'
else
echo 'x - extracting Teach/TR/tr4.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/TR/tr4.lsp' &&
#+msdos (defmeth popup-menu-control-proto :do-click (x y a b)
X	  (let* ((graph (send self :graph))
X		 (loc (send self :location))
X		 (loc-x (first loc))
X		 (loc-y (+ 5 (second loc))))
X	    (when (and (< loc-x x (+ loc-x 10)) (< loc-y y (+ loc-y 10)))
X		  (send graph :paint-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X		  (send self :do-action (list a b))
X		  (send graph :erase-rect (+ 1 loc-x) (+ 1 loc-y) 8 8)
X		  t)))
;;
;; TR module written by Tae-Sung Shin
;;
X
(defproto tr-plot-proto 
X  '(xdata ydata xlabel ylabel index graph1 parms parmn ctl lactl ctl-loc ctl-loc1) 
X  () 
X  scatterplot-proto)
X
;;
;;;;;;;;;;;;;;;;;;;; set-up some slots and accessor methods
;;
X
(defmeth tr-plot-proto :ctl-loc (&optional (ctl-loc nil set))
X  (if set (setf (slot-value 'ctl-loc) ctl-loc))
X  (slot-value 'ctl-loc))
X
(defmeth tr-plot-proto :ctl-loc1 (&optional (ctl-loc1 nil set))
X  (if set (setf (slot-value 'ctl-loc1) ctl-loc1))
X  (slot-value 'ctl-loc1))
X
(defmeth tr-plot-proto :xdata (&optional (xdata nil set))
X  (if set (setf (slot-value 'xdata) (sort-data xdata)))
X  (slot-value 'xdata))
X
(defmeth tr-plot-proto :ydata (&optional (ydata nil set))
X  (if set (setf (slot-value 'ydata) ydata))
X  (slot-value 'ydata))
X
(defmeth tr-plot-proto :parms (&optional (parms nil set))
X  (if set (setf (slot-value 'parms) parms))
X  (slot-value 'parms))
X
(defmeth tr-plot-proto :parmn (&optional (parmn nil set))
X  (if set (setf (slot-value 'parmn) parmn))
X  (slot-value 'parmn))
X
(defmeth tr-plot-proto :index (&optional (index nil set))
X  (if set (setf (slot-value 'index) index))
X  (slot-value 'index))
X
(defmeth tr-plot-proto :xlabel (&optional (xlabel nil set))
X  (if set (setf (slot-value 'xlabel) xlabel))
X  (slot-value 'xlabel))
X
(defmeth tr-plot-proto :graph1 (&optional (graph1 nil set))
X  (if set (setf (slot-value 'graph1) graph1))
X  (slot-value 'graph1))
X
(defmeth tr-plot-proto :ylabel (&optional (ylabel nil set))
X  (if set (setf (slot-value 'ylabel) ylabel))
X  (slot-value 'ylabel))
X  
(defmeth tr-plot-proto :ctl (&optional (ctl nil set))
X  (if set (setf (slot-value 'ctl) ctl))
X  (slot-value 'ctl))
X
(defmeth tr-plot-proto :lactl (&optional (lactl nil set))
X  (if set (setf (slot-value 'lactl) lactl))
X  (slot-value 'lactl))
X
(defmeth tr-plot-proto :close ()
X  (when (send self :graph1)
X	(mapcar #'(lambda (a) (send a :graph nil)) (send self :graph1))
X	(mapcar #'(lambda (a) (send a :close)) (send self :graph1)))
X  (call-next-method)
X  (exit))
X
;;;;; distribution selection control set up
X
(defproto simulate-menu-proto '(menu) () popup-menu-control-proto)
X
(defmeth simulate-menu-proto :isnew (loc)
X  (call-next-method loc :title "Distributions"))
X
(defmeth simulate-menu-proto :menu ()
X  (let ((graph (send self :graph)))
X    (when (null (slot-value 'menu))
X	  (let* ((menu (send menu-proto :new "Menu"))
X		 (normal (send menu-item-proto :new "Normal" 
X		  :action  #'(lambda () (send graph :generate-data 0 t))))
X		 (chisq (send menu-item-proto :new "Chi-square" 
X		  :action #'(lambda () (send graph :generate-data 1 t))))
X		 (t (send menu-item-proto :new "T" 
X		  :action #'(lambda () (send graph :generate-data 2 t))))
X		 (unif (send menu-item-proto :new "Uniform" 
X		  :action #'(lambda () (send graph :generate-data 3 t))))
X		 (expon (send menu-item-proto :new "Exponential" 
X		  :action #'(lambda () (send graph :generate-data 4 t))))
X		 (cauchy (send menu-item-proto :new "Cauchy" 
X		  :action #'(lambda () (send graph :generate-data 5 t))))
X		 (binom (send menu-item-proto :new "Binomial" 
X		  :action #'(lambda () (send graph :generate-data 6 t))))
X		 (pois (send menu-item-proto :new "Poisson" 
X		  :action #'(lambda () (send graph :generate-data 7 t)))))
X	    
X	    (send menu :append-items 
X		  normal chisq t unif expon cauchy binom pois)
X	    (setf (slot-value 'menu) menu)))
X   (slot-value 'menu)))
X
;;;;;; data selection control set up
X
(defproto data-menu-proto '(menu) () popup-menu-control-proto)
X
(defmeth data-menu-proto :isnew (loc)
X  (call-next-method loc :title "Select Data"))
X
(defmeth data-menu-proto :menu ()
X  (let ((graph (send self :graph))
X	(datalist (variables)))
X    (defmeth graph :data-redraw (item1)
X      (send self :clear nil)
X      (let* ((data (eval item1))
X	     (x (first data))
X	     (n (length x))
X	     (xttl (second data)))
X	(format t "~%")
X	(format t "X variable ~20a ~%" xttl) 
X	(prin1 x)(terpri)
X	(send self :parms nil)
X	(send self :delete-ctl)
X	(send self :x-axis nil)
X	(send self :xdata x)
X	(send self :xlabel xttl)
;       (send self :title xttl)
X	(send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))    
X	(send self :set-trans)
X	(send self :draw-plots)
X	))
X    (flet ((mk-item (item)
X		    (send menu-item-proto :new (string item) 
X			  :action  
X			  #'(lambda () (send graph :data-redraw item)))))
X	  (when (null (slot-value 'menu))
X		(let* ((menu (send menu-proto :new "Menu"))
X		       (items (mapcar #'mk-item datalist)))
X		  (flet ((append-item (item)
X				      (send menu :append-items item)))
X			(mapcar #'append-item items))
X		  (setf (slot-value 'menu) menu)))
X	  (slot-value 'menu))))
X
;;;;; draw normal probability plot, boxplot, and histogram  with values of xdata
X
(defmeth tr-plot-proto :draw-plots ()
X  (send self :draw-data (send self :xdata)))
X
;;;;; actions for choosing new sample selection
X
(defmeth tr-plot-proto :new-sample ()
X  (let* ((distributions (transpose (send self :return-distributions)))
X	 (sim-funs (select distributions 4))
X	 (function (select sim-funs (send self :index)))
X	 (plot (send self :graph1))
X	 (plot1 (first plot))
X	 (plot2 (second plot))
X	 (plot3 (third plot))
X	 (y  (send self :xdata (funcall function))))
X    (send plot1 :draw-next-frame '(1) (list y))
X    (send plot2 :clear-lines)
X    (send plot2 :clear-points)
X    (send plot2 :add-boxplot y :x 1 :draw nil)
X    (send plot3  :draw-next-frame '(0) (list y))
X    (send self :set-trans)))
X
(defun round100 (x)
X  (/ (round (* 100 x)) 100))
X
;;;;; set the sequence of transformation parameter
X
(defmeth tr-plot-proto :set-trans ()    
X  (let* ((la1 (first (send self :lactl)))
X	 (la2 (second (send self :lactl)))
X	 (x (send self :xdata))
X	 (ra (* 2 (interquartile-range x)))
X	 (minx (- 0.01 (min x)))
X	 (parms (send self :parms))
X	 (y (standardize (mapcar #'(lambda (a) (tr-data a -1 minx)) x))))
X    (send la2 :sequence (mapcar #'round100 (rseq minx (+ ra minx) 20)))
X    (send la2 :slot-value 'index 0)
X    (send la2 :draw-indicator)
X    (send la1 :slot-value 'index 0)
X    (send la1 :draw-indicator)
X    ))
X
;;;;; draw normal probability plot, boxplot, and histogram  with y
X
(defmeth tr-plot-proto :draw-data (y)
X  (let* ((y (standardize y))
X	 (plot (send self :graph1))
X	 (plot1 (first plot))
X	 (plot2 (second plot))
X	 (plot3 (third plot)))
X     (when (< 0 (send plot1 :num-points)) 
X	  (send plot1 :clear-points nil)
X	  (send plot2 :clear nil)
X	  (send plot3 :clear nil))
X    (send plot1 :add-points (send self :ydata) y)
X    (send plot2 :add-boxplot y :x 1)
X    (send plot3 :add-points y)
X    ))       
X
;;;;; draw original sample on the plots
X
(defmeth tr-plot-proto :org-sample ()
X  (if (send self :xdata) 
X      (send self :draw-data (send self :xdata))
X    (send self :draw-text 
X	  "First, Select data or Distribution!" 170 20 0 0)))
X
;;;;; method for original sample control
X
(defmeth tr-plot-proto :org-control ()
X  (let* ((location (send self :locate-next-control))
X	 (owner self)
X	 (control (send graph-control-proto :new
X			:location location :title "Original sample")))    
X    (defmeth control :do-action (&rest args) 
X      (send owner :org-sample))
X    (send self :add-control control)))
X
;;
;;;;;;;;;;;;;;;;;;;;;; methods to select  Distribution 
;; 
X
(defmeth tr-plot-proto :return-distributions ()
X  "Accessor method for slot :distribution-list."
X  (cond ((null (send self :has-slot 'distribution-list))
X	 (send self :make-distribution-list))
X	((null (slot-value 'distribution-list))
X	 (send self :make-distribution-list))
X	(t (slot-value 'distribution-list))))
X
(defmeth tr-plot-proto :make-distribution-list ()
X  "Creates slot containing the list of lists of distribution
X   names and corresponding activating functions."
X  (send self :add-slot 'distribution-list
X	(list
X	 (list "Normal" #'(lambda () (send self :draw-normal )) 
X	       (list "Mean:" "S.D.:" "Sample Size:")
X	       (list 0 1 4) #'(lambda () (send self :simulate-normal ))
X	       (list (iseq 0 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70) )) 
X	 (list "Chi-square"  #'(lambda () (send self :draw-chisquare ))
X	       (list "DF:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda () (send self :simulate-chisquare ))
X	       (list (iseq 1 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70) ))
X	 (list "t"  #'(lambda () (send self :draw-t  ))
X	       (list "DF:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda () (send self :simulate-t ))
X	       (list (iseq 1 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70)  ))
X	 (list "Uniform" #'(lambda () (send self :draw-uniform ))
X	       (list "a:" "b:" "Sample Size:")
X	       (list 0 1 4) #'(lambda () (send self :simulate-uniform ))
X	       (list (iseq 0 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70)  ))
X	 (list "Exponential" #'(lambda () (send self :draw-expon ))
X	       (list "Theta:" nil "Sample Size:")
X	       (list 1 1 4) #'(lambda () (send self :simulate-expon ))
X	       (list (iseq 1 20) (iseq 1 20) (* 5 (iseq 2 20)) (iseq 50 70)   ))
X	 (list "Cauchy" #'(lambda () (send self :draw-cauchy ))
X	       (list "Mean:" nil "Sample Size:")
X	       (list 0 0 4) #'(lambda () (send self :simulate-cauchy ))
X	       (list (iseq 0 20) (iseq 1 20)  (* 5 (iseq 2 20)) (iseq 50 70) ))
X	 (list "Binomial" #'(lambda () (send self :draw-binomial ))
X	       (list "n:" "p:" "Sample Size:")
X	       (list 10 0.05 4) #'(lambda () (send self :simulate-binomial ))
X	       (list (iseq 4 30) (* .05 (iseq 2 19)) (* 5 (iseq 2 20)) (iseq 50 70)))
X	 (list "Poisson" #'(lambda () (send self :draw-poisson ))
X	       (list "Lambda:" nil "Sample Size:")
X	       (list 1 0 4) #'(lambda () (send self :simulate-poisson ))
X	       (list (iseq 1 20) (iseq 0 20) (* 5 (iseq 2 20)) (iseq 50 70)  )))))
X
;;;;; delete the controls related to simulation
X
(defmeth tr-plot-proto :delete-ctl ()
(let ((ctl (send self :ctl)))
X    (send self :ctl-loc 
X        (list (send (first ctl) :location)
X	      (if (second ctl) (send (second ctl) :location) 
X		(send self :ctl-loc1))
X	      (send (third ctl) :location))))
X  (mapcar #'(lambda (a) (send self :delete-control a)) (send self :ctl))
X  (send self :ctl nil))
X
;;;; add the controls related to simulation
X
(defmeth tr-plot-proto :add-ctl ()
X (let* ((loc (send self :ctl-loc))
X       (a (send tr-parm1-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (first loc)
X		 :title "parm1" :length (send self :slider-width)
X		 :index 0))    
X	(b (send tr-parm2-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (second loc)
X		 :title "parm2" :length (send self :slider-width)
X		 :index 0))
X	(n (send tr-n-control-proto :new 
X		  (* 4 (iseq 1 20))
X		  :location (third loc)
X		  :title "Sample Size 1" :length (send self :slider-width)
X		  :index 0)))
X   (send self :add-control a)
X   (send self :add-control b)
X   (send self :add-control n)
X   (send self :ctl (list a b n))))
X
;;;;; delete the second parameter control
X  
(defmeth tr-plot-proto :delete-parm2-ctl ()
X  (send self :ctl-loc1 (send (select (send self :ctl) 1) :location))
X  (send self :delete-control (select (send self :ctl) 1))
X  (setf (select (send self :ctl) 1) nil))
X
;;;;; add the second parameter control
X
(defmeth tr-plot-proto :add-parm2-ctl ()
X  (let* ((ctl (send self :ctl))
X	 (a (select ctl 0))
X	 (b (send tr-parm2-control-proto :new 
X		   (* 4 (iseq 1 20))
X		   :location (send self :ctl-loc1)
X		   :title "parm2" :length (send self :slider-width)
X		   :index 0))
X	 (n1 (select ctl 2)))
X      (send self :ctl (list a b n1))
X      (send self :add-control b)
X      b))
X
(defmeth tr-plot-proto :redraw ()
X  (call-next-method)
X  (send self :describe-dist))
X
;;;;; display information of the distribution selected
X
(defmeth tr-plot-proto :describe-dist ()
X  (let ((parms (send self :parms)))
X    (when parms
X	  (let* ((dist (send self :xlabel))
X		 (parmn (send self :parmn))
X		 (a (first parmn))
X		 (b (second parmn))
X		 (n (third parmn))
X		 (real-co (send self :real-to-canvas 
X				(first (send self :range 0)) 20))
X		 (x-co (first real-co))
X		 (y-co 30))
X	    (send self :draw-text 
X		  (concatenate 'string 
X			       "Distribution : " dist) x-co y-co 0 0)
X	    (send self :draw-text 
X		  (concatenate 'string 
X				a " " (num-to-string (first parms)))
X		  x-co (+ y-co 20) 0 0)
X	    (if b (send self :draw-text 
X			(concatenate 'string 
X				     b " " (num-to-string (second parms)))
X			x-co (+ 40 y-co) 0 0))
X	    (send self :erase-rect x-co (+ 40 y-co) 200 30)
X	    (send self :draw-text 
X		  (concatenate 'string 
X				n " " (num-to-string (third parms)))
X		  x-co (+ 60 y-co) 0 0)))))
X
;;;;; method for actions after selection of distribution
X
(defmeth tr-plot-proto :generate-data (ind getparms)
X  (if getparms
X      (let* ((distributions (transpose (send self :return-distributions)))
X	     (name (first distributions))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (parmvalu (fourth distributions))
X	     (function2 (select distributions 4))
X	     (dist1 (select distributions 4))
X	     (plot (send self :graph1))
X	     (plot1 (select plot 0))
X	     (plot2 (select plot 1))
X	     (plot3 (select plot 2))
X	     (seqs (select distributions 5))
X	     (seq (select seqs ind))
X	     (parmn (select parmname ind))
X	     (ctl (if (send self :ctl) (send self :ctl) (send self :add-ctl)))
X	     (n1 (select ctl 2))
X	     (a (select ctl 0))
X	     (b (if (select ctl 1) (select ctl 1) (send self :add-parm2-ctl))))
X	(if (< 0 (send plot1 :num-points))
X	    (mapcar #'(lambda (a) (send a :clear)) plot))
X	(send self :xlabel (select name ind))
X	(send self :parmn parmn)
X	(send n1 :title "Sample size")
X	(send a :title (select parmn 0))
X	(if (select parmn 1) (send b :title (select parmn 1))
X	  (send self :delete-parm2-ctl))
X	(send self :index ind)
X	(send self :parms (list (select (select seq 0) 0)
X				(select (select seq 1) 0) 
X				(select (select seq 2) 0)))
X	(send n1 :sequence (select seq 2))
X	(send a :sequence (select seq 0))
X	(if (select parmn 1) (send b :sequence (select seq 1)))
X	(send n1 :index 0)
X	(send a :index 0)
X	(if (select parmn 1) (send b :index 0))
X	(send self :index ind)
X	(funcall (select function ind))
X	(funcall (select function2 ind))
X	(send self :set-trans)
X	(send self :draw-data (send self :xdata))
X	(send self :describe-dist))))
X
;;;;; methods for draw distribution density
X
(defmeth tr-plot-proto :draw-normal (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((mu (first parms))
X		      (sigma (second parms))
X		      (xmin (+ mu (* sigma (normal-quant .01))))
X		      (xmax (+ mu (* sigma (normal-quant .99))))
X		      (x (rseq xmin xmax 50)) 
X		      (y (mapcar #'normal-dens (/ (- x mu) sigma))))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth tr-plot-proto :add-lines2 (x y)
X  (mapcar #'(lambda (a b) (send self :add-lines 
X				(list (list a a) (list 0 b)))) x y))
X
(defmeth tr-plot-proto :draw-fun (xmin xmax x y) 
X  (let ((parms (send self :parms)))
X    (when parms 
X	  (let* ((mu (first parms))
X		 (sigma (sqrt (second parms)))
X		 (maxy (max y))
X		 (nice-range (get-nice-range xmin xmax 7))
X		 (y (* (/ 1 maxy) y))
X		 (n1 (first nice-range))
X		 (n2 (second nice-range))
X		 (n3 (third nice-range)))
X	    (send self :clear nil)
X	    (send self :range 0 n1 n2)
X	    (send self :x-axis t t 5)
X	    (if (> (length x) 49) (send self :add-lines (list x y))
X	      (send self :add-lines2 x y))
X	    ))))
X
(defmeth tr-plot-proto :draw-chisquare (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms))
X		       (xmax (chisq-quant .99 df))
X		       (xmin 0)
X		       (x (rseq xmin xmax 50)) 
X		      
X		       (y (mapcar #'(lambda (i) (chisq-dens i df)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth tr-plot-proto :draw-t (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms))
X		       (xmax (t-quant .99 df))
X		       (xmin (t-quant .01 df))
X		       (x (rseq xmin xmax 50)) 
X		    
X		       (y (mapcar #'(lambda (i) (t-dens i df)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defun unif-dens (a b x)
X  (let* ((dis (- b a))
X	 (dens (/ 1 dis))
X	 (ans (if (and (< a x) (> b x)) dens 0)))
X    ans))
X
(defmeth tr-plot-proto :draw-uniform (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((a (first parms))
X		       (b (second parms))
X		       (n (third parms))
X		       (xmax (+ b .5))
X		       (xmin (- a .5))
X		       (den (/ 1 (- b a)))
X		       (x (list xmin a a b b xmax))  
X		       (y (list 0 0 den den 0 0))
X		       (nice-range (get-nice-range xmin xmax 7))
X		       (y (* (/ 1 den) y))
X		       (n1 (first nice-range))
X		       (n2 (second nice-range))
X		       (n3 (third nice-range)))
X		  (send self :clear-lines)
X		  (send self :range 0 n1 n2)
X		  (send self :x-axis t t 5)
X		  (send self :add-lines (list x y))))))
X
X
X		  
X
(defmeth tr-plot-proto :draw-expon (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((theta (first parms))
X		       (n (third parms))
X		       (xmax (* theta (gamma-quant .99 1)))
X		       (xmin (* theta (gamma-quant .01 1)))
X		       (x (rseq xmin xmax 50)) 
X		   
X		       (y (mapcar #' (lambda (i) 
X				       (* theta (gamma-dens i 1))) 
X				     (/ x theta))))
X		  (send self :draw-fun xmin xmax x y)))))
X
X
(defmeth tr-plot-proto :draw-cauchy (&optional set)
X  (let ((parms (send self :parms)))
X    (when parms (let* ((mu (first parms))
X		       (n (third parms))
X		       (xmax (+ mu (cauchy-quant .99)))
X		       (xmin (+ mu (cauchy-quant .01)))
X		       (x (rseq xmin xmax 50)) 
X		       
X		       (y (mapcar #' (lambda (i) 
X				       (cauchy-dens i)) (- x mu))))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth tr-plot-proto :draw-binomial (&optional set)
X (let ((parms (send self :parms)))
X    (when parms (let* ((m (first parms))
X		       (p (second parms))
X		       (n (third parms))
X		       (xmax m)
X		       (xmin 0)
X		       (x (iseq 0 m)) 
X		     
X		       (y (mapcar #' (lambda (i) 
X				       (binomial-pmf i m p)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
(defmeth tr-plot-proto :draw-poisson (&optional set)
X (let ((parms (send self :parms)))
X    (when parms (let* ((lamda (first parms))
X		       (n (third parms))
X		       (xmax (round (poisson-quant .9999 lamda)))
X		       (xmin 0)
X		       (x (iseq xmin xmax)) 
X		       
X		       (y (mapcar #' (lambda (i) 
X				       (poisson-pmf i lamda)) x)))
X		  (send self :draw-fun xmin xmax x y)))))
X
;;;;; methods for generating simulation data
X
(defmeth tr-plot-proto :simulate-normal ()
X  (let ((parms (send self :parms)))
X    (when parms (let* (
X		       (mu (first parms))
X		       (sigma (second parms))
X		       (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (+ mu (* sigma (normal-rand n))))
X		  
))))
X
(defmeth tr-plot-proto :simulate-chisquare ()
X  (let ((parms (send self :parms)))
X    (when parms (let* ((df (first parms))
X		       (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (chisq-rand n df))
X		  ))))                  
X
(defmeth tr-plot-proto :simulate-t ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((df (first parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (t-rand n df))
X		  ))))
X
(defmeth tr-plot-proto :simulate-uniform ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((a (first parms))
X		      (b (second parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (+ a (* (- b a) (uniform-rand n))))
X		  ))))
X
(defmeth tr-plot-proto :simulate-expon ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((theta (first parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata 
X			(* theta (gamma-rand n 1)))
X		  ))))
X
(defmeth tr-plot-proto :simulate-cauchy ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((mu (first parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (+ mu (cauchy-rand n)))
X		  ))))
X
(defmeth tr-plot-proto :simulate-binomial ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((n (first parms))
X		      (p (second parms))
X		      (m (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq m) 1) (+ m 1))))
X		  (send self :xdata (binomial-rand m n p))
X		  ))))
X
(defmeth tr-plot-proto :simulate-poisson ()
X  (let ((parms (send self :parms)))
X    (when parms (let ((lamda (first parms))
X		      (n (third parms)))
X		  (send self :ydata (normal-quant (/ (+ (iseq n) 1) (+ n 1))))
X		  (send self :xdata (poisson-rand n lamda))
X		  ))))
X
;;;; install the plot controls
X
(defmeth graph-proto :plot-controls () 
X  (let* ((margin (send self :margin))
X	 (left (send self :plot-control-left-margin))
X	 (top 12)
X	 (n (+ margin (list left top 0 0))))
X    (apply #'send self :margin n)
X    (send self :add-slot 'overlay-loc '(10 10))
X    (apply #'send self :size (+ (send self :size) (list left top)))
X    #+X11 (send self :size 490 320); fits 1/4 of a 14" Sony color monitor
X    (send self :resize)))
X
(defmeth tr-plot-proto :plot-controls ()
X  (call-method graph-proto :plot-controls)
X  (send self :add-control (send  simulate-menu-proto :new 
X				 (send self :locate-next-control)))
X  (send self :add-control (send  data-menu-proto :new 
X				 (send self :locate-next-control)))
X  (let (
X	(a (send tr-parm1-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (send self :locate-next-control :height 2)
X		 :title "parm1" :length (send self :slider-width)
X		 :index 0))    
X	(b (send tr-parm2-control-proto :new 
X		 (* 4 (iseq 1 20))
X		 :location (send self :locate-next-control :height 2)
X		 :title "parm2" :length (send self :slider-width)
X		 :index 0))
X	(n (send tr-n-control-proto :new 
X		  (* 4 (iseq 1 20))
X		  :location (send self :locate-next-control :height 2)
X		  :title "Sample Size" :length (send self :slider-width)
X		  :index 0))
X	(la1 (send tr-la1-control-proto :new 
X		  (rseq -1 2 31)
X		  :location (send self :locate-next-control :height 2)
X		  :title "Power" :length (send self :slider-width)
X		  :index 0))
X	(la2 (send tr-la2-control-proto :new 
X		  (rseq 0 2 21)
X		  :location (send self :locate-next-control :height 2)
X		  :title "Shift" :length (send self :slider-width)
X		  :index 0)))
X    (send self :ctl (list a b n))
X    (send self :lactl (list la1 la2))
X    (send self :add-control a)
X    (send self :add-control b)
X    (send self :add-control n)
X    (send self :add-control la1)
X    (send self :add-control la2)
X    (send self :org-control)))
X
(defun trp ()
"generate 4 plots for transformation simulation"
X  (let* ((plot (send tr-plot-proto :new 5 :show nil))
X	 (graph1 
X	  (send plot :graph1 
X		(list (send scatterplot-proto :new 2 :show nil)
X		      (send scatterplot-proto :new 2 :show nil)
X		      (send histogram-proto :new 1 :show nil))))
X
;first is prob plot, second boxplot, third is histogram
X
X	 (plot1 (first graph1))
X	 (plot2 (second graph1))
X	 (plot3 (third graph1))
X	 (owner plot))
X    (mapcar #'(lambda (a) (send a :size 490 320)) graph1)
#+(or macintosh msdos)    (mapcar #'(lambda (a) (send a :margin 0 0 0 0)) graph1)
X    (send plot :size 490 320)
X    (send plot :margin 0 110 0 0)
X    (send plot :menu nil)
X    (send plot1 :menu nil)
X    (send plot2 :menu nil)
X    (send plot3 :menu nil)
X    (send plot :tile 4)
X    (send plot1 :tile 1)
X    (send plot2 :tile 2)
X    (send plot3 :tile 3)
X    (send plot :location 7 58)
X    (send plot :title "Simulation of Transformation to Normal")
X    (send plot1 :variable-label 0 "Standardized Normal Quantile")
X    (send plot1 :variable-label 1 "Standardized Data Quantile")
X    (send plot1 :title "Normal Probability Plot")
X    (send plot2 :title "Box Plot")
X    (send plot1 :range 1 -3 3)
X    (send plot1 :range 0 -3 3)
X    (send plot2 :range 1 -3 3)
X    (send plot2 :range 0 0 2)
X    (send plot3 :range 0 -3 3)
X    (send plot1 :x-axis t t)
X    (send plot2 :x-axis nil)
X    (send plot3 :x-axis t)
X    (send plot1 :y-axis t t)
X    (send plot2 :y-axis t)
X    (send plot3 :y-axis nil)
X    (mapcar #'(lambda (a) (send a :add-slot 'graph)) graph1)
X    (mapcar 
X     #'(lambda (a)
X	 (defmeth a :graph (&optional (graph nil set))
X	   (if set (setf (slot-value 'graph) graph))
X	   (slot-value 'graph))) 
X     graph1)
X    (send plot3 :add-slot 'ctl)
X    (defmeth plot3 :ctl (&optional (ctl nil set))
X      (if set (setf (slot-value 'ctl) ctl))
X      (slot-value 'ctl))
X    (mapcar #'(lambda (a) (send a :graph plot)) graph1)
X    (mapcar 
X     #'(lambda (a)
X	 (defmeth a :close ()
X	   (when (send self :graph)
X		 (send (send self :graph) :graph1 
X		       (set-difference 
X			(send (send self :graph) :graph1) (list self)))
X		 (send (send self :graph) :close))
X	   (call-next-method))) 
X     graph1)
X    (defmeth plot2 :show-stats ()
X      (call-method graph-proto :showing-labels t)
X      (let ((n (+ (send self :num-points) 5)))
X	(send self :point-state (iseq n) 'selected)))
X    (defmeth plot2 :show-stats-control ()
X      (call-method graph-proto :plot-controls)
X      #+(or macintosh msdos) (send self :margin 0 30 0 0)
X      (let* ((location (send self :locate-next-control))
X	     (control (send graph-control-proto :new
X			    :location location :title "Show Statistics")))
X	(defmeth control :do-action (&rest args) 
X	  (send plot2 :show-stats))
X	(send self :add-control control)))
X    (defmeth plot1 :plot-controls ()
X      (call-method graph-proto :plot-controls))
X    (send plot1 :plot-controls)
X    (send plot2 :show-stats-control)
X    (send plot3 :plot-controls)
X    (send plot :plot-controls)
X    (send plot3 :num-bins 11)
X    (send (send plot3 :ctl) :index 11)
X    (mapcar #'(lambda (a) (send a :show-window)) graph1)
X    (send plot :show-window)
X    #+(or macintosh msdos) (send plot :location 10 28)
X    #+(or macintosh msdos) (send plot :size 400 230)
X    #+(or macintosh msdos) (send plot1 :location 330 28)
X    #+(or macintosh msdos) (send plot1 :size 320 200)
X    #+(or macintosh msdos) (send plot2 :location 10 228)
X    #+(or macintosh msdos) (send plot2 :size 320 200)
X    #+(or macintosh msdos) (send plot3 :location 330 228)
X    #+(or macintosh msdos) (send plot3 :size 320 200)
X    #+(or macintosh msdos) (send plot1 :margin 0 0 0 0)
X    plot))
X
#+msdos (defmeth graph-proto :overlay-click (x y m1 m2)
X		(if (not (dolist (ov (slot-value 'overlays))
X				(if (send ov :do-click x y m1 m2) 
X					(return t)))) (send self :redraw))
X					t)
X
(defmeth histogram-proto :plot-controls () 
X  (call-next-method) 
X  (send self :add-control 
X	(send self :ctl 
X	      (send hist-control-proto :new (iseq 2 20)
X		    :location (send self :locate-next-control :height 2)
X		    :title "NumBins" :length (send self :slider-width)
X		    :index)))
X  (send self :install-kernel-density))
X
;;;;; methods for actions after selecting parameter controls
X
(defmeth tr-plot-proto :n-chg (ind)
X  (if (< 0 (send (first (send self :graph1)) :num-points))
X      (let* ((nctl (select (send self :ctl) 2))
X	     (distributions (transpose (send self :return-distributions)))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (function1 (select distributions 4))
X	     (index (send self :index))
X	     (parms (send self :parms)))
X	(setf (select parms 2) (select (send nctl :sequence) ind))
X	(send self :parms parms)
X	(funcall (select function1 index))
X	(send self :set-trans)
X	(send self :draw-data (send self :xdata))
X	(send self :describe-dist)))
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select data or Distribution!" 170 20 0 0)))
X
(defmeth tr-plot-proto :parm1-chg (ind)
X  (if (< 0 (send (first (send self :graph1)) :num-points))
X      (let* ((p1ctl (select (send self :ctl) 0))
X	     (distributions (transpose (send self :return-distributions)))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (function1 (select distributions 4))
X	     (index (send self :index))
X	     (parms (send self :parms)))
X	(setf (select parms 0) (select (send p1ctl :sequence) ind))
X	(send self :parms parms)
X	(funcall (select function index))
X	(funcall (select function1 index))
X	(send self :set-trans)
X	(send self :draw-data (send self :xdata))
X	(send self :describe-dist)))
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select data or Distribution!" 170 20 0 0)))
X
(defmeth tr-plot-proto :parm2-chg (ind)
X  (if (< 0 (send (first (send self :graph1)) :num-points))
X      (let* ((p2ctl (select (send self :ctl) 1))
X	     (distributions (transpose (send self :return-distributions)))
X	     (function (second distributions))
X	     (parmname (third distributions))
X	     (function1 (select distributions 4))
X	     (index (send self :index))
X	     (parms (send self :parms)))
X	(setf (select parms 1) (select (send p2ctl :sequence) ind))
X	(send self :parms parms)
X	(funcall (select function index))
X	(funcall (select function1 index))
X	(send self :set-trans)
X	(send self :draw-data (send self :xdata))
X	(send self :describe-dist)))
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select data or Distribution!" 170 20 0 0))) 
X
X
(defun tr-data (x la1 la2)
X  (if (= la1 0) (log (+ x la2)) (/ (- (^ (+ x la2) la1) 1) la1)))
X
(defun standardize (x)
X  (let* ((mu (mean x))
X	 (s (standard-deviation x)))
X    (/ (- x mu) s)))
X
(defmeth tr-plot-proto :la-draw ()
X      (let* ((lactl (send self :lactl))
X	     (lac1 (first lactl))
X	     (lac2 (second lactl))
X	     (la1 (select (send lac1 :sequence) (send lac1 :index)))
X	     (la2 (select (send lac2 :sequence) (send lac2 :index)))
X	     (x (send self :xdata))
X	     (y (standardize (mapcar #'(lambda (a) (tr-data a la1 la2)) x))))
X	(send self :draw-data y)))
X
(defmeth tr-plot-proto :la1-chg (ind)
X  (if (< 0 (send (first (send self :graph1)) :num-points))
X      (let* ((lactl (send self :lactl))
X	     (lac1 (first lactl))
X	     (lac2 (second lactl))
X	     (la1 (select (send lac1 :sequence) ind))
X	     (la2 (select (send lac2 :sequence) (send lac2 :index)))
X	     (y (standardize 
X			    (mapcar #'(lambda (a) (tr-data a la1 la2)) 
X				   (send self :xdata))))
X	     (plot (send self :graph1))
X	     (plot1 (first plot))
X	     (plot2 (second plot))
X	     (plot3 (third plot)))
X	(send plot1 :clear nil)
X	(send plot1 :add-points (send self :ydata) y)
X	(send plot2 :clear nil)
X	(send plot2 :add-boxplot y :x 1)
X	(send plot3 :clear nil)
X	(send plot3 :add-points y)))
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select data or Distribution!" 170 20 0 0)))
X
(defmeth tr-plot-proto :la2-chg (ind)
X  (if (< 0 (send (first (send self :graph1)) :num-points))
X      (let* ((lactl (send self :lactl))
X	     (lac1 (first lactl))
X	     (lac2 (second lactl))
X	     (la1 (select (send lac1 :sequence) ind))
X	     (la2 (select (send lac2 :sequence) (send lac2 :index)))
X	     (x (send self :xdata))
X	     (y (standardize
X		 (mapcar #'(lambda (a) (tr-data a la1 la2)) x)))
X	     (plot (send self :graph1))
X	     (plot1 (first plot))
X	     (plot2 (second plot))
X	     (plot3 (third plot)))
X	(send plot1 :clear nil)
X	(send plot1 :add-points (send self :ydata) y)
X	(send plot2 :clear nil)
X	(send plot2 :add-boxplot y :x 1)
X	(send plot3 :clear nil)
X	(send plot3 :add-points y)
X	))
X  (if (not (send self :xdata)) (send self :draw-text 
X			"First, Select data or Distribution!" 170 20 0 0)))
X
;;;;; definitions of plot control protos
X
(defproto tr-n-control-proto '() () slider-control-proto)
(defmeth tr-n-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :n-chg new))))  
X  (slot-value 'index))
X
(defproto tr-parm1-control-proto '() () slider-control-proto)
(defmeth tr-parm1-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :parm1-chg new))
X	))  
X  (slot-value 'index))
X
(defproto tr-parm2-control-proto '() () slider-control-proto)
(defmeth tr-parm2-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(send self :do-action (elt (send self :sequence) new))
X	(if (send self :graph) (send (send self :graph) 
X				     :parm2-chg new))))  
X  (slot-value 'index))
X
(defproto tr-la1-control-proto '() () slider-control-proto)
(defmeth tr-la1-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(if (send self :graph) (send (send self :graph) 
X				     :la1-chg new))
X	))
X  (slot-value 'index))
(defproto tr-la2-control-proto '() () slider-control-proto)
(defmeth tr-la2-control-proto :index (&optional (new nil set))
X  (when set
X      (let* ((new (max (send self :min) (min new (send self :max)))))
X	(setf (slot-value 'index) new)
X	(send self :draw-indicator)
X	(if (send self :graph) (send (send self :graph) 
X				     :la2-chg new))))  
X  (slot-value 'index))
X
X
X
X
X
SHAR_EOF
chmod 0745 Teach/TR/tr4.lsp ||
echo 'restore of Teach/TR/tr4.lsp failed'
Wc_c="`wc -c < 'Teach/TR/tr4.lsp'`"
test 33853 -eq "$Wc_c" ||
	echo 'Teach/TR/tr4.lsp: original size 33853, current size' "$Wc_c"
fi
# ============= Teach/TR/tr-dataf.lsp ==============
if test -f 'Teach/TR/tr-dataf.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/TR/tr-dataf.lsp (File already exists)'
else
echo 'x - extracting Teach/TR/tr-dataf.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/TR/tr-dataf.lsp' &&
(def precipitation (list (list 0.77 1.74 0.81 1.2 1.95 1.2 0.47 1.43 3.37 
2.2 3 3.09 1.51 2.1 0.52 1.62 1.31 0.32 0.59 0.81 2.81 1.87 1.18 
1.35 4.75 2.48 0.96 1.89 0.9 2.05) "Precipitation"))
X
(def urban (list (list 206 170 155 155 134 239 234 228 330 284 201 241 
179 244 200 205 279 227 197 242 234) "Urban"))
X
(def rural (list (list  108 152 129 146 174 194 152 223 231 131 142 173
155 220 172 148 143 158 108 136) "Rural"))
X
(def hc (list (list  0.5 0.65 0.46 0.41 0.41 0.39 0.44 0.55 0.72 0.64 0.83 
0.38 0.38 0.5 0.6 0.73 0.83 0.57 0.34 0.41 0.37 1.02 0.87 1.1 0.65 
0.43 0.48 0.41 0.51 0.41 0.47 0.52 0.56 0.7 0.51 0.52 0.57 0.51 0.36 
0.48 0.52 0.61 0.58 0.46 0.47 0.55) "HC"))
X
(def co (list (list  5.01 14.67 8.6 4.42 4.95 7.24 7.51 12.3 14.59 7.98 
11.53 4.1 5.21 12.1 9.62 14.97 15.13 5.04 3.95 3.38 4.12 23.53 19 
22.92 11.2 3.81 3.45 1.85 4.1 2.26 4.74 4.29 5.36 14.83 5.69 6.35 
6.02 5.79 2.03 4.62 6.78 8.43 6.02 3.99 5.22 7.47) "CO"))
X
(def tensile-strength (list (list  162 233 232 231 231 237 224 219 203 189 
210 210 196 180 200 173 188 161 119 161 151 165 151 128 161 146 148 
144 134 127) "Tensil-Strength"))
X
(def hardness (list (list  45 55 61 66 71 71 81 86 53 60 64 68 79 81 56 68 75 
83 88 59 71 80 82 89 51 59 65 74 81 86) "Hardness"))
X
(def abrasion-loss (list (list  372 206 175 154 136 112 55 45 221 166 164 113 
82 32 228 196 128 97 64 249 219 186 155 114 341 340 283 267 215 148)
"Abrasion-Loss"))
X
(def flow (list (list  5 4.81 4.46 4.84 4.46 3.85 3.21 3.25 4.55 4.85 4 3.62 
5.15 3.76 4.9 4.13 5.1 5.05 4.27 4.9 4.55 4.39 4.85 4.59 5 3.82 3.68 
5.15 2.94 5 4.1 1.15 1.72 4.2 5) "Flow"))
X
(def moist (list (list  21 20 16 18 16 18 12 12 13 13 17 24 11 10 17 14 14 
14 20 12 11 10 16 17 17 17 15 17 21 21 21 26 21 17 11) "Moist"))
X
(def ratio (list (list  2.4 2.4 2.4 2.5 3.2 3.1 3.2 2.7 2.7 2.7 2.7 2.8 
2.5 2.6 2 2 2 1.9 2.1 1.9 2 2 2 2.2 2.4 2.4 2.4 2.2 2.2 1.9 2.4 
3.5 3 3.5 3.2) "Ratio"))
X
(def travel-space (list (list  12.8 12.9 12.9 13.6 14.5 14.6 15.1 17.5 19.5 20.8) "Travel-Space")) 
X
(def separation (list (list  5.5 6.2 6.3 7 7.8 8.3 7.1 10 10.8 11)
X "Separation"))
(def ethanol (list (list  0.59 0.3 0.25 0.03 0.44 0.18 0.13 0.02 0.22 0.23 
0.07 0 0.12 0.13 0 0.01) "Ethanol"))
X
(def air (list (list  80 80 75 62 62 62 62 62 58 58 58 58 58 58 50 50 50 
50 50 56 70) "Air")) 
SHAR_EOF
chmod 0745 Teach/TR/tr-dataf.lsp ||
echo 'restore of Teach/TR/tr-dataf.lsp failed'
Wc_c="`wc -c < 'Teach/TR/tr-dataf.lsp'`"
test 2325 -eq "$Wc_c" ||
	echo 'Teach/TR/tr-dataf.lsp: original size 2325, current size' "$Wc_c"
fi
# ============= Teach/Teach_CI ==============
if test -f 'Teach/Teach_CI' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/Teach_CI (File already exists)'
else
echo 'x - extracting Teach/Teach_CI (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/Teach_CI' &&
#! /bin/csh
xlispstat ci.lsp
SHAR_EOF
chmod 0765 Teach/Teach_CI ||
echo 'restore of Teach/Teach_CI failed'
Wc_c="`wc -c < 'Teach/Teach_CI'`"
test 29 -eq "$Wc_c" ||
	echo 'Teach/Teach_CI: original size 29, current size' "$Wc_c"
fi
# ============= Teach/Teach_CLT ==============
if test -f 'Teach/Teach_CLT' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/Teach_CLT (File already exists)'
else
echo 'x - extracting Teach/Teach_CLT (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/Teach_CLT' &&
#! /bin/csh
xlispstat clt.lsp
SHAR_EOF
chmod 0765 Teach/Teach_CLT ||
echo 'restore of Teach/Teach_CLT failed'
Wc_c="`wc -c < 'Teach/Teach_CLT'`"
test 30 -eq "$Wc_c" ||
	echo 'Teach/Teach_CLT: original size 30, current size' "$Wc_c"
fi
# ============= Teach/Teach_LS ==============
if test -f 'Teach/Teach_LS' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/Teach_LS (File already exists)'
else
echo 'x - extracting Teach/Teach_LS (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/Teach_LS' &&
#! /bin/csh
xlispstat ls.lsp
SHAR_EOF
chmod 0765 Teach/Teach_LS ||
echo 'restore of Teach/Teach_LS failed'
Wc_c="`wc -c < 'Teach/Teach_LS'`"
test 29 -eq "$Wc_c" ||
	echo 'Teach/Teach_LS: original size 29, current size' "$Wc_c"
fi
# ============= Teach/Teach_PP ==============
if test -f 'Teach/Teach_PP' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/Teach_PP (File already exists)'
else
echo 'x - extracting Teach/Teach_PP (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/Teach_PP' &&
#! /bin/csh
xlispstat pp.lsp
SHAR_EOF
chmod 0765 Teach/Teach_PP ||
echo 'restore of Teach/Teach_PP failed'
Wc_c="`wc -c < 'Teach/Teach_PP'`"
test 29 -eq "$Wc_c" ||
	echo 'Teach/Teach_PP: original size 29, current size' "$Wc_c"
fi
# ============= Teach/Teach_SD ==============
if test -f 'Teach/Teach_SD' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/Teach_SD (File already exists)'
else
echo 'x - extracting Teach/Teach_SD (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/Teach_SD' &&
#! /bin/csh
xlispstat sd.lsp
SHAR_EOF
chmod 0765 Teach/Teach_SD ||
echo 'restore of Teach/Teach_SD failed'
Wc_c="`wc -c < 'Teach/Teach_SD'`"
test 29 -eq "$Wc_c" ||
	echo 'Teach/Teach_SD: original size 29, current size' "$Wc_c"
fi
# ============= Teach/Teach_TR ==============
if test -f 'Teach/Teach_TR' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/Teach_TR (File already exists)'
else
echo 'x - extracting Teach/Teach_TR (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/Teach_TR' &&
#! /bin/csh
xlispstat tr.lsp
SHAR_EOF
chmod 0765 Teach/Teach_TR ||
echo 'restore of Teach/Teach_TR failed'
Wc_c="`wc -c < 'Teach/Teach_TR'`"
test 29 -eq "$Wc_c" ||
	echo 'Teach/Teach_TR: original size 29, current size' "$Wc_c"
fi
# ============= Teach/ci.lsp ==============
if test -f 'Teach/ci.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/ci.lsp (File already exists)'
else
echo 'x - extracting Teach/ci.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/ci.lsp' &&
#+msdos (load "nsf\\overlay1")
#+msdos (load "nsf\\overlay2")
#+msdos (load "nsf\\overlay3")
#+msdos (load "nsf\\make-col.lsp")
#+msdos (load "nsf\\ci.sim")
#+macintosh (load ":nsf:overlay1")
#+macintosh (load ":nsf:overlay2")
#+macintosh (load ":nsf:overlay3")
#+macintosh (load ":nsf:make-col.lsp")
#+macintosh (load ":nsf:ci.sim")
#+unix (load "OVL/overlay1")
#+unix (load "OVL/overlay2")
#+unix (load "OVL/overlay3")
#+unix (load "OVL/make-col.lsp")
#+unix (load "CI/ci.sim")
(sim)
SHAR_EOF
chmod 0745 Teach/ci.lsp ||
echo 'restore of Teach/ci.lsp failed'
Wc_c="`wc -c < 'Teach/ci.lsp'`"
test 486 -eq "$Wc_c" ||
	echo 'Teach/ci.lsp: original size 486, current size' "$Wc_c"
fi
# ============= Teach/clt.lsp ==============
if test -f 'Teach/clt.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/clt.lsp (File already exists)'
else
echo 'x - extracting Teach/clt.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/clt.lsp' &&
#+msdos (load "nsf\\overlay1")
#+msdos (load "nsf\\overlay2")
#+msdos (load "nsf\\overlay3")
#+msdos (load "nsf\\rgraph1")
#+msdos (load "nsf\\fun1")
#+msdos (load "nsf\\boxplot")
#+msdos (load "nsf\\clt8")
#+macintosh (load ":nsf:overlay1")
#+macintosh (load ":nsf:overlay2")
#+macintosh (load ":nsf:overlay3")
#+macintosh (load ":nsf:rgraph1")
#+macintosh (load ":nsf:fun1")
#+macintosh (load ":nsf:boxplot")
#+macintosh (load ":nsf:clt8")
#+unix (load "OVL/overlay1")
#+unix (load "OVL/overlay2")
#+unix (load "OVL/overlay3")
#+unix (load "OVL/rgraph1")
#+unix (load "OVL/fun1")
#+unix (load "OVL/boxplot")
#+unix (load "CLT/clt8")
(cltplot)
SHAR_EOF
chmod 0745 Teach/clt.lsp ||
echo 'restore of Teach/clt.lsp failed'
Wc_c="`wc -c < 'Teach/clt.lsp'`"
test 645 -eq "$Wc_c" ||
	echo 'Teach/clt.lsp: original size 645, current size' "$Wc_c"
fi
# ============= Teach/ls.lsp ==============
if test -f 'Teach/ls.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/ls.lsp (File already exists)'
else
echo 'x - extracting Teach/ls.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/ls.lsp' &&
#+msdos (load "nsf\\overlay1")
#+msdos (load "nsf\\overlay2")
#+msdos (load "nsf\\overlay3")
#+msdos (load "nsf\\make-col.lsp")
#+msdos (load "nsf\\lsestm.lsp")
#+msdos (load "nsf\\ls-dataf.lsp")
#+macintosh (load ":nsf:overlay1")
#+macintosh (load ":nsf:overlay2")
#+macintosh (load ":nsf:overlay3")
#+macintosh (load ":nsf:make-col.lsp")
#+macintosh (load ":nsf:lsestm.lsp")
#+macintosh (load ":nsf:ls-dataf.lsp")
#+unix (load "OVL/overlay1")
#+unix (load "OVL/overlay2")
#+unix (load "OVL/overlay3")
#+unix (load "OVL/make-col.lsp")
#+unix (load "LS/lsestm.lsp")
#+unix (load "LS/ls-dataf.lsp")
(ls)
X
SHAR_EOF
chmod 0745 Teach/ls.lsp ||
echo 'restore of Teach/ls.lsp failed'
Wc_c="`wc -c < 'Teach/ls.lsp'`"
test 604 -eq "$Wc_c" ||
	echo 'Teach/ls.lsp: original size 604, current size' "$Wc_c"
fi
# ============= Teach/pp.lsp ==============
if test -f 'Teach/pp.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/pp.lsp (File already exists)'
else
echo 'x - extracting Teach/pp.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/pp.lsp' &&
#+msdos (load "nsf\\overlay1")
#+msdos (load "nsf\\overlay2")
#+msdos (load "nsf\\overlay3")
#+msdos (load "nsf\\rgraph1")
#+msdos (load "nsf\\fun1")
#+msdos (load "nsf\\boxplot")
#+msdos (load "nsf\\pp-dataf")
#+msdos (load "nsf\\pp6")
#+macintosh (load ":nsf:overlay1")
#+macintosh (load ":nsf:overlay2")
#+macintosh (load ":nsf:overlay3")
#+macintosh (load ":nsf:rgraph1")
#+macintosh (load ":nsf:fun1")
#+macintosh (load ":nsf:boxplot")
#+macintosh (load ":nsf:pp-dataf")
#+macintosh (load ":nsf:pp6")
#+unix (load "OVL/overlay1")
#+unix (load "OVL/overlay2")
#+unix (load "OVL/overlay3")
#+unix (load "OVL/rgraph1")
#+unix (load "OVL/fun1")
#+unix (load "OVL/boxplot")
#+unix (load "PP/pp-dataf")
#+unix (load "PP/pp6")
(pp)
SHAR_EOF
chmod 0745 Teach/pp.lsp ||
echo 'restore of Teach/pp.lsp failed'
Wc_c="`wc -c < 'Teach/pp.lsp'`"
test 730 -eq "$Wc_c" ||
	echo 'Teach/pp.lsp: original size 730, current size' "$Wc_c"
fi
# ============= Teach/sd.lsp ==============
if test -f 'Teach/sd.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/sd.lsp (File already exists)'
else
echo 'x - extracting Teach/sd.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/sd.lsp' &&
#+msdos (load "nsf\\overlay1")
#+msdos (load "nsf\\overlay2")
#+msdos (load "nsf\\overlay3")
#+msdos (load "nsf\\rgraph1")
#+msdos (load "nsf\\make-col.lsp")
#+msdos (load "nsf\\sd3.lsp")
#+macintosh (load ":nsf:overlay1")
#+macintosh (load ":nsf:overlay2")
#+macintosh (load ":nsf:overlay3")
#+macintosh (load ":nsf:rgraph1")
#+macintosh (load ":nsf:make-col.lsp")
#+macintosh (load ":nsf:sd3.lsp")
#+unix (load "OVL/overlay1")
#+unix (load "OVL/overlay2")
#+unix (load "OVL/overlay3")
#+unix (load "OVL/rgraph1")
#+unix (load "OVL/make-col.lsp")
#+unix (load "SD/sd3.lsp")
(sd)
SHAR_EOF
chmod 0745 Teach/sd.lsp ||
echo 'restore of Teach/sd.lsp failed'
Wc_c="`wc -c < 'Teach/sd.lsp'`"
test 580 -eq "$Wc_c" ||
	echo 'Teach/sd.lsp: original size 580, current size' "$Wc_c"
fi
# ============= Teach/tr.lsp ==============
if test -f 'Teach/tr.lsp' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/tr.lsp (File already exists)'
else
echo 'x - extracting Teach/tr.lsp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/tr.lsp' &&
#+msdos (load "nsf\\overlay1")
#+msdos (load "nsf\\overlay2")
#+msdos (load "nsf\\overlay3")
#+msdos (load "nsf\\rgraph1")
#+msdos (load "nsf\\fun1")
#+msdos (load "nsf\\boxplot")
#+msdos (load "nsf\\tr4.lsp")
#+msdos (load "nsf\\tr-dataf.lsp")
#+macintosh (load ":nsf:overlay1")
#+macintosh (load ":nsf:overlay2")
#+macintosh (load ":nsf:overlay3")
#+macintosh (load ":nsf:rgraph1")
#+macintosh (load ":nsf:fun1")
#+macintosh (load ":nsf:boxplot")
#+macintosh (load ":nsf:tr4.lsp")
#+macintosh (load ":nsf:tr-dataf.lsp")
#+unix (load "OVL/overlay1")
#+unix (load "OVL/overlay2")
#+unix (load "OVL/overlay3")
#+unix (load "OVL/rgraph1")
#+unix (load "OVL/fun1")
#+unix (load "OVL/boxplot")
#+unix (load "TR/tr4.lsp")
#+unix (load "TR/tr-dataf.lsp")
(trp)
X
X
SHAR_EOF
chmod 0745 Teach/tr.lsp ||
echo 'restore of Teach/tr.lsp failed'
Wc_c="`wc -c < 'Teach/tr.lsp'`"
test 757 -eq "$Wc_c" ||
	echo 'Teach/tr.lsp: original size 757, current size' "$Wc_c"
fi
# ============= Teach/install.xlispstat ==============
if test -f 'Teach/install.xlispstat' -a X"$1" != X"-c"; then
	echo 'x - skipping Teach/install.xlispstat (File already exists)'
else
echo 'x - extracting Teach/install.xlispstat (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Teach/install.xlispstat' &&
In order to run Teach modules, you will first need a copy of XLISP-STAT.
If you don't have a copy of XLISP-STAT,  you can obtain a copy via 
electronic mail or via ftp.  Send mail to: 
X
X                   statlib@temper.stat.cmu.edu
X
containing the single line 
X
X                     send index from xlispstat.
X
This mail should contain no subject header and no extraneous
information because it will be processed by the computer and not by a
human.
X
You also can obtain XLISP-STAT by ftp from umnstat.stat.umn.edu.
X 
Follow the instructions given there to install XLISP-STAT on your system. 
X
SHAR_EOF
chmod 0660 Teach/install.xlispstat ||
echo 'restore of Teach/install.xlispstat failed'
Wc_c="`wc -c < 'Teach/install.xlispstat'`"
test 594 -eq "$Wc_c" ||
	echo 'Teach/install.xlispstat: original size 594, current size' "$Wc_c"
fi
exit 0
