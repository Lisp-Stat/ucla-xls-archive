;;;;   Estimation of the Poisson models;;;;;;;;             11 Nov 93 ... Special things for the geometric moment ests.;;;;             24 Jun 93 ... Add in the ML code.  Make into objects.;;;;             13 May 93 ... Add the revised code for acf and prob appear.;;;;             16 Apr 93 ... Cut from sim code.;;;;(require "utils")(require "coderes");;;;(provide "Poisson")#|  (send *code-manager* :load   'poisson)  (send *code-manager* :unload 'poisson)  (def data (poisson-rand 200 2))  (time (standard-deviation data))  (time (estimate-integer-acf (poisson-rand 100 2)))  (def x (poisson-rand 200 2))  (def y (poisson-rand 200 3))  (time (calc-log-poisson-prob data 3)) |#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                                                       ;;;               Estimating the autocovariance function                  ;;;                                                                       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun VAR (x) (^ (standard-deviation x) 2))(defun ESTIMATE-POISSON-ACF (y &key (maxlag 10))  ;  Estimated lag covariances, with keyed maximum lag.  Length is 1+maxLag.  ;  Uses the Poisson method  E(X) - Var(X-Y)/2.  Y must be integer.  (let ((acs (repeat -777.7 (1+ maxLag)))   )    (select     (call-cfun "CalcACS"                1  y (length y) (float acs) (length acs))     3))  )(defun ESTIMATE-INTEGER-ACF (y &key (maxLag 10) mod)  ;  Traditional lag product estimator. Y MUST be integers  (let ((acs (repeat -777.7 (1+ maxLag)))  )    (select     (call-cfun "CalcACS" 0  y (length y) acs (length acs))     3))  );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                                                       ;;;               Log-likelihood                                          ;;;                                                                       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; --- Compute the log-likelihood by applying this method to n pairs in data;     Arg is lambda C, NOT the unique or net lambda.(defun CALC-LOG-POISSON-PROB (xy lamC &key lam)           ; mod 20 Nov 94  ; Data xy is a pair of lists.  (let ((scrLen (* 3 (1+ 75)))      ; 75 is maxPower used in C code.        (lamU (- (if lam lam        ; estimate common lam if parm not input.                     (mean data))                 lamC))     )    (if (and (< 0 lamC) (< 0 lamU))        (let ((cRes (call-cfun "LambdaLogLike" 0                               (first xy) (second xy)                               (length (first xy))                               (float lamU) (float lamC)                               (make-array scrLen :initial-element 7.7)                               scrLen                               7.7))    )          (if (> 0 (car (car cRes)))              (format t "Need more space in calc-log-prob(c): ~% ~a ~%"                      cRes)              (car (nth 8 cRes))   ))        (progn ; message and return very negative value if neg lambda.         (def SAVE (list xy lamC lam))   ; RAS         (format t "Log prob: lambda negative; lamC=~a, lamU=~a.~%" lamC lamU)         -7777777)        )))