;;;;;;;;    Utilities for Lisp;;;;;;;;                       25 Feb 91 --> 5 Mar 95;;;;    Includes:;;;;               Context, printing;;;;               APL;;;;               List filtering;;;;               Simple stats, plots(provide "utils");;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                                               ;;;;                  Context                                      ;;;;                                                               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defconstant macintosh? (if (member :macintosh *features*) t nil))(defconstant unix?      (if (member :unix      *features*) t nil));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                                               ;;;;                   Macros                                      ;;;;                                                               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defmacro DO-UNTIL (test &body body)  `(do ()       (,test)       ,@body));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                                               ;;;;                  Printing                                     ;;;;                                                               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(setf *float-format* "%g")(def *verbose* t)(defun vPrint (&rest args)  (when *verbose*      (apply #'format t args)      ))(defun PRINT-REAL-LIST (str lst wid dec)  (format t "~a: " str)  (mapcar #'(lambda (x)              (format t " ~v,vf" wid dec x))          lst)  (terpri)); (format t "~{ ~8,3f ~}~%" list)(defun WARNING (f str &rest args)  (format t "*** WARNING ***~%")  (format t str args)  (terpri));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                                               ;;;;                    Files                                      ;;;;                                                  7 Mar 95     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun MAKE-NEW-FILE (fileSymbol comment &key ifExists)  ; Creates a new file with insertion of comment line.  ; Options include :append, :overwrite, :new-version, and :error  ; 5 Mar 95  (with-open-file (fs (string-downcase (string fileSymbol))                      :direction :output                      :if-exists (if ifExists ifExists :error)                      :if-does-not-exist :create)                  (format fs "~s~%" comment)                  ))(defun APPEND-TO-FILE (fileSymbol data)  ; Adds a list line to the indicated file.  ; 5 Mar 95  (with-open-file (fs (string-downcase (string fileSymbol))                      :direction :output                      :if-exists :append                      :if-does-not-exist :error)                  (format fs "~s~%" data)                  )); (def res (read-file 'geo2.5 :func #'(lambda (x) (combine (rest x)))))(defun READ-FILE (fileSymbol &key func)  ; Prints the comment line and then returns result, one for each line.  ; Applies the function func to each result when done.  ; 5 Mar 95 ... 7 Mar 95  (let ((line nil)        (contents nil)  )    (with-open-file (fs (string-downcase (string fileSymbol))                        :direction :input :if-does-not-exist :error)                    (loop (setf line (read-line fs nil 'eof))                          (when (eq line 'eof)                                (format t "Read completed...~%")                                (return))                          (push (with-input-from-string (s line)                                                        (read s))                                contents)                          ))    (setf contents (reverse contents))    (format t "First line-> ~s~%" (first contents))    (if func        (mapcar func (rest contents))        (rest contents))    )); (pathname); (file-write-date );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                                               ;;;;                  String Handling                              ;;;;                                                  27 Feb 95    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun STRCAT (&rest args)  (apply #'concatenate 'string args))(defun STRING-TO-SYMBOLS (str)  ; Converts the string to a list of symbols as distinguised by  ; one or more spaces.  ; 27 Feb 94 ... 27 Feb 95  (with-input-from-string (s (strcat "(" str ")"))                          (read s))); (string-to-symbols "This is a test")(defun STRING-TO-STRINGS (str &optional (delimChar #\Space))  ; Converts input string into strings as separated by the   ; delimiter character. Spaces and delim are removed from source.  ; 27 Feb 94 ... 27 Feb 95  (let ((remove (remove-duplicates                 (strcat (string delimChar) (string #\Space)))  )        (soFar  nil)  )    (labels ((recur (s)                     (let ((pos (position delimChar s))  )                      (if pos                          (if (zerop pos)                              (recur (string-left-trim remove s))                              (progn                               (push (string-trim remove (subseq s 0 pos))                                     soFar)                               (recur (subseq s (1+ pos)))   ))                          (push (string-trim remove s) soFar)                          )))  )      (recur str)      (reverse soFar)      ))); (string-to-strings "This is  a   test")(defun SUBLIS-STR (pairs target)  ; Put second member of each cons pair into target where first is found.  ; 17 Feb 95 ... 24 Feb 95  (let ((found nil))    (flet ((insert (p)                   (let ((pos (search (first p) target))  )                     (when pos                           (format t "Found ~a @ ~d ~%" (first p) pos)                           (setf found t)                           (setf target                                 (concatenate                                  'string                                  (subseq target 0 pos)                                  (rest p)                                  (subseq target (+ pos                                                    (length (first p)) ))                                  )))                     ))  )      (dolist (p pairs)              (insert p)   )      (values target found)      )));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                                               ;;;;                    APL                                        ;;;;                                                               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     EXECUTION(defun execute (text &key (echo? t))  (if echo? (format t "EXECUTE ~a ~%" text))  (eval (read (make-string-input-stream text) nil))  nil);  (execute (format nil "(def s~a 3)" 1));;     IOTA(defun iota (n)  "Integers from 1 to n."  (iseq 1 n));;     COMPRESS  (also see reduce)(defun compress (f v)  (apply f v));;     SCAN(defun scan (f v)  (accumulate f v))(defun scan (f v &optional(soFar ()))  (cond    ((= 0 (length v)) (reverse soFar))    ((eq soFar ()) (scan f (cdr v) (list (first v))))    ( t  (scan f (cdr v) (cons (funcall f (first soFar) (first v)) soFar)))    ));;     RHO(defun rho (array)  (array-dimensions (array)));;     RESHAPE(defun reshape (dim list)  "Build a matrix from the elements in list."  (let* ((nRows  (first  dim))         (nCols  (second dim))         (nElem  (* nRows nCols))         (mat    (make-array dim))     ; array having desired dimensions         (linear (make-array nElem :displaced-to mat)))  ; linearized   (dotimes (element nElem mat)       (setf (aref linear element) (car list))       (setf list (cdr list))  )))             ;;     RAVEL(defun ravel (mat)  "Convert a matrix into a list."  (combine mat));;     TAKE;(defun take (n seq &optional result)        ; tail recursion via opt parm;    (if (> n 0);      (take (- n 1) (cdr aList) (cons (first aList) result));      (reverse result));  )(defun TAKE (n seq &optional toList)  (cond    ((= 0 n)      ())    ((listp   seq) (take n (coerce seq 'vector) t))    ((vectorp seq) (let* ((an   (abs n))                          (len  (length seq))                          (nadd (max 0 (- an len)))                          (padd (repeat 0 nAdd))                          (take (- an nadd))                          (in   (if (> n 0)                                    (iseq take)                                    (iseq (- len take) (1- len) )))                          (type (if toList 'list 'vector))  )                     (if (> n 0)                         (concatenate type (select seq in) padd)                         (concatenate type padd (select seq in))                         )))     ));;     DROP; (defun drop (n aList);  (nthcdr n aList))(defun DROP (n seq &optional toList)  "Drop n's from front/back of input sequence. n may be list."  (cond    ((listp n)     (if (endp n) seq                       (drop (rest n) (drop (car n) seq toList) toList)))    ( (= 0 n)       seq)    ((listp   seq) (drop n (coerce seq 'vector) t))    ((vectorp seq) (let* ((an   (abs n))                          (len  (length seq))                          (drop (min len an))                          (in   (if (> n 0)                                    (iseq drop (1- len))                                    (iseq (- len drop))))                          (type (if toList 'list 'vector))  )                     (if (= drop len)                         ()                         (coerce (select seq in) type))  )     )));;;      ___________  ARRAY ROW AND COLUMN  ______________(defun ARRAY-COL (a j)  (if (and (>= j 0) (< j (second (array-dimensions a))))      (let* ((dim (array-dimensions a))             (col (make-array (first dim)))  )        (dotimes (i (first dim) col)                 (setf (aref col i) (aref a i j))                 )        )))  (defun ARRAY-ROW (a i)  (if (and (>= i 0) (< i (first (array-dimensions a))))      (let* ((dim (array-dimensions a))             (row (make-array (second dim)))  )        (dotimes (j (second dim) row)                 (setf (aref row j) (aref a i j))                 )        )));;;            ___________  FILTER/COUNT UTILS   _______________;;     FIND-IF(defun find-if (pred aList)           ;  Lisp function  missing in XLisp ???  (if aList      (if (funcall pred (first aList))          (first aList)          (find-if pred (rest aList)))      ));;     COUNT-IF                       ;  Lisp function missing in XLisp ???(defun count-if (pred aList &optional (count 0))  (cond ((endp aList) count)        ((funcall pred (first aList)) (count-if pred (rest aList) (1+ count)))        ( t   (count-if pred (rest aList) count))    ))(defun COUNT-IF (pred aList)  (let ((count 0))    (dolist (i aList count)            (setf count (if (funcall pred i) (1+ count) count)))    ));;     REPLACE-IF                     ; in place replacement of FIRST found(defun replace-if (pred aList new)  (cond ((endp aList)   ())        ((funcall pred (first aList))  (setf (car aList) new))        (    t          (replace-if pred (rest aList) new))    ));;;    ________________   ELEMENT REPETITION   ________________                       ;;;  (def mat (encode '(1 1 1 2 2 2 3 3 3 3 3 3) '((1 2) 3 5)))(defun ENCODE (catList grps)  "Builds a matrix of dummy vars associated with ids in grps."  (let* ((grps (mapcar #'(lambda(x) (if (listp x) x (list x)))                       grps))                      ; make arg into lists         (grps (remove-if #'(lambda (g)            ; use groups that appear                              (= 0 (sum                                    (mapcar #'(lambda (x)                                                (if (member x catList) 1 0))                                                g))))                              grps))         (cols (mapcar #'(lambda (grp)               ; build indicators                           (mapcar #'(lambda (x) (if (member x grp) 1 0))                                   catList) )                       grps))         )    (list (mapcar #'(lambda (k) (format nil "~a" k)) grps)          (apply #'bind-columns cols))     ));;     UNIQUE                         ;  list of the unique elements;(defun unique (aList &optional result);  (if (endp aList) result;      (if (member (first aList) (rest aList) :test #'equal) ; weak test on ;value;          (unique (rest aList) result);          (unique (rest aList) (cons (first aList) result));          )))(defun UNIQUE (seq)  (cond    ((listp   seq) (remove-duplicates seq))    ((vectorp seq) (let ((keep (list 0))          ; assumes sorted                         (last (aref seq 0))                         (iLim (1- (length seq)))  )                     (dotimes (i iLim (select seq (reverse keep)))                              (setf keep (if (< last (aref seq (1+ i)))                                            (cons (1+ i) keep)                                            keep))                              (setf last (aref seq (1+ i)))                              ))     )));;     MATCH (or WHERE-IN y are the elements of x, both sorted arrays)(defun where-in (x y &key (origin 0))  (let* ((n (length x))        (result (make-array n))        (yIn 0))    (dotimes (i n result)             (let ((xi (aref x i)))               (loop                (if (= xi (aref y yIn))                    (progn                     (setf (aref result i) (+ yIn origin))                     (return))                    (setf yIn (1+ yIn))                   ))               ))))              ; (where-in '#(0.4 0.45 0.45 0.6) '#(0 0.2 0.4 0.45 0.6 0.7) )   ;;;     __________________  OTHER UTILS   ______________________;;     GET COLUMN FROM ARRAY(defun getcol (col mat)  (if (matrixp mat)      (let* ((dim   (array-dimensions mat))             (nRows (first dim))             (nCols (second dim))             (list  (make-list nRows))   )        (if (<= col nCols)            (dotimes (row nRows list)                (setf (elt list row) (aref mat row col))            )))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                                               ;;;;             Descriptive Stats                                 ;;;;                                                               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (defun HIST-COUNTS (x)    ; Counts the number of values at integers from min to max of x    ; 9 Apr 95    (let ((bins (iseq (min x) (max x)))          (sx  (sort-data x))          (pos 0)          (cts ())  )      (dolist (b bins)              (if (setf pos (position b sx))                  (push pos cts)                  (push (first cts) cts))              )      (def save cts)      (list bins            (difference (reverse (push (length x) cts)))            )))            (defun MANDS (x &optional label)    ; ... 3 Apr 95    (if (listp (first x))        (mapcar #'mands x label)        (let ((sd (standard-deviation x)))          (format           t "~a: Mean ~7,4f (se ~7,4f); sd ~7,4f RMSE ~7,4f [md ~7,4f, iq ~7,4f]~%"           (if label label "")           (mean x) (/ sd (sqrt (length x))) sd           (sqrt (mse x))           (median x) (interquartile-range x)))        ))      (defun MSE (x)    (/ (sum (* x x)) (length x)))  (defun COVAR (x y)    (let ((x (- x (mean x)))          (y (- y (mean y)))   )      (/ (inner-product x y) (1- (length x)))      ))                (defun AUTOCORR (x &optional y &key (nLags 10))    ; Gives cross-corr if y is given    ; 27 Nov 94    (flet ((stan (z) (/ (- z (mean z)) (standard-deviation z)))   )      (let* ((acf ())             (n (length x))             (x (stan x))             (z (if y (stan y) x))  )        (when y ; padd with zeros              (setf x (nconc (repeat 0 nLags) x))              (setf z (nconc z (repeat 0 nLags)))  )        (dotimes (i (1+ (if y (* 2 nLags) nLags)))                 (push (inner-product x z) acf)                 (setf x (rest x))                 (setf z (butlast z))                 )        (reverse (/ acf (1- n)))        )))  (defun CORR (x &optional y)    ; Modified to handle a matrix.    ; 27 Nov 94 ... 10 May 95    (if y        (let* ((x   (- x (mean x)))               (y   (- y (mean y)))               (den (sqrt (* (inner-product x x) (inner-product y y))))               (c   (if (< 0 den) (/ (inner-product x y) den)                        (progn (format t "Zero variance.~%")                               0)))    )          (format t "correlation is ~a~%" c)          c)        (let* ((cm (apply #'covariance-matrix x))               (d  (sqrt (diagonal cm)))    )          (/ cm (outer-product d d #'*)))        ))  ;;     ____________________  PLOTS  _______________________________(defun SCHEMATIC-PLOT (x reps &key addTo center (color 'black))  "Adds a scematic plot of the replicated series at x to input plot."  (let* ((mat   (apply #'bind-rows reps))         (bins  (column-list mat))         (os    (mapcar #'fivnum bins))         (os    (if center (mapcar #'(lambda (x) (- x (third x)))                                  (coerce os 'list))                    os))         (os    (apply #'bind-rows os))         (os    (column-list os))         (plot  (if addTo addTo (plot-lines x (repeat 0 (length x))))) )    (send plot :add-points x (first os)        :color color :symbol 'dot2)    (send plot :add-points x (first (last os)) :color color :symbol 'dot2)    (send plot :line-type 'dashed)    (send plot :add-lines x  (second os) :color color)    (send plot :add-lines x  (fourth os) :color color)    (send plot :line-type 'solid)    (send plot :add-lines x  (third  os) :color color)    (send plot :adjust-to-data)    plot    ))