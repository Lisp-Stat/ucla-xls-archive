#include <math.h>#include <stdlib.h>#include "probability.h"#ifdef _UNIX_#include "probability.c"#endif#define Sqr(x) ((x)*(x))//	Prototypesvoid Main (void);		// Dummy mainvoid CalcACS (long *method, long *y, long *tLimit, double *acs, long *jLimit);void LambdaLogLike (long *returnCode, long *y, long *x, long *pN,		 double *plamU, double *plamC, double *scratch, long *pLenScr, double *pLogLike);//	Mainvoid main (void){	int i;	i = 1;}/*  ___________________  Calculating the autocovariances  ____________________  */void CalcACS (long *meth, long *y, long *tLimit, double *acs, long *jLimit){	long t,j, diff, sum, total, end;	long tLim, jLim, method;	double mean, yBarOverN, n;			method = *meth;                 /* Convert to long values */	tLim = *tLimit;	jLim = *jLimit;			sum = 0;							/* first find the mean of the series */	for (t=0; t<tLim; ++t)		sum += y[t];	mean = ((double) sum) / ((double) tLim);		if (method == 0)	{	n = (double) tLim;		yBarOverN = mean / n;		total = sum;		sum = 0;		for (t = 0; t < tLim; ++t)		/* do variance first since no lag */			sum += y[t] * y[t];		*acs++ = ((double) sum) / n - mean * mean;		end = 0;		for (j=1; j < jLim; ++j)		{	sum = 0;			for (t = j; t< tLim; ++ t)				sum += y[t] * y[t-j];			end += y[j-1] + y[tLim-j];			*acs++ = ((double) sum) / n    /* adjust for end effects in mean corr */					- yBarOverN * ((double) (2 * total - end)  - (mean * (n-j)));		}	} else	{	*acs++ = mean;		for (j=1; j < jLim; ++j)		{	sum = 0;			for (t = j; t < tLim; ++t)			{	diff = y[t] - y[t-j];				sum += diff * diff;			}			*acs++ = mean - ((double) sum) / ((double) 2*tLim);		}	}}void LambdaLogLike (long *returnCode, long *y, long *x, long *pN,		 double *plamU, double *plamC, double *scratch, long *pLenScr, double *pLogLike){	long i,j, xySum, maxSum, maxPower;		double *lamCPower, *lamUPower, *factorial,				sum, id, min;		maxPower = (*pLenScr / 3) - 1;			// Check for room	maxSum = 0;	for(i=0; i < *pN; ++ i)	{	sum = x[i]+y[i];		if (sum > maxSum)		{	maxSum = sum;			if (maxSum > maxPower)			/* no room in the inn -> RETURN */			{	*returnCode = -maxSum;				*y = i;				return;			}		}	}	maxPower = maxSum;		/* Set pointers for lookup tables */		lamCPower = scratch;	lamUPower = scratch +   (maxPower+1) ;	factorial = scratch + 2*(maxPower+1) ;		/* Initialize lookup tables */		lamCPower[0] = 1.0; 	lamUPower[0] = 1.0;	factorial[0] = 1.0;	for(i=1; i<=maxPower; ++i)	{	lamCPower[i] = *plamC * lamCPower[i-1];		lamUPower[i] = *plamU * lamUPower[i-1];		id = (double) i;		factorial[i] = id * factorial[i-1];	}		/* Accumulate log likelihood, with lambda terms at start */		id = (double) *pN;	*pLogLike = - id * (*plamC + 2.0 * *plamU);	for(i=0; i<*pN; ++i)	{	sum = 0.0;		if (x[i] < y[i]) min = x[i];		    else   		 min = y[i];		xySum = x[i] + y[i];		for(j = 0; j <= min; ++j)			sum +=  (lamCPower[j] * lamUPower[xySum - 2*j])					/ (factorial[j] * factorial[x[i]-j] * factorial[y[i]-j]);		*pLogLike += log(sum);	}			*returnCode = 0;}		