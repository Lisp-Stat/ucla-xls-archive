/* macdynload - Dynamic loading and C function calling routines.       *//* XLISP-STAT 2.1 Copyright (c) 1990, by Luke Tierney                  *//* Additions to Xlisp 2.1, Copyright (c) 1989 by David Michael Betz    *//* You may give out copies of this software; for conditions see the    *//* file COPYING included with this distribution.                       *//* Calling conventions are based on the conventions given in the New S *//* book.                                                               */#ifndef __FRAGLOAD__					// RAS: need to get some symbols from here#	include <FragLoad.h>#endif#include "xlisp.h"#include "xlstat.h"#include "xlsx.h"#include "sharedlib.h"					// RAS: added this and next line for MAXARGS#define MAXARGS 15						#define seqlen(x) ((vectorp(x)) ? getsize(x) : llength(x))extern char buf[];extern LVAL s_true;extern LVAL newvector(), mklist(), getnextelement();extern double makedouble();typedef void  (*pfv_t)(...);    /* pointer to function returning void. *//************************************************************************//**                                                                    **//**                  Resource File Handling Functions                  **//**                                                                    **//************************************************************************/LVAL xsopen_resfile(void){ 	char	*name;	int		verbose;	long	sym, symCount;	LVAL	verboseLVAL;  	OSErr	err;  	Str255	extName;	Ptr		extAddr;	SymClass extClass;	ConnectionID id;  	name = (char *) getstring(xlgastring());	if (xlgetkeyarg(k_verbose, &verboseLVAL))		verbose = (verboseLVAL != NIL);	else verbose = FALSE;	xllastarg();    /*	RAS: replaces the following code  CtoPstr(name);  fn = OpenResFile((StringPtr) name);  PtoCstr((StringPtr) name);  */  	id = OpenLibrary(name);	if ((id != kNoConnectionID) && verbose)	{	err = CountSymbols(id, &symCount);		if (! err)		{	sprintf(buf, "\nExported symbol list from library #%d\n", id);			stdputstr(buf);			sprintf(buf, "        Name               Address    Class\n");			stdputstr(buf);			for (sym=0; sym<symCount; ++sym)			{	err = GetIndSymbol(id, sym, extName, &extAddr, &extClass);				PtoCstr(extName);				sprintf(buf, "%d  %-20s   %d      %d\n", sym, extName, extAddr, extClass);				stdputstr(buf);			}			sprintf(buf, "\n");			stdputstr(buf);		}  	}	return((id >= 0) ? cvfixnum((FIXTYPE) id) : NIL);}LVAL xsclose_resfile(void){  int fn;    fn = getfixnum(xlgafixnum());  xllastarg();  /*	RAS: replace next with CloseLibrary  CloseResFile(fn);  */  CloseLibrary(fn);  return(NIL);}/************************************************************************//**                                                                    **//**               Allocation and Error Signalling Functions            **//**                                                                    **//************************************************************************/static LVAL current_allocs = NULL;#define fixup_current_allocs \  { if (current_allocs == NULL) current_allocs = NIL; }/* allocate space that will be garbage collected after return */static char *xscall_alloc(int n, int m){  LVAL adata;  char *p;  fixup_current_allocs;  adata = newadata(n, m, FALSE);  if (adata == NIL || (p = getadaddr(adata)) == nil)    xlfail("allocation failed");  current_allocs = cons(adata, current_allocs);  return(p);}/* error routine for use within C functions */static VOID xscall_fail(char *s) { xlfail(s); }/************************************************************************//**                                                                    **//**                Lisp to C/FORTRAN Data Conversion                   **//**                                                                    **//************************************************************************/#define IN 0#define RE 1typedef struct {  int type, size;  char *addr;} call_arg;/* convert lisp argument to allocated pointer */static call_arg lisp2arg(LVAL x){  call_arg a;  LVAL elem, data;  int i;  xlprot1(x);  /* make sure x is a sequence and find its length */  if (! sequencep(x)) x = consa(x);  a.size = seqlen(x);  /* determine the mode of the data */  for (i = 0, a.type = IN, data = x; i < a.size; i++) {    elem = getnextelement(&data, i);    if (floatp(elem)) a.type = RE;#ifdef RATIOS    else if (ratiop(elem)) a.type = RE;#endif    else if (! fixp(elem)) xlerror("not a real number", elem);  }  /* allocate space for the data */  a.addr = xscall_alloc(a.size, (a.type == IN) ? sizeof(int) : sizeof(double));  /* fill the space */  for (i = 0, data = x; i < a.size; i++) {    elem = getnextelement(&data, i);    if (a.type == IN) ((int *) a.addr)[i] = getfixnum(elem);    else ((double *) a.addr)[i] = makedouble(elem);  }    xlpop();  return(a);}/* copy allocated pointer back to new lisp list */static LVAL arg2lisp(call_arg a){  LVAL x, next;  int i;  xlsave1(x);  x = mklist(a.size, NIL);  for (i = 0, next = x; i < a.size; i++, next = cdr(next)) {    if (a.type == IN) rplaca(next, cvfixnum((FIXTYPE) ((int *) a.addr)[i]));    else rplaca(next, cvflonum((FLOTYPE) ((double *) a.addr)[i]));  }  xlpop();  return(x);}/************************************************************************//**                                                                    **//**                 Foreign Function Call Function                     **//**                                                                    **//************************************************************************///	RAS:  replaced old xscall_cfun with this version of the Unix codeLVAL xscall_cfun(void) {  LVAL result, Lname, old_allocs, next;  call_arg args[MAXARGS], *pargs;  int nargs;  pfv_t pRoutine;						// RAS  char *name;    fixup_current_allocs;  xlstkcheck(3);  xlsave(old_allocs);  xlprotect(current_allocs);  xlsave(result);  old_allocs = current_allocs;  current_allocs = NIL;  /* get the routine pointer */  Lname = xlgastring();  name = (char *) getstring(Lname);  /*	RAS: replaced this code with LibrarySymbol call  pattern =  INTERNAL_CNAME_PATTERN;  sprintf(lbuf, pattern, getstring(name));  routine = (pfi_t) get_caddress(lbuf);   */  pRoutine = (pfv_t) LibrarySymbolAddr(name, kTVectSym);  if (! pRoutine) xlerror("can't find internal symbol by this name", Lname);  /* convert the arguments to allocated pointers */  for (nargs = 0; moreargs(); nargs++) {    if (nargs >= MAXARGS) xlfail("too many arguments");    args[nargs] = lisp2arg(xlgetarg());  }  /* make the call -- there must be a better way to do this;  RAS: added (*pRoutine) deref */  switch (nargs) {  case  0: (*pRoutine)(); break;  case  1: (*pRoutine)(args[0].addr); break;  case  2: (*pRoutine)(args[0].addr, args[1].addr); break;  case  3: (*pRoutine)(args[0].addr, args[1].addr, args[2].addr); break;  case  4:     (*pRoutine)(args[0].addr, args[1].addr, args[2].addr, args[3].addr);    break;  case  5:     (*pRoutine)(args[0].addr, args[1].addr, args[2].addr, args[3].addr, 	    args[4].addr);    break;  case  6:    (*pRoutine)(args[0].addr, args[1].addr, args[2].addr, args[3].addr,	    args[4].addr, args[5].addr);     break;  case  7:    (*pRoutine)(args[0].addr, args[1].addr, args[2].addr, args[3].addr,	    args[4].addr, args[5].addr, args[6].addr);     break;  case  8:    (*pRoutine)(args[0].addr, args[1].addr, args[2].addr, args[3].addr, 	    args[4].addr, args[5].addr, args[6].addr, args[7].addr);     break;  case  9:     (*pRoutine)(args[0].addr, args[1].addr, args[2].addr, args[3].addr, 	    args[4].addr, args[5].addr, args[6].addr, args[7].addr, 	    args[8].addr);     break;  case 10:     (*pRoutine)(args[0].addr, args[1].addr, args[2].addr, args[3].addr, 	    args[4].addr, args[5].addr, args[6].addr, args[7].addr, 	    args[8].addr, args[9].addr);     break;  case 11:     (*pRoutine)(args[0].addr, args[1].addr, args[2].addr, args[3].addr, 	    args[4].addr, args[5].addr, args[6].addr, args[7].addr, 	    args[8].addr, args[9].addr, args[10].addr);     break;  case 12:     (*pRoutine)(args[0].addr, args[1].addr, args[2].addr, args[3].addr, 	    args[4].addr, args[5].addr, args[6].addr, args[7].addr, 	    args[8].addr, args[9].addr, args[10].addr, args[11].addr);     break;  case 13:     (*pRoutine)(args[0].addr, args[1].addr, args[2].addr, args[3].addr, 	    args[4].addr, args[5].addr, args[6].addr, args[7].addr, 	    args[8].addr, args[9].addr, args[10].addr, args[11].addr,	    args[12].addr);     break;  case 14:     (*pRoutine)(args[0].addr, args[1].addr, args[2].addr, args[3].addr, 	    args[4].addr, args[5].addr, args[6].addr, args[7].addr, 	    args[8].addr, args[9].addr, args[10].addr, args[11].addr,	    args[12].addr,  args[13].addr);     break;  case 15:     (*pRoutine)(args[0].addr, args[1].addr, args[2].addr, args[3].addr, 	    args[4].addr, args[5].addr, args[6].addr, args[7].addr, 	    args[8].addr, args[9].addr, args[10].addr, args[11].addr,	    args[12].addr,  args[13].addr, args[14].addr);     break;  }    /* convert the pointers back to lists, grouped in a list */  result = (nargs > 0) ? mklist(nargs, NIL) : NIL;  for (next = result, pargs = args; consp(next); next = cdr(next), pargs++)    rplaca(next, arg2lisp(*pargs));    current_allocs = old_allocs;  xlpopn(3);  return(result);}